{"version":3,"file":"chunks/2177.667f131baf58ff913792.min.js","mappings":"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","sources":["webpack://@patternslib/patternslib/./node_modules/@tiptap/suggestion/dist/tiptap-suggestion.esm.js","webpack://@patternslib/patternslib/./node_modules/@patternslib/pat-tiptap/src/utils.js","webpack://@patternslib/patternslib/./node_modules/@patternslib/pat-tiptap/src/extensions/suggestion.js"],"sourcesContent":["import { PluginKey, Plugin } from 'prosemirror-state';\nimport { DecorationSet, Decoration } from 'prosemirror-view';\nimport { escapeForRegEx } from '@tiptap/core';\n\nfunction findSuggestionMatch(config) {\r\n    var _a;\r\n    const { char, allowSpaces, allowedPrefixes, startOfLine, $position, } = config;\r\n    const escapedChar = escapeForRegEx(char);\r\n    const suffix = new RegExp(`\\\\s${escapedChar}$`);\r\n    const prefix = startOfLine ? '^' : '';\r\n    const regexp = allowSpaces\r\n        ? new RegExp(`${prefix}${escapedChar}.*?(?=\\\\s${escapedChar}|$)`, 'gm')\r\n        : new RegExp(`${prefix}(?:^)?${escapedChar}[^\\\\s${escapedChar}]*`, 'gm');\r\n    const text = ((_a = $position.nodeBefore) === null || _a === void 0 ? void 0 : _a.isText) && $position.nodeBefore.text;\r\n    if (!text) {\r\n        return null;\r\n    }\r\n    const textFrom = $position.pos - text.length;\r\n    const match = Array.from(text.matchAll(regexp)).pop();\r\n    if (!match || match.input === undefined || match.index === undefined) {\r\n        return null;\r\n    }\r\n    // JavaScript doesn't have lookbehinds. This hacks a check that first character\r\n    // is a space or the start of the line\r\n    const matchPrefix = match.input.slice(Math.max(0, match.index - 1), match.index);\r\n    const matchPrefixIsAllowed = new RegExp(`^[${allowedPrefixes === null || allowedPrefixes === void 0 ? void 0 : allowedPrefixes.join('')}\\0]?$`).test(matchPrefix);\r\n    if (allowedPrefixes !== null && !matchPrefixIsAllowed) {\r\n        return null;\r\n    }\r\n    // The absolute position of the match in the document\r\n    const from = textFrom + match.index;\r\n    let to = from + match[0].length;\r\n    // Edge case handling; if spaces are allowed and we're directly in between\r\n    // two triggers\r\n    if (allowSpaces && suffix.test(text.slice(to - 1, to + 1))) {\r\n        match[0] += ' ';\r\n        to += 1;\r\n    }\r\n    // If the $position is located within the matched substring, return that range\r\n    if (from < $position.pos && to >= $position.pos) {\r\n        return {\r\n            range: {\r\n                from,\r\n                to,\r\n            },\r\n            query: match[0].slice(char.length),\r\n            text: match[0],\r\n        };\r\n    }\r\n    return null;\r\n}\n\nconst SuggestionPluginKey = new PluginKey('suggestion');\r\nfunction Suggestion({ pluginKey = SuggestionPluginKey, editor, char = '@', allowSpaces = false, allowedPrefixes = [' '], startOfLine = false, decorationTag = 'span', decorationClass = 'suggestion', command = () => null, items = () => [], render = () => ({}), allow = () => true, }) {\r\n    let props;\r\n    const renderer = render === null || render === void 0 ? void 0 : render();\r\n    const plugin = new Plugin({\r\n        key: pluginKey,\r\n        view() {\r\n            return {\r\n                update: async (view, prevState) => {\r\n                    var _a, _b, _c, _d, _e, _f, _g;\r\n                    const prev = (_a = this.key) === null || _a === void 0 ? void 0 : _a.getState(prevState);\r\n                    const next = (_b = this.key) === null || _b === void 0 ? void 0 : _b.getState(view.state);\r\n                    // See how the state changed\r\n                    const moved = prev.active && next.active && prev.range.from !== next.range.from;\r\n                    const started = !prev.active && next.active;\r\n                    const stopped = prev.active && !next.active;\r\n                    const changed = !started && !stopped && prev.query !== next.query;\r\n                    const handleStart = started || moved;\r\n                    const handleChange = changed && !moved;\r\n                    const handleExit = stopped || moved;\r\n                    // Cancel when suggestion isn't active\r\n                    if (!handleStart && !handleChange && !handleExit) {\r\n                        return;\r\n                    }\r\n                    const state = handleExit && !handleStart\r\n                        ? prev\r\n                        : next;\r\n                    const decorationNode = document.querySelector(`[data-decoration-id=\"${state.decorationId}\"]`);\r\n                    props = {\r\n                        editor,\r\n                        range: state.range,\r\n                        query: state.query,\r\n                        text: state.text,\r\n                        items: [],\r\n                        command: commandProps => {\r\n                            command({\r\n                                editor,\r\n                                range: state.range,\r\n                                props: commandProps,\r\n                            });\r\n                        },\r\n                        decorationNode,\r\n                        // virtual node for popper.js or tippy.js\r\n                        // this can be used for building popups without a DOM node\r\n                        clientRect: decorationNode\r\n                            ? () => {\r\n                                var _a;\r\n                                // because of `items` can be asynchrounous we’ll search for the current docoration node\r\n                                const { decorationId } = (_a = this.key) === null || _a === void 0 ? void 0 : _a.getState(editor.state); // eslint-disable-line\r\n                                const currentDecorationNode = document.querySelector(`[data-decoration-id=\"${decorationId}\"]`);\r\n                                return (currentDecorationNode === null || currentDecorationNode === void 0 ? void 0 : currentDecorationNode.getBoundingClientRect()) || null;\r\n                            }\r\n                            : null,\r\n                    };\r\n                    if (handleStart) {\r\n                        (_c = renderer === null || renderer === void 0 ? void 0 : renderer.onBeforeStart) === null || _c === void 0 ? void 0 : _c.call(renderer, props);\r\n                    }\r\n                    if (handleChange) {\r\n                        (_d = renderer === null || renderer === void 0 ? void 0 : renderer.onBeforeUpdate) === null || _d === void 0 ? void 0 : _d.call(renderer, props);\r\n                    }\r\n                    if (handleChange || handleStart) {\r\n                        props.items = await items({\r\n                            editor,\r\n                            query: state.query,\r\n                        });\r\n                    }\r\n                    if (handleExit) {\r\n                        (_e = renderer === null || renderer === void 0 ? void 0 : renderer.onExit) === null || _e === void 0 ? void 0 : _e.call(renderer, props);\r\n                    }\r\n                    if (handleChange) {\r\n                        (_f = renderer === null || renderer === void 0 ? void 0 : renderer.onUpdate) === null || _f === void 0 ? void 0 : _f.call(renderer, props);\r\n                    }\r\n                    if (handleStart) {\r\n                        (_g = renderer === null || renderer === void 0 ? void 0 : renderer.onStart) === null || _g === void 0 ? void 0 : _g.call(renderer, props);\r\n                    }\r\n                },\r\n                destroy: () => {\r\n                    var _a;\r\n                    if (!props) {\r\n                        return;\r\n                    }\r\n                    (_a = renderer === null || renderer === void 0 ? void 0 : renderer.onExit) === null || _a === void 0 ? void 0 : _a.call(renderer, props);\r\n                },\r\n            };\r\n        },\r\n        state: {\r\n            // Initialize the plugin's internal state.\r\n            init() {\r\n                const state = {\r\n                    active: false,\r\n                    range: {\r\n                        from: 0,\r\n                        to: 0,\r\n                    },\r\n                    query: null,\r\n                    text: null,\r\n                    composing: false,\r\n                };\r\n                return state;\r\n            },\r\n            // Apply changes to the plugin state from a view transaction.\r\n            apply(transaction, prev, oldState, state) {\r\n                const { isEditable } = editor;\r\n                const { composing } = editor.view;\r\n                const { selection } = transaction;\r\n                const { empty, from } = selection;\r\n                const next = { ...prev };\r\n                next.composing = composing;\r\n                // We can only be suggesting if the view is editable, and:\r\n                //   * there is no selection, or\r\n                //   * a composition is active (see: https://github.com/ueberdosis/tiptap/issues/1449)\r\n                if (isEditable && (empty || editor.view.composing)) {\r\n                    // Reset active state if we just left the previous suggestion range\r\n                    if (((from < prev.range.from) || from > prev.range.to)\r\n                        && !composing\r\n                        && !prev.composing) {\r\n                        next.active = false;\r\n                    }\r\n                    // Try to match against where our cursor currently is\r\n                    const match = findSuggestionMatch({\r\n                        char,\r\n                        allowSpaces,\r\n                        allowedPrefixes,\r\n                        startOfLine,\r\n                        $position: selection.$from,\r\n                    });\r\n                    const decorationId = `id_${Math.floor(Math.random() * 0xFFFFFFFF)}`;\r\n                    // If we found a match, update the current state to show it\r\n                    if (match && allow({ editor, state, range: match.range })) {\r\n                        next.active = true;\r\n                        next.decorationId = prev.decorationId ? prev.decorationId : decorationId;\r\n                        next.range = match.range;\r\n                        next.query = match.query;\r\n                        next.text = match.text;\r\n                    }\r\n                    else {\r\n                        next.active = false;\r\n                    }\r\n                }\r\n                else {\r\n                    next.active = false;\r\n                }\r\n                // Make sure to empty the range if suggestion is inactive\r\n                if (!next.active) {\r\n                    next.decorationId = null;\r\n                    next.range = { from: 0, to: 0 };\r\n                    next.query = null;\r\n                    next.text = null;\r\n                }\r\n                return next;\r\n            },\r\n        },\r\n        props: {\r\n            // Call the keydown hook if suggestion is active.\r\n            handleKeyDown(view, event) {\r\n                var _a;\r\n                const { active, range } = plugin.getState(view.state);\r\n                if (!active) {\r\n                    return false;\r\n                }\r\n                return ((_a = renderer === null || renderer === void 0 ? void 0 : renderer.onKeyDown) === null || _a === void 0 ? void 0 : _a.call(renderer, { view, event, range })) || false;\r\n            },\r\n            // Setup decorator on the currently active suggestion.\r\n            decorations(state) {\r\n                const { active, range, decorationId } = plugin.getState(state);\r\n                if (!active) {\r\n                    return null;\r\n                }\r\n                return DecorationSet.create(state.doc, [\r\n                    Decoration.inline(range.from, range.to, {\r\n                        nodeName: decorationTag,\r\n                        class: decorationClass,\r\n                        'data-decoration-id': decorationId,\r\n                    }),\r\n                ]);\r\n            },\r\n        },\r\n    });\r\n    return plugin;\r\n}\n\nexport { Suggestion, SuggestionPluginKey, Suggestion as default, findSuggestionMatch };\n//# sourceMappingURL=tiptap-suggestion.esm.js.map\n","export const add_search_params = (url, params = {}) => {\n    // See: https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams/URLSearchParams#examples\n    const url_obj = new URL(url, window.location.href);\n    return `${url_obj.origin}${url_obj.pathname}?${new URLSearchParams([\n        ...Array.from(url_obj.searchParams.entries()),\n        ...Object.entries(params),\n    ]).toString()}`;\n};\n\n// Export a list of WAI attributes.\nexport const accessibility_attributes = [\n    \"aria-activedescendant\",\n    \"aria-atomic\",\n    \"aria-autocomplete\",\n    \"aria-busy\",\n    \"aria-checked\",\n    \"aria-controls\",\n    \"aria-describedby\",\n    \"aria-disabled\",\n    \"aria-dropeffect\",\n    \"aria-expanded\",\n    \"aria-flowto\",\n    \"aria-grabbed\",\n    \"aria-haspopup\",\n    \"aria-hidden\",\n    \"aria-invalid\",\n    \"aria-label\",\n    \"aria-labelledby\",\n    \"aria-level\",\n    \"aria-live\",\n    \"aria-multiline\",\n    \"aria-multiselectable\",\n    \"aria-orientation\",\n    \"aria-owns\",\n    \"aria-posinset\",\n    \"aria-pressed\",\n    \"aria-readonly\",\n    \"aria-relevant\",\n    \"aria-required\",\n    \"aria-selected\",\n    \"aria-setsize\",\n    \"aria-sort\",\n    \"aria-valuemax\",\n    \"aria-valuemin\",\n    \"aria-valuenow\",\n    \"aria-valuetext\",\n    \"role\",\n];\n\nexport default {\n    add_search_params: add_search_params,\n    accessibility_attributes: accessibility_attributes,\n};\n","import { Node, mergeAttributes } from \"@tiptap/core\";\nimport { PluginKey } from \"prosemirror-state\";\nimport { Suggestion as ProseMirrorSuggestion } from \"@tiptap/suggestion\";\nimport { context_menu, context_menu_close } from \"../context_menu\";\nimport { focus_handler } from \"../focus-handler\";\nimport dom from \"@patternslib/patternslib/src/core/dom\";\nimport events from \"@patternslib/patternslib/src/core/events\";\nimport utils from \"@patternslib/patternslib/src/core/utils\";\nimport tiptap_utils from \"../utils\";\n\nlet context_menu_instance;\n\nfunction pattern_suggestion(app, props) {\n    // Dynamic pattern for the suggestion context menu\n    return {\n        name: \"tiptap-suggestion\",\n        trigger: \".tiptap-items\",\n        init($el) {\n            this.el = $el[0];\n\n            if (dom.get_data(this.el, this.name)) {\n                // Prevent double initialization.\n                return;\n            }\n            dom.set_data(this.el, this.name, this);\n\n            focus_handler(this.el);\n\n            this.active = this.items[0];\n\n            // Support selections via keyboard navigation.\n            events.add_event_listener(\n                this.el,\n                \"keydown\",\n                \"tiptap-suggestion-keydown\",\n                (e) => {\n                    e.preventDefault();\n                    e.stopPropagation();\n\n                    if (e.code === \"ArrowDown\") {\n                        // Select next or first.\n                        if (!this.active) {\n                            this.active = this.items[0];\n                        } else {\n                            let next = this.active\n                                ? this.items.indexOf(this.active) + 1\n                                : 0;\n                            if (next >= this.items.length) {\n                                // circular selection mode, start with first.\n                                next = 0;\n                                // TODO: should we load the next batch?\n                            }\n                            this.active = this.items[next];\n                        }\n                    } else if (e.code === \"ArrowUp\") {\n                        // Select previous or last.\n                        if (!this.active) {\n                            this.active = this.items[0];\n                        } else {\n                            let prev = this.active\n                                ? this.items.indexOf(this.active) - 1\n                                : 0;\n                            if (prev < 0) {\n                                // back to first\n                                prev = this.items.length - 1;\n                                // TODO: should we load the previous batch?\n                            }\n                            this.active = this.items[prev];\n                        }\n                    } else if (e.code === \"Enter\") {\n                        // Use selected to insert in text area.\n                        const value = this.active?.dataset?.tiptapValue;\n                        if (!value) {\n                            // nothing selected.\n                            return;\n                        }\n\n                        const el = this.active.querySelector(\"a\");\n                        this.command(el, value);\n                    }\n                }\n            );\n\n            // Select and insert to text area by clicking.\n            events.add_event_listener(\n                this.el,\n                \"click\",\n                \"tiptap-suggestion-click\",\n                (e) => {\n                    const el = e.target.closest(\"a\");\n                    const value = dom.acquire_attribute(el, \"data-tiptap-value\");\n                    if (!value) {\n                        // clicked anywhere, but not on a selection item\n                        return;\n                    }\n\n                    e.preventDefault();\n                    this.command(el, value);\n                }\n            );\n        },\n\n        command(el, value) {\n            const attributes = Object.fromEntries(\n                [...el.attributes].map((it) => [it.name, it.value])\n            );\n            props.command({\n                \"data-title\": value,\n                ...attributes,\n            });\n        },\n\n        get active() {\n            // Get the currently selected item.\n            return this.el.querySelector(\".tiptap-item.active\");\n        },\n\n        set active(el) {\n            if (!el) {\n                // No item available, e.g. no search results and thus not this.items.\n                return;\n            }\n            // Set an item to be selected.\n            this.active?.classList.remove(\"active\");\n            el.classList.add(\"active\");\n        },\n\n        get items() {\n            // Get all items.\n            return [...this.el.querySelectorAll(\".tiptap-item\")];\n        },\n    };\n}\n\nexport const factory = ({ app, name, char, plural }) => {\n    return Node.create({\n        name: name,\n        group: \"inline\",\n        inline: true,\n        selectable: false,\n        atom: true,\n\n        addOptions() {\n            return {\n                HTMLAttributes: {},\n                url: null,\n                renderLabel({ options, node }) {\n                    return `${options.suggestion.char}${node.attrs[\"data-title\"]}`;\n                },\n                suggestion: {\n                    char: char,\n                    pluginKey: new PluginKey(name),\n                },\n            };\n        },\n\n        addAttributes() {\n            const attributes = {\n                \"class\": {},\n                \"href\": {},\n                \"target\": {},\n                \"title\": {},\n                \"data-id\": {},\n                \"data-title\": {},\n                // add a lot of patterns data attributes...\n                \"data-pat-inject\": {},\n                \"data-pat-forward\": {},\n                \"data-pat-modal\": {},\n                \"data-pat-switch\": {},\n                \"data-pat-toggle\": {},\n                \"data-pat-tooltip\": {},\n            };\n\n            // Needs to be always included. A default of \"\" makes sure it is.\n            attributes[`data-${this.name}`] = { default: \"\" };\n\n            for (const attr of tiptap_utils.accessibility_attributes) {\n                // Add a bunch of accessibility attributes\n                attributes[attr] = {};\n            }\n\n            return attributes;\n        },\n\n        parseHTML() {\n            return [\n                {\n                    tag: `a[data-${this.name}]`,\n                },\n            ];\n        },\n\n        renderHTML({ node, HTMLAttributes }) {\n            return [\n                \"a\",\n                mergeAttributes(this.options.HTMLAttributes, HTMLAttributes),\n                this.options.renderLabel({\n                    options: this.options,\n                    node,\n                }),\n            ];\n        },\n\n        renderText({ node }) {\n            return this.options.renderLabel({\n                options: this.options,\n                node,\n            });\n        },\n\n        addKeyboardShortcuts() {\n            return {\n                Enter: () => {\n                    if (context_menu_instance) {\n                        // While suggestion menu is open, do not add a line-break to the text.\n                        // Handle the ``Enter`` key as early as possible to prevent a line-break to happen.\n\n                        // Dispatch the event to the context menu pattern\n                        // while still keeping the focus in the textarea.\n                        context_menu_instance.tippy?.popper\n                            ?.querySelector(\".tiptap-items\")\n                            ?.dispatchEvent(\n                                new KeyboardEvent(\"keydown\", {\n                                    code: \"Enter\",\n                                })\n                            );\n\n                        return true;\n                    }\n                    // Normal case, do not prevent the Enter key to add a line break.\n                    return false;\n                },\n\n                Backspace: ({ editor }) =>\n                    editor.commands.command(({ tr, state }) => {\n                        let is_suggestion = false;\n                        const { selection } = state;\n                        const { empty, anchor } = selection;\n\n                        if (!empty) {\n                            return false;\n                        }\n\n                        state.doc.nodesBetween(anchor - 1, anchor, (node, pos) => {\n                            if (node.type.name === this.name) {\n                                is_suggestion = true;\n                                tr.insertText(\n                                    this.options.suggestion.char || \"\",\n                                    pos,\n                                    pos + node.nodeSize\n                                );\n\n                                return false;\n                            }\n                        });\n\n                        return is_suggestion;\n                    }),\n            };\n        },\n\n        addProseMirrorPlugins() {\n            // Suggestion command\n            this.options.suggestion.command = ({ editor, range, props }) => {\n                // Extend range until current cursor position.\n                range.to = editor.state.selection.$head.pos;\n                editor\n                    .chain()\n                    .focus()\n                    .insertContentAt(range, [\n                        {\n                            type: this.name,\n                            attrs: props,\n                        },\n                        {\n                            type: \"text\",\n                            text: \" \",\n                        },\n                    ])\n                    .run();\n            };\n\n            // Suggestion render\n            this.options.suggestion.render = () => {\n                let _debounced_context_menu;\n\n                const ctx_close = () => {\n                    context_menu_close({\n                        instance: context_menu_instance,\n                        pattern_name: \"tiptap-suggestion\",\n                    });\n                    context_menu_instance = null;\n                    this.editor.off(\"selectionUpdate\", _debounced_context_menu);\n                };\n\n                return {\n                    onStart: async (props) => {\n                        const _context_menu = async (\n                            { transaction } = { transaction: null } // optional destructuring\n                        ) => {\n                            // If the transaction parameter is given then this\n                            // is a ``selectionUpdate``.\n                            let url = this.options.url;\n\n                            // Now get the text and pass it to the backend to\n                            // query for the filter value.\n                            //\n                            // Get the text input between the suggestion\n                            // character and the cursor.\n                            // This is then used to filter items and submitted\n                            // as query string to the server.\n                            let from = props.range.from + 1; // start w/out suggestion character.\n                            let to = transaction\n                                ? transaction.curSelection.$head.pos\n                                : props.range.to;\n                            const text = this.editor.state.doc.textBetween(from, to, \"\"); // prettier-ignore\n\n                            // Add query string filter value.\n                            // The query string filter key must be already present on the URL.\n                            url = text ? url + text : url;\n\n                            const ctx_menu = await context_menu({\n                                url: url,\n                                editor: this.editor,\n                                instance: context_menu_instance,\n                                pattern: pattern_suggestion(app, props),\n                                extra_class: `tiptap-${plural || this.name}`, // plural form\n                            });\n\n                            return ctx_menu;\n                        };\n                        _debounced_context_menu = utils.debounce(async (transaction) => {\n                            context_menu_instance = await _context_menu(transaction);\n                        }, 200);\n\n                        // Immediately open the suggestion context menu.\n                        context_menu_instance = await _context_menu();\n\n                        // ... and reload it after text input after a short timeout.\n                        this.editor.on(\"selectionUpdate\", _debounced_context_menu);\n                    },\n                    onKeyDown: (props) => {\n                        if (!context_menu_instance) {\n                            //No context menu open, return.\n                            return;\n                        }\n\n                        if (\n                            props.event.key === \"ArrowDown\" ||\n                            props.event.key === \"ArrowUp\" ||\n                            props.event.key === \"Enter\"\n                        ) {\n                            props.event.preventDefault();\n                            props.event.stopPropagation();\n                            const ctx = document.querySelector(\".tiptap-items\");\n                            if (!ctx) {\n                                return;\n                            }\n\n                            // Dispatch the event to the context menu pattern\n                            // while still keeping the focus in the textarea.\n                            ctx.dispatchEvent(\n                                new KeyboardEvent(\"keydown\", {\n                                    code: props.event.key,\n                                })\n                            );\n                        }\n                    },\n                    onExit: () => {\n                        ctx_close();\n                    },\n                };\n            };\n\n            // Suggestion allow\n            this.options.suggestion.allow = ({ state, range }) => {\n                const $from = state.doc.resolve(range.from);\n                const type = state.schema.nodes[this.name];\n                const allow = !!$from.parent.type.contentMatch.matchType(type);\n\n                return allow;\n            };\n\n            return [\n                ProseMirrorSuggestion({\n                    editor: this.editor,\n                    ...this.options.suggestion,\n                }),\n            ];\n        },\n    });\n};\n"],"names":["SuggestionPluginKey","Suggestion","pluginKey","editor","char","allowSpaces","allowedPrefixes","startOfLine","decorationTag","decorationClass","command","items","render","allow","props","renderer","plugin","key","view","update","async","prevState","_a","_b","_c","_d","_e","_f","_g","prev","this","getState","next","state","moved","active","range","from","started","stopped","handleStart","handleChange","query","handleExit","decorationNode","document","querySelector","decorationId","text","commandProps","clientRect","currentDecorationNode","getBoundingClientRect","onBeforeStart","call","onBeforeUpdate","onExit","onUpdate","onStart","destroy","init","to","composing","apply","transaction","oldState","isEditable","selection","empty","match","config","$position","escapedChar","escapeForRegEx","suffix","RegExp","prefix","regexp","nodeBefore","isText","textFrom","pos","length","Array","matchAll","pop","undefined","input","index","matchPrefix","slice","Math","max","matchPrefixIsAllowed","join","test","findSuggestionMatch","$from","floor","random","handleKeyDown","event","onKeyDown","decorations","doc","nodeName","class","context_menu_instance","i","pattern_suggestion","app","name","trigger","$el","el","dom","focus_handler","events","e","preventDefault","stopPropagation","code","indexOf","value","dataset","tiptapValue","target","closest","attributes","Object","fromEntries","map","it","classList","remove","add","querySelectorAll","factory","plural","Node","group","inline","selectable","atom","addOptions","HTMLAttributes","url","renderLabel","options","node","suggestion","attrs","PluginKey","addAttributes","default","tiptap_utils","parseHTML","tag","renderHTML","mergeAttributes","renderText","addKeyboardShortcuts","Enter","tippy","popper","dispatchEvent","KeyboardEvent","Backspace","commands","tr","is_suggestion","anchor","nodesBetween","type","insertText","nodeSize","addProseMirrorPlugins","$head","chain","focus","insertContentAt","run","_debounced_context_menu","_context_menu","curSelection","textBetween","context_menu","instance","pattern","extra_class","ctx_menu","utils","on","ctx","context_menu_close","pattern_name","off","resolve","schema","nodes","parent","contentMatch","matchType","ProseMirrorSuggestion"],"sourceRoot":""}