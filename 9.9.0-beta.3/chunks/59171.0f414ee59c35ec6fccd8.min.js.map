{"version":3,"file":"chunks/59171.0f414ee59c35ec6fccd8.min.js","mappings":"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","sources":["webpack://@patternslib/patternslib/./node_modules/@patternslib/pat-tiptap/src/context_menu.js","webpack://@patternslib/patternslib/./node_modules/@patternslib/pat-tiptap/src/extensions/image-figure.js","webpack://@patternslib/patternslib/./node_modules/@patternslib/pat-tiptap/src/focus-handler.js"],"sourcesContent":["import registry from \"@patternslib/patternslib/src/core/registry\";\nimport dom from \"@patternslib/patternslib/src/core/dom\";\nimport events from \"@patternslib/patternslib/src/core/events\";\nimport patTooltip from \"@patternslib/patternslib/src/pat/tooltip/tooltip\";\nimport { posToDOMRect } from \"@tiptap/core\";\n\nlet PREV_NODE = null;\n\nexport async function context_menu({\n    url,\n    editor,\n    instance = null,\n    pattern = null,\n    extra_class = null,\n}) {\n    const prev_node = PREV_NODE;\n    const cur_node = (PREV_NODE = editor.state.doc.nodeAt(editor.state.selection.from));\n\n    if (\n        instance !== null &&\n        (cur_node !== prev_node || !instance?.tippy.popperInstance)\n    ) {\n        // Close context menu, when new node is selected.\n        await context_menu_close({\n            instance: instance,\n            pattern_name: pattern.name,\n        });\n        instance = null;\n    }\n\n    if (!instance || !instance?.tippy.popperInstance) {\n        // Only re-initialize when not already opened.\n\n        // 1) Dynamically register a pattern to be used in the context menu\n        //    We need to unregister it after use in ``context_menu_close``\n        //    to allow multiple tiptap editors on the same page because it\n        //    references the current editor instance.\n        if (pattern) {\n            registry.patterns[pattern.name] = pattern;\n        }\n\n        // 2) Initialize the tooltip\n        const editor_element = editor.options.element;\n        instance = new patTooltip(editor_element, {\n            \"source\": \"ajax\",\n            \"url\": url,\n            \"trigger\": \"none\",\n            \"class\": extra_class,\n            \"position-list\": [\"tl\"],\n        });\n\n        await events.await_pattern_init(instance);\n\n        const reference_position = posToDOMRect(\n            editor.view,\n            editor.state.selection.from,\n            editor.state.selection.to\n        );\n\n        instance.tippy?.setProps({\n            // NOTE: getReferenceClientRect is called after each setContent.\n            getReferenceClientRect: () => reference_position,\n        });\n\n        events.add_event_listener(\n            document,\n            \"mousedown\",\n            \"tiptap--context_menu_close--click\",\n            async (e) => {\n                if (\n                    [e.target, ...dom.get_parents(e.target)].includes(\n                        instance?.tippy.popper\n                    )\n                ) {\n                    // Do not close the context menu if we click in it.\n                    return;\n                }\n                await context_menu_close({\n                    instance: instance,\n                    pattern_name: pattern.name,\n                });\n                instance = null;\n            }\n        );\n        events.add_event_listener(\n            document,\n            \"keydown\",\n            \"tiptap--context_menu_close--esc\",\n            async (e) => {\n                if (e.key !== \"Escape\") {\n                    // Not a closing key.\n                    return;\n                }\n                await context_menu_close({\n                    instance: instance,\n                    pattern_name: pattern.name,\n                });\n                instance = null;\n            }\n        );\n\n        instance.show();\n    } else {\n        instance.get_content(url);\n    }\n\n    return instance;\n}\n\nexport async function context_menu_close({ instance, pattern_name }) {\n    // Hide and destroy the context menu / tooltip instance\n    if (instance) {\n        await instance.hide();\n        instance.destroy();\n        instance = null;\n    }\n\n    // Unregister the pattern\n    if (pattern_name) {\n        delete registry.patterns[pattern_name];\n    }\n    events.remove_event_listener(document, \"tiptap--context_menu_close--click\");\n    events.remove_event_listener(document, \"tiptap--context_menu_close--esc\");\n    return null;\n}\n","import { context_menu, context_menu_close } from \"../context_menu\";\nimport { focus_handler } from \"../focus-handler\";\nimport { Node, mergeAttributes } from \"@tiptap/core\";\nimport { Plugin } from \"prosemirror-state\";\nimport { BasePattern } from \"@patternslib/patternslib/src/core/basepattern\";\nimport dom from \"@patternslib/patternslib/src/core/dom\";\nimport events from \"@patternslib/patternslib/src/core/events\";\nimport utils from \"@patternslib/patternslib/src/core/utils\";\n\nlet context_menu_instance;\n\nfunction pattern_image_context_menu({ app: app }) {\n    class Pattern extends BasePattern {\n        static name = \"tiptap-image-context-menu\";\n        static trigger = \".tiptap-image-context-menu\";\n\n        init() {\n            focus_handler(this.el);\n\n            const btn_edit = this.el.querySelector(\".tiptap-edit-image\");\n            const btn_remove = this.el.querySelector(\".tiptap-remove-image\");\n\n            btn_edit &&\n                btn_edit.addEventListener(\"click\", () => {\n                    app.toolbar.image.click();\n                });\n\n            btn_remove &&\n                btn_remove.addEventListener(\"click\", () => {\n                    app.editor.commands.selectParentNode(); // Also select the surrounding <figure>\n                    app.editor.commands.deleteSelection();\n                    app.editor.commands.focus();\n                });\n        }\n    }\n\n    return Pattern;\n}\n\nfunction image_panel({ app }) {\n    // Not Base-pattern based due to two reasons:\n    // - We need to reinitialize the pattern on already initialized nodes on possible tab-changes within the modal.\n    // - We need to keep the _node_image and _figcaption references among re-initializations.\n    return {\n        name: \"tiptap-image-panel\",\n        trigger: app.options.image?.panel,\n\n        init(image_panel) {\n            const image_srcs = image_panel.querySelectorAll(\"[name=tiptap-src]\");\n            const image_alt = image_panel.querySelector(\"[name=tiptap-alt]\");\n            const image_title = image_panel.querySelector(\"[name=tiptap-title]\");\n            const image_caption = image_panel.querySelector(\"[name=tiptap-caption]\");\n            const image_confirm = image_panel.querySelector(\".tiptap-confirm, [name=tiptap-confirm]\"); // prettier-ignore\n            focus_handler(image_panel);\n\n            const node_image = this.node_image;\n\n            // Populate form fields\n            if (node_image) {\n                const current_src = node_image.attrs?.src;\n                // Filter for all inputs with the same src value but not an empty src.\n                let image_srcs_ = current_src\n                    ? [...image_srcs].filter((it) => it.value === current_src)\n                    : [];\n                if (image_srcs_.length > 0) {\n                    for (const image_src of image_srcs_) {\n                        image_src.checked = true;\n                        image_src.dispatchEvent(events.change_event());\n                    }\n                } else {\n                    let image_srcs_ = [...image_srcs].filter(\n                        (it) => it.type === \"text\" || it.type === \"url\"\n                    );\n                    if (image_srcs_.length > 0 && !image_srcs_[0].value) {\n                        image_srcs_[0].value = current_src || \"\";\n                    }\n                }\n                if (image_title && !image_title.value) {\n                    image_title.value = node_image.attrs?.title || \"\";\n                }\n                if (image_alt && !image_alt.value) {\n                    image_alt.value = node_image.attrs?.alt || \"\";\n                }\n            }\n\n            // Get / set figcaption node, if it exists\n            const node_figcaption = this.figcaption_node;\n            if (node_figcaption && image_caption && !image_caption.value) {\n                image_caption.value = node_figcaption.textContent || \"\";\n            }\n\n            const update_callback = (set_focus) => {\n                // Get the selected image on time of submitting\n                const selected_image_src = image_panel.querySelector(\n                    `[name=tiptap-src][type=radio]:checked,\n                         [name=tiptap-src][type=checkbox]:checked,\n                         [name=tiptap-src][type=option]:checked,\n                         [name=tiptap-src][type=hidden],\n                         [name=tiptap-src][type=text],\n                         [name=tiptap-src][type=url]`\n                );\n\n                app.editor.commands.insertContent({\n                    type: \"figure\",\n                    content: [\n                        {\n                            type: \"image-figure\",\n                            attrs: {\n                                src: selected_image_src.value,\n                                ...(image_alt?.value && { alt: image_alt.value }),\n                                ...(image_title?.value && {\n                                    title: image_title.value,\n                                }),\n                            },\n                        },\n                        // Conditionally add a figcaption\n                        ...(image_caption?.value\n                            ? [\n                                  {\n                                      type: \"figcaption\",\n                                      content: [\n                                          {\n                                              type: \"text\",\n                                              text: image_caption.value,\n                                          },\n                                      ],\n                                  },\n                              ]\n                            : []),\n                    ],\n                });\n                if (set_focus === true) {\n                    // set cursor after the image, otherwise image is\n                    // selected and right away deleted when starting typing.\n                    app.editor.commands.selectParentNode();\n                    app.editor.commands.focus(app.editor.state.selection.to);\n                    //app.editor.commands.blur();\n                }\n            };\n\n            // FORM UPDATE\n            const form = dom.querySelectorAllAndMe(image_panel, \"form\")?.[0];\n            if (form) {\n                events.add_event_listener(form, \"submit\", \"tiptap_image_submit\", (e) => {\n                    // Prevent form submission when hitting \"enter\" within the form.\n                    // The form is handled by JS only.\n                    e.preventDefault();\n                });\n            }\n            if (image_confirm) {\n                // update on click on confirm\n                events.add_event_listener(\n                    image_confirm,\n                    \"click\",\n                    \"tiptap_image_confirm\",\n                    () => update_callback(true)\n                );\n            } else {\n                // update on input/change\n                for (const image_src of image_srcs) {\n                    events.add_event_listener(\n                        image_src,\n                        \"change\",\n                        \"tiptap_image_src\",\n                        update_callback\n                    );\n                }\n                events.add_event_listener(\n                    image_alt,\n                    \"change\",\n                    \"tiptap_image_alt\",\n                    update_callback\n                );\n                events.add_event_listener(\n                    image_title,\n                    \"change\",\n                    \"tiptap_image_title\",\n                    update_callback\n                );\n                events.add_event_listener(\n                    image_caption,\n                    \"change\",\n                    \"tiptap_image_caption\",\n                    update_callback\n                );\n            }\n        },\n\n        _node_image: null,\n        get node_image() {\n            // Get image node\n            if (this._node_image || this._node_image === undefined) {\n                return this._node_image;\n            }\n            this._node_image = app.editor.state.doc.nodeAt(\n                app.editor.state.selection.from\n            );\n            return this._node_image;\n        },\n\n        _figcaption: null, // initialized as null. If not found this will be set to undefined.\n        get figcaption_node() {\n            // Return cached figcaption and avoid calling this method multiple times.\n            // Calling it again would select again a parent node which would lead to incorrect results.\n            if (this._figcaption || this._figcaption === undefined) {\n                return this._figcaption;\n            }\n\n            app.editor.commands.selectParentNode(); // Also select the surrounding <figure>\n            const node_figure = app.editor.state.doc.nodeAt(\n                app.editor.state.selection.from\n            );\n            const node_figcaption = node_figure?.content.content.filter(\n                (it) => it.type.name === \"figcaption\"\n            )?.[0];\n            this._figcaption = node_figcaption; // if not found, this is undefined.\n            return node_figcaption;\n        },\n    };\n}\n\nexport function init({ app, button }) {\n    button.addEventListener(\"click\", () => {\n        if (dom.get_data(app.toolbar_el, \"tiptap-instance\", null) !== app) {\n            // If this pat-tiptap instance is not the one which was last\n            // focused, just return and do nothing.\n            // This might be due to one toolbar shared by multiple editors.\n            return;\n        }\n\n        // Register the image-panel pattern.\n        // Multiple registrations from different tiptap instances are possible\n        // since we're registering it only after the toolbar's image button has\n        // been clicked and clicking in another tiptap instance would override\n        // previous registrations.\n        const image_panel_pattern = image_panel({ app: app });\n        document.addEventListener(\n            \"patterns-injected-delayed\",\n            (e) => {\n                image_panel_pattern.init(e.detail.injected);\n\n                // Register listener on modal for any DOM changes done by pat-inject.\n                app.current_modal.addEventListener(\"patterns-injected-delayed\", () => {\n                    // Re-init panel after injection.\n                    image_panel_pattern.init(app.current_modal);\n                });\n            },\n            { once: true }\n        );\n    });\n\n    app.editor.on(\"selectionUpdate\", async () => {\n        app.editor.isActive(\"image-figure\")\n            ? button.classList.add(\"active\")\n            : button.classList.remove(\"active\");\n        app.editor.can().setImage()\n            ? button.classList.remove(\"disabled\")\n            : button.classList.add(\"disabled\");\n\n        if (!app.options.image.menu) {\n            // Nothing to do, return.\n            return;\n        }\n\n        // Open the context menu with a small delay.\n        utils.debounce(async () => {\n            if (!app.editor.isActive(\"image-figure\")) {\n                // Image not active anymore. Return.\n                if (context_menu_instance) {\n                    // If open, close.\n                    await context_menu_close({\n                        instance: context_menu_instance,\n                        pattern_name: \"tiptap-image-context-menu\",\n                    });\n                    context_menu_instance = null;\n                }\n                return;\n            }\n\n            // Initialize the context menu\n            context_menu_instance = await context_menu({\n                url: app.options.image.menu,\n                editor: app.editor,\n                instance: context_menu_instance,\n                pattern: pattern_image_context_menu({ app: app }),\n                extra_class: \"tiptap-image-menu\",\n            });\n        }, 50)();\n    });\n}\n\nexport const factory = () => {\n    return Node.create({\n        name: \"image-figure\",\n\n        addOptions() {\n            return {\n                HTMLAttributes: {},\n            };\n        },\n\n        addAttributes() {\n            return {\n                src: {\n                    default: null,\n                },\n                alt: {\n                    default: null,\n                },\n                title: {\n                    default: null,\n                },\n            };\n        },\n\n        group: \"block\",\n        inline: false,\n\n        allowGapCursor: false,\n        atom: true,\n        draggable: false,\n        isolating: true,\n        selectable: true,\n\n        parseHTML() {\n            return [\n                {\n                    tag: \"img\",\n                    getAttrs: (node) => node.closest(\"figure\") !== null && null, // prosemirror expects null for a successful check.\n                },\n            ];\n        },\n\n        renderHTML({ HTMLAttributes }) {\n            return [\"img\", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];\n        },\n\n        addProseMirrorPlugins() {\n            return [\n                new Plugin({\n                    props: {\n                        handleDOMEvents: {\n                            dragstart: (view, event) => {\n                                // prevent drag/drop at all.\n                                event.preventDefault();\n                                return false;\n                            },\n                        },\n                    },\n                }),\n            ];\n        },\n    });\n};\n","import events from \"@patternslib/patternslib/src/core/events\";\nimport utils from \"@patternslib/patternslib/src/core/utils\";\n\nexport const TARGETS = [];\n\nexport function focus_handler(el) {\n    // make element focusable\n    // See: https://javascript.info/focus-blur\n    el.setAttribute(\"tabindex\", \"-1\"); // not user-selectable but programmatically focusable.\n    events.add_event_listener(\n        el,\n        \"focus\",\n        \"tiptap-focusin\",\n        async () => {\n            utils.timeout(1); // short timeout to ensure focus class is set even if tiptap_blur_handler is called concurrently.\n            TARGETS.map((it) => it?.classList.add(\"tiptap-focus\"));\n        },\n        true\n    );\n    events.add_event_listener(\n        el,\n        \"blur\",\n        \"tiptap-focusout\",\n        () => {\n            TARGETS.map((it) => it?.classList.remove(\"tiptap-focus\"));\n        },\n        true\n    );\n}\n"],"names":["PREV_NODE","async","context_menu","_ref","url","editor","instance","pattern","extra_class","prev_node","cur_node","state","doc","nodeAt","selection","from","tippy","popperInstance","context_menu_close","pattern_name","name","get_content","registry","editor_element","options","element","patTooltip","events","reference_position","posToDOMRect","view","to","setProps","getReferenceClientRect","document","e","target","dom","includes","popper","key","show","_ref2","hide","destroy","context_menu_instance","pattern_image_context_menu","app","Pattern","BasePattern","static","init","focus_handler","this","el","btn_edit","querySelector","btn_remove","addEventListener","toolbar","image","click","commands","selectParentNode","deleteSelection","focus","_ref3","button","toolbar_el","image_panel_pattern","trigger","panel","image_panel","image_srcs","querySelectorAll","image_alt","image_title","image_caption","image_confirm","node_image","current_src","attrs","src","image_srcs_","filter","it","value","length","image_src","checked","dispatchEvent","type","title","alt","node_figcaption","figcaption_node","textContent","update_callback","set_focus","selected_image_src","insertContent","content","text","form","preventDefault","_node_image","undefined","_figcaption","node_figure","detail","injected","current_modal","once","on","isActive","classList","add","remove","can","setImage","menu","utils","factory","Node","addOptions","HTMLAttributes","addAttributes","default","group","inline","allowGapCursor","atom","draggable","isolating","selectable","parseHTML","tag","getAttrs","node","closest","renderHTML","_ref4","mergeAttributes","addProseMirrorPlugins","Plugin","props","handleDOMEvents","dragstart","event","TARGETS","setAttribute","map"],"sourceRoot":""}