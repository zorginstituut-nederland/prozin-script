{"version":3,"file":"chunks/91347.f2602fb47a64c38baeb0.min.js","mappings":"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","sources":["webpack://@patternslib/patternslib/./node_modules/prosemirror-tables/dist/index.js","webpack://@patternslib/patternslib/./node_modules/@tiptap/extension-table/dist/index.js"],"sourcesContent":["// src/index.ts\nimport { Plugin as Plugin2 } from \"prosemirror-state\";\n\n// src/cellselection.ts\nimport { Fragment, Slice } from \"prosemirror-model\";\nimport {\n  NodeSelection as NodeSelection2,\n  Selection,\n  SelectionRange,\n  TextSelection\n} from \"prosemirror-state\";\nimport { Decoration, DecorationSet } from \"prosemirror-view\";\n\n// src/tablemap.ts\nvar readFromCache;\nvar addToCache;\nif (typeof WeakMap != \"undefined\") {\n  let cache = /* @__PURE__ */ new WeakMap();\n  readFromCache = (key) => cache.get(key);\n  addToCache = (key, value) => {\n    cache.set(key, value);\n    return value;\n  };\n} else {\n  const cache = [];\n  const cacheSize = 10;\n  let cachePos = 0;\n  readFromCache = (key) => {\n    for (let i = 0; i < cache.length; i += 2)\n      if (cache[i] == key)\n        return cache[i + 1];\n  };\n  addToCache = (key, value) => {\n    if (cachePos == cacheSize)\n      cachePos = 0;\n    cache[cachePos++] = key;\n    return cache[cachePos++] = value;\n  };\n}\nvar TableMap = class {\n  constructor(width, height, map, problems) {\n    this.width = width;\n    this.height = height;\n    this.map = map;\n    this.problems = problems;\n  }\n  findCell(pos) {\n    for (let i = 0; i < this.map.length; i++) {\n      const curPos = this.map[i];\n      if (curPos != pos)\n        continue;\n      const left = i % this.width;\n      const top = i / this.width | 0;\n      let right = left + 1;\n      let bottom = top + 1;\n      for (let j = 1; right < this.width && this.map[i + j] == curPos; j++) {\n        right++;\n      }\n      for (let j = 1; bottom < this.height && this.map[i + this.width * j] == curPos; j++) {\n        bottom++;\n      }\n      return { left, top, right, bottom };\n    }\n    throw new RangeError(`No cell with offset ${pos} found`);\n  }\n  colCount(pos) {\n    for (let i = 0; i < this.map.length; i++) {\n      if (this.map[i] == pos) {\n        return i % this.width;\n      }\n    }\n    throw new RangeError(`No cell with offset ${pos} found`);\n  }\n  nextCell(pos, axis, dir) {\n    const { left, right, top, bottom } = this.findCell(pos);\n    if (axis == \"horiz\") {\n      if (dir < 0 ? left == 0 : right == this.width)\n        return null;\n      return this.map[top * this.width + (dir < 0 ? left - 1 : right)];\n    } else {\n      if (dir < 0 ? top == 0 : bottom == this.height)\n        return null;\n      return this.map[left + this.width * (dir < 0 ? top - 1 : bottom)];\n    }\n  }\n  rectBetween(a, b) {\n    const {\n      left: leftA,\n      right: rightA,\n      top: topA,\n      bottom: bottomA\n    } = this.findCell(a);\n    const {\n      left: leftB,\n      right: rightB,\n      top: topB,\n      bottom: bottomB\n    } = this.findCell(b);\n    return {\n      left: Math.min(leftA, leftB),\n      top: Math.min(topA, topB),\n      right: Math.max(rightA, rightB),\n      bottom: Math.max(bottomA, bottomB)\n    };\n  }\n  cellsInRect(rect) {\n    const result = [];\n    const seen = {};\n    for (let row = rect.top; row < rect.bottom; row++) {\n      for (let col = rect.left; col < rect.right; col++) {\n        const index = row * this.width + col;\n        const pos = this.map[index];\n        if (seen[pos])\n          continue;\n        seen[pos] = true;\n        if (col == rect.left && col && this.map[index - 1] == pos || row == rect.top && row && this.map[index - this.width] == pos) {\n          continue;\n        }\n        result.push(pos);\n      }\n    }\n    return result;\n  }\n  positionAt(row, col, table) {\n    for (let i = 0, rowStart = 0; ; i++) {\n      const rowEnd = rowStart + table.child(i).nodeSize;\n      if (i == row) {\n        let index = col + row * this.width;\n        const rowEndIndex = (row + 1) * this.width;\n        while (index < rowEndIndex && this.map[index] < rowStart)\n          index++;\n        return index == rowEndIndex ? rowEnd - 1 : this.map[index];\n      }\n      rowStart = rowEnd;\n    }\n  }\n  static get(table) {\n    return readFromCache(table) || addToCache(table, computeMap(table));\n  }\n};\nfunction computeMap(table) {\n  if (table.type.spec.tableRole != \"table\")\n    throw new RangeError(\"Not a table node: \" + table.type.name);\n  const width = findWidth(table), height = table.childCount;\n  const map = [];\n  let mapPos = 0;\n  let problems = null;\n  const colWidths = [];\n  for (let i = 0, e = width * height; i < e; i++)\n    map[i] = 0;\n  for (let row = 0, pos = 0; row < height; row++) {\n    const rowNode = table.child(row);\n    pos++;\n    for (let i = 0; ; i++) {\n      while (mapPos < map.length && map[mapPos] != 0)\n        mapPos++;\n      if (i == rowNode.childCount)\n        break;\n      const cellNode = rowNode.child(i);\n      const { colspan, rowspan, colwidth } = cellNode.attrs;\n      for (let h = 0; h < rowspan; h++) {\n        if (h + row >= height) {\n          (problems || (problems = [])).push({\n            type: \"overlong_rowspan\",\n            pos,\n            n: rowspan - h\n          });\n          break;\n        }\n        const start = mapPos + h * width;\n        for (let w = 0; w < colspan; w++) {\n          if (map[start + w] == 0)\n            map[start + w] = pos;\n          else\n            (problems || (problems = [])).push({\n              type: \"collision\",\n              row,\n              pos,\n              n: colspan - w\n            });\n          const colW = colwidth && colwidth[w];\n          if (colW) {\n            const widthIndex = (start + w) % width * 2, prev = colWidths[widthIndex];\n            if (prev == null || prev != colW && colWidths[widthIndex + 1] == 1) {\n              colWidths[widthIndex] = colW;\n              colWidths[widthIndex + 1] = 1;\n            } else if (prev == colW) {\n              colWidths[widthIndex + 1]++;\n            }\n          }\n        }\n      }\n      mapPos += colspan;\n      pos += cellNode.nodeSize;\n    }\n    const expectedPos = (row + 1) * width;\n    let missing = 0;\n    while (mapPos < expectedPos)\n      if (map[mapPos++] == 0)\n        missing++;\n    if (missing)\n      (problems || (problems = [])).push({ type: \"missing\", row, n: missing });\n    pos++;\n  }\n  const tableMap = new TableMap(width, height, map, problems);\n  let badWidths = false;\n  for (let i = 0; !badWidths && i < colWidths.length; i += 2)\n    if (colWidths[i] != null && colWidths[i + 1] < height)\n      badWidths = true;\n  if (badWidths)\n    findBadColWidths(tableMap, colWidths, table);\n  return tableMap;\n}\nfunction findWidth(table) {\n  let width = -1;\n  let hasRowSpan = false;\n  for (let row = 0; row < table.childCount; row++) {\n    const rowNode = table.child(row);\n    let rowWidth = 0;\n    if (hasRowSpan)\n      for (let j = 0; j < row; j++) {\n        const prevRow = table.child(j);\n        for (let i = 0; i < prevRow.childCount; i++) {\n          const cell = prevRow.child(i);\n          if (j + cell.attrs.rowspan > row)\n            rowWidth += cell.attrs.colspan;\n        }\n      }\n    for (let i = 0; i < rowNode.childCount; i++) {\n      const cell = rowNode.child(i);\n      rowWidth += cell.attrs.colspan;\n      if (cell.attrs.rowspan > 1)\n        hasRowSpan = true;\n    }\n    if (width == -1)\n      width = rowWidth;\n    else if (width != rowWidth)\n      width = Math.max(width, rowWidth);\n  }\n  return width;\n}\nfunction findBadColWidths(map, colWidths, table) {\n  if (!map.problems)\n    map.problems = [];\n  const seen = {};\n  for (let i = 0; i < map.map.length; i++) {\n    const pos = map.map[i];\n    if (seen[pos])\n      continue;\n    seen[pos] = true;\n    const node = table.nodeAt(pos);\n    if (!node) {\n      throw new RangeError(`No cell with offset ${pos} found`);\n    }\n    let updated = null;\n    const attrs = node.attrs;\n    for (let j = 0; j < attrs.colspan; j++) {\n      const col = (i + j) % map.width;\n      const colWidth = colWidths[col * 2];\n      if (colWidth != null && (!attrs.colwidth || attrs.colwidth[j] != colWidth))\n        (updated || (updated = freshColWidth(attrs)))[j] = colWidth;\n    }\n    if (updated)\n      map.problems.unshift({\n        type: \"colwidth mismatch\",\n        pos,\n        colwidth: updated\n      });\n  }\n}\nfunction freshColWidth(attrs) {\n  if (attrs.colwidth)\n    return attrs.colwidth.slice();\n  const result = [];\n  for (let i = 0; i < attrs.colspan; i++)\n    result.push(0);\n  return result;\n}\n\n// src/util.ts\nimport { PluginKey } from \"prosemirror-state\";\n\n// src/schema.ts\nfunction getCellAttrs(dom, extraAttrs) {\n  if (typeof dom === \"string\") {\n    return {};\n  }\n  const widthAttr = dom.getAttribute(\"data-colwidth\");\n  const widths = widthAttr && /^\\d+(,\\d+)*$/.test(widthAttr) ? widthAttr.split(\",\").map((s) => Number(s)) : null;\n  const colspan = Number(dom.getAttribute(\"colspan\") || 1);\n  const result = {\n    colspan,\n    rowspan: Number(dom.getAttribute(\"rowspan\") || 1),\n    colwidth: widths && widths.length == colspan ? widths : null\n  };\n  for (const prop in extraAttrs) {\n    const getter = extraAttrs[prop].getFromDOM;\n    const value = getter && getter(dom);\n    if (value != null) {\n      result[prop] = value;\n    }\n  }\n  return result;\n}\nfunction setCellAttrs(node, extraAttrs) {\n  const attrs = {};\n  if (node.attrs.colspan != 1)\n    attrs.colspan = node.attrs.colspan;\n  if (node.attrs.rowspan != 1)\n    attrs.rowspan = node.attrs.rowspan;\n  if (node.attrs.colwidth)\n    attrs[\"data-colwidth\"] = node.attrs.colwidth.join(\",\");\n  for (const prop in extraAttrs) {\n    const setter = extraAttrs[prop].setDOMAttr;\n    if (setter)\n      setter(node.attrs[prop], attrs);\n  }\n  return attrs;\n}\nfunction tableNodes(options) {\n  const extraAttrs = options.cellAttributes || {};\n  const cellAttrs = {\n    colspan: { default: 1 },\n    rowspan: { default: 1 },\n    colwidth: { default: null }\n  };\n  for (const prop in extraAttrs)\n    cellAttrs[prop] = { default: extraAttrs[prop].default };\n  return {\n    table: {\n      content: \"table_row+\",\n      tableRole: \"table\",\n      isolating: true,\n      group: options.tableGroup,\n      parseDOM: [{ tag: \"table\" }],\n      toDOM() {\n        return [\"table\", [\"tbody\", 0]];\n      }\n    },\n    table_row: {\n      content: \"(table_cell | table_header)*\",\n      tableRole: \"row\",\n      parseDOM: [{ tag: \"tr\" }],\n      toDOM() {\n        return [\"tr\", 0];\n      }\n    },\n    table_cell: {\n      content: options.cellContent,\n      attrs: cellAttrs,\n      tableRole: \"cell\",\n      isolating: true,\n      parseDOM: [\n        { tag: \"td\", getAttrs: (dom) => getCellAttrs(dom, extraAttrs) }\n      ],\n      toDOM(node) {\n        return [\"td\", setCellAttrs(node, extraAttrs), 0];\n      }\n    },\n    table_header: {\n      content: options.cellContent,\n      attrs: cellAttrs,\n      tableRole: \"header_cell\",\n      isolating: true,\n      parseDOM: [\n        { tag: \"th\", getAttrs: (dom) => getCellAttrs(dom, extraAttrs) }\n      ],\n      toDOM(node) {\n        return [\"th\", setCellAttrs(node, extraAttrs), 0];\n      }\n    }\n  };\n}\nfunction tableNodeTypes(schema) {\n  let result = schema.cached.tableNodeTypes;\n  if (!result) {\n    result = schema.cached.tableNodeTypes = {};\n    for (const name in schema.nodes) {\n      const type = schema.nodes[name], role = type.spec.tableRole;\n      if (role)\n        result[role] = type;\n    }\n  }\n  return result;\n}\n\n// src/util.ts\nvar tableEditingKey = new PluginKey(\"selectingCells\");\nfunction cellAround($pos) {\n  for (let d = $pos.depth - 1; d > 0; d--)\n    if ($pos.node(d).type.spec.tableRole == \"row\")\n      return $pos.node(0).resolve($pos.before(d + 1));\n  return null;\n}\nfunction cellWrapping($pos) {\n  for (let d = $pos.depth; d > 0; d--) {\n    const role = $pos.node(d).type.spec.tableRole;\n    if (role === \"cell\" || role === \"header_cell\")\n      return $pos.node(d);\n  }\n  return null;\n}\nfunction isInTable(state) {\n  const $head = state.selection.$head;\n  for (let d = $head.depth; d > 0; d--)\n    if ($head.node(d).type.spec.tableRole == \"row\")\n      return true;\n  return false;\n}\nfunction selectionCell(state) {\n  const sel = state.selection;\n  if (\"$anchorCell\" in sel && sel.$anchorCell) {\n    return sel.$anchorCell.pos > sel.$headCell.pos ? sel.$anchorCell : sel.$headCell;\n  } else if (\"node\" in sel && sel.node && sel.node.type.spec.tableRole == \"cell\") {\n    return sel.$anchor;\n  }\n  const $cell = cellAround(sel.$head) || cellNear(sel.$head);\n  if ($cell) {\n    return $cell;\n  }\n  throw new RangeError(`No cell found around position ${sel.head}`);\n}\nfunction cellNear($pos) {\n  for (let after = $pos.nodeAfter, pos = $pos.pos; after; after = after.firstChild, pos++) {\n    const role = after.type.spec.tableRole;\n    if (role == \"cell\" || role == \"header_cell\")\n      return $pos.doc.resolve(pos);\n  }\n  for (let before = $pos.nodeBefore, pos = $pos.pos; before; before = before.lastChild, pos--) {\n    const role = before.type.spec.tableRole;\n    if (role == \"cell\" || role == \"header_cell\")\n      return $pos.doc.resolve(pos - before.nodeSize);\n  }\n}\nfunction pointsAtCell($pos) {\n  return $pos.parent.type.spec.tableRole == \"row\" && !!$pos.nodeAfter;\n}\nfunction moveCellForward($pos) {\n  return $pos.node(0).resolve($pos.pos + $pos.nodeAfter.nodeSize);\n}\nfunction inSameTable($cellA, $cellB) {\n  return $cellA.depth == $cellB.depth && $cellA.pos >= $cellB.start(-1) && $cellA.pos <= $cellB.end(-1);\n}\nfunction findCell($pos) {\n  return TableMap.get($pos.node(-1)).findCell($pos.pos - $pos.start(-1));\n}\nfunction colCount($pos) {\n  return TableMap.get($pos.node(-1)).colCount($pos.pos - $pos.start(-1));\n}\nfunction nextCell($pos, axis, dir) {\n  const table = $pos.node(-1);\n  const map = TableMap.get(table);\n  const tableStart = $pos.start(-1);\n  const moved = map.nextCell($pos.pos - tableStart, axis, dir);\n  return moved == null ? null : $pos.node(0).resolve(tableStart + moved);\n}\nfunction removeColSpan(attrs, pos, n = 1) {\n  const result = { ...attrs, colspan: attrs.colspan - n };\n  if (result.colwidth) {\n    result.colwidth = result.colwidth.slice();\n    result.colwidth.splice(pos, n);\n    if (!result.colwidth.some((w) => w > 0))\n      result.colwidth = null;\n  }\n  return result;\n}\nfunction addColSpan(attrs, pos, n = 1) {\n  const result = { ...attrs, colspan: attrs.colspan + n };\n  if (result.colwidth) {\n    result.colwidth = result.colwidth.slice();\n    for (let i = 0; i < n; i++)\n      result.colwidth.splice(pos, 0, 0);\n  }\n  return result;\n}\nfunction columnIsHeader(map, table, col) {\n  const headerCell = tableNodeTypes(table.type.schema).header_cell;\n  for (let row = 0; row < map.height; row++)\n    if (table.nodeAt(map.map[col + row * map.width]).type != headerCell)\n      return false;\n  return true;\n}\n\n// src/cellselection.ts\nvar CellSelection = class extends Selection {\n  constructor($anchorCell, $headCell = $anchorCell) {\n    const table = $anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = $anchorCell.start(-1);\n    const rect = map.rectBetween(\n      $anchorCell.pos - tableStart,\n      $headCell.pos - tableStart\n    );\n    const doc = $anchorCell.node(0);\n    const cells = map.cellsInRect(rect).filter((p) => p != $headCell.pos - tableStart);\n    cells.unshift($headCell.pos - tableStart);\n    const ranges = cells.map((pos) => {\n      const cell = table.nodeAt(pos);\n      if (!cell) {\n        throw RangeError(`No cell with offset ${pos} found`);\n      }\n      const from = tableStart + pos + 1;\n      return new SelectionRange(\n        doc.resolve(from),\n        doc.resolve(from + cell.content.size)\n      );\n    });\n    super(ranges[0].$from, ranges[0].$to, ranges);\n    this.$anchorCell = $anchorCell;\n    this.$headCell = $headCell;\n  }\n  map(doc, mapping) {\n    const $anchorCell = doc.resolve(mapping.map(this.$anchorCell.pos));\n    const $headCell = doc.resolve(mapping.map(this.$headCell.pos));\n    if (pointsAtCell($anchorCell) && pointsAtCell($headCell) && inSameTable($anchorCell, $headCell)) {\n      const tableChanged = this.$anchorCell.node(-1) != $anchorCell.node(-1);\n      if (tableChanged && this.isRowSelection())\n        return CellSelection.rowSelection($anchorCell, $headCell);\n      else if (tableChanged && this.isColSelection())\n        return CellSelection.colSelection($anchorCell, $headCell);\n      else\n        return new CellSelection($anchorCell, $headCell);\n    }\n    return TextSelection.between($anchorCell, $headCell);\n  }\n  content() {\n    const table = this.$anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = this.$anchorCell.start(-1);\n    const rect = map.rectBetween(\n      this.$anchorCell.pos - tableStart,\n      this.$headCell.pos - tableStart\n    );\n    const seen = {};\n    const rows = [];\n    for (let row = rect.top; row < rect.bottom; row++) {\n      const rowContent = [];\n      for (let index = row * map.width + rect.left, col = rect.left; col < rect.right; col++, index++) {\n        const pos = map.map[index];\n        if (seen[pos])\n          continue;\n        seen[pos] = true;\n        const cellRect = map.findCell(pos);\n        let cell = table.nodeAt(pos);\n        if (!cell) {\n          throw RangeError(`No cell with offset ${pos} found`);\n        }\n        const extraLeft = rect.left - cellRect.left;\n        const extraRight = cellRect.right - rect.right;\n        if (extraLeft > 0 || extraRight > 0) {\n          let attrs = cell.attrs;\n          if (extraLeft > 0) {\n            attrs = removeColSpan(attrs, 0, extraLeft);\n          }\n          if (extraRight > 0) {\n            attrs = removeColSpan(\n              attrs,\n              attrs.colspan - extraRight,\n              extraRight\n            );\n          }\n          if (cellRect.left < rect.left) {\n            cell = cell.type.createAndFill(attrs);\n            if (!cell) {\n              throw RangeError(\n                `Could not create cell with attrs ${JSON.stringify(attrs)}`\n              );\n            }\n          } else {\n            cell = cell.type.create(attrs, cell.content);\n          }\n        }\n        if (cellRect.top < rect.top || cellRect.bottom > rect.bottom) {\n          const attrs = {\n            ...cell.attrs,\n            rowspan: Math.min(cellRect.bottom, rect.bottom) - Math.max(cellRect.top, rect.top)\n          };\n          if (cellRect.top < rect.top) {\n            cell = cell.type.createAndFill(attrs);\n          } else {\n            cell = cell.type.create(attrs, cell.content);\n          }\n        }\n        rowContent.push(cell);\n      }\n      rows.push(table.child(row).copy(Fragment.from(rowContent)));\n    }\n    const fragment = this.isColSelection() && this.isRowSelection() ? table : rows;\n    return new Slice(Fragment.from(fragment), 1, 1);\n  }\n  replace(tr, content = Slice.empty) {\n    const mapFrom = tr.steps.length, ranges = this.ranges;\n    for (let i = 0; i < ranges.length; i++) {\n      const { $from, $to } = ranges[i], mapping = tr.mapping.slice(mapFrom);\n      tr.replace(\n        mapping.map($from.pos),\n        mapping.map($to.pos),\n        i ? Slice.empty : content\n      );\n    }\n    const sel = Selection.findFrom(\n      tr.doc.resolve(tr.mapping.slice(mapFrom).map(this.to)),\n      -1\n    );\n    if (sel)\n      tr.setSelection(sel);\n  }\n  replaceWith(tr, node) {\n    this.replace(tr, new Slice(Fragment.from(node), 0, 0));\n  }\n  forEachCell(f) {\n    const table = this.$anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = this.$anchorCell.start(-1);\n    const cells = map.cellsInRect(\n      map.rectBetween(\n        this.$anchorCell.pos - tableStart,\n        this.$headCell.pos - tableStart\n      )\n    );\n    for (let i = 0; i < cells.length; i++) {\n      f(table.nodeAt(cells[i]), tableStart + cells[i]);\n    }\n  }\n  isColSelection() {\n    const anchorTop = this.$anchorCell.index(-1);\n    const headTop = this.$headCell.index(-1);\n    if (Math.min(anchorTop, headTop) > 0)\n      return false;\n    const anchorBottom = anchorTop + this.$anchorCell.nodeAfter.attrs.rowspan;\n    const headBottom = headTop + this.$headCell.nodeAfter.attrs.rowspan;\n    return Math.max(anchorBottom, headBottom) == this.$headCell.node(-1).childCount;\n  }\n  static colSelection($anchorCell, $headCell = $anchorCell) {\n    const table = $anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = $anchorCell.start(-1);\n    const anchorRect = map.findCell($anchorCell.pos - tableStart);\n    const headRect = map.findCell($headCell.pos - tableStart);\n    const doc = $anchorCell.node(0);\n    if (anchorRect.top <= headRect.top) {\n      if (anchorRect.top > 0)\n        $anchorCell = doc.resolve(tableStart + map.map[anchorRect.left]);\n      if (headRect.bottom < map.height)\n        $headCell = doc.resolve(\n          tableStart + map.map[map.width * (map.height - 1) + headRect.right - 1]\n        );\n    } else {\n      if (headRect.top > 0)\n        $headCell = doc.resolve(tableStart + map.map[headRect.left]);\n      if (anchorRect.bottom < map.height)\n        $anchorCell = doc.resolve(\n          tableStart + map.map[map.width * (map.height - 1) + anchorRect.right - 1]\n        );\n    }\n    return new CellSelection($anchorCell, $headCell);\n  }\n  isRowSelection() {\n    const table = this.$anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = this.$anchorCell.start(-1);\n    const anchorLeft = map.colCount(this.$anchorCell.pos - tableStart);\n    const headLeft = map.colCount(this.$headCell.pos - tableStart);\n    if (Math.min(anchorLeft, headLeft) > 0)\n      return false;\n    const anchorRight = anchorLeft + this.$anchorCell.nodeAfter.attrs.colspan;\n    const headRight = headLeft + this.$headCell.nodeAfter.attrs.colspan;\n    return Math.max(anchorRight, headRight) == map.width;\n  }\n  eq(other) {\n    return other instanceof CellSelection && other.$anchorCell.pos == this.$anchorCell.pos && other.$headCell.pos == this.$headCell.pos;\n  }\n  static rowSelection($anchorCell, $headCell = $anchorCell) {\n    const table = $anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = $anchorCell.start(-1);\n    const anchorRect = map.findCell($anchorCell.pos - tableStart);\n    const headRect = map.findCell($headCell.pos - tableStart);\n    const doc = $anchorCell.node(0);\n    if (anchorRect.left <= headRect.left) {\n      if (anchorRect.left > 0)\n        $anchorCell = doc.resolve(\n          tableStart + map.map[anchorRect.top * map.width]\n        );\n      if (headRect.right < map.width)\n        $headCell = doc.resolve(\n          tableStart + map.map[map.width * (headRect.top + 1) - 1]\n        );\n    } else {\n      if (headRect.left > 0)\n        $headCell = doc.resolve(tableStart + map.map[headRect.top * map.width]);\n      if (anchorRect.right < map.width)\n        $anchorCell = doc.resolve(\n          tableStart + map.map[map.width * (anchorRect.top + 1) - 1]\n        );\n    }\n    return new CellSelection($anchorCell, $headCell);\n  }\n  toJSON() {\n    return {\n      type: \"cell\",\n      anchor: this.$anchorCell.pos,\n      head: this.$headCell.pos\n    };\n  }\n  static fromJSON(doc, json) {\n    return new CellSelection(doc.resolve(json.anchor), doc.resolve(json.head));\n  }\n  static create(doc, anchorCell, headCell = anchorCell) {\n    return new CellSelection(doc.resolve(anchorCell), doc.resolve(headCell));\n  }\n  getBookmark() {\n    return new CellBookmark(this.$anchorCell.pos, this.$headCell.pos);\n  }\n};\nCellSelection.prototype.visible = false;\nSelection.jsonID(\"cell\", CellSelection);\nvar CellBookmark = class {\n  constructor(anchor, head) {\n    this.anchor = anchor;\n    this.head = head;\n  }\n  map(mapping) {\n    return new CellBookmark(mapping.map(this.anchor), mapping.map(this.head));\n  }\n  resolve(doc) {\n    const $anchorCell = doc.resolve(this.anchor), $headCell = doc.resolve(this.head);\n    if ($anchorCell.parent.type.spec.tableRole == \"row\" && $headCell.parent.type.spec.tableRole == \"row\" && $anchorCell.index() < $anchorCell.parent.childCount && $headCell.index() < $headCell.parent.childCount && inSameTable($anchorCell, $headCell))\n      return new CellSelection($anchorCell, $headCell);\n    else\n      return Selection.near($headCell, 1);\n  }\n};\nfunction drawCellSelection(state) {\n  if (!(state.selection instanceof CellSelection))\n    return null;\n  const cells = [];\n  state.selection.forEachCell((node, pos) => {\n    cells.push(\n      Decoration.node(pos, pos + node.nodeSize, { class: \"selectedCell\" })\n    );\n  });\n  return DecorationSet.create(state.doc, cells);\n}\nfunction isCellBoundarySelection({ $from, $to }) {\n  if ($from.pos == $to.pos || $from.pos < $from.pos - 6)\n    return false;\n  let afterFrom = $from.pos;\n  let beforeTo = $to.pos;\n  let depth = $from.depth;\n  for (; depth >= 0; depth--, afterFrom++)\n    if ($from.after(depth + 1) < $from.end(depth))\n      break;\n  for (let d = $to.depth; d >= 0; d--, beforeTo--)\n    if ($to.before(d + 1) > $to.start(d))\n      break;\n  return afterFrom == beforeTo && /row|table/.test($from.node(depth).type.spec.tableRole);\n}\nfunction isTextSelectionAcrossCells({ $from, $to }) {\n  let fromCellBoundaryNode;\n  let toCellBoundaryNode;\n  for (let i = $from.depth; i > 0; i--) {\n    const node = $from.node(i);\n    if (node.type.spec.tableRole === \"cell\" || node.type.spec.tableRole === \"header_cell\") {\n      fromCellBoundaryNode = node;\n      break;\n    }\n  }\n  for (let i = $to.depth; i > 0; i--) {\n    const node = $to.node(i);\n    if (node.type.spec.tableRole === \"cell\" || node.type.spec.tableRole === \"header_cell\") {\n      toCellBoundaryNode = node;\n      break;\n    }\n  }\n  return fromCellBoundaryNode !== toCellBoundaryNode && $to.parentOffset === 0;\n}\nfunction normalizeSelection(state, tr, allowTableNodeSelection) {\n  const sel = (tr || state).selection;\n  const doc = (tr || state).doc;\n  let normalize;\n  let role;\n  if (sel instanceof NodeSelection2 && (role = sel.node.type.spec.tableRole)) {\n    if (role == \"cell\" || role == \"header_cell\") {\n      normalize = CellSelection.create(doc, sel.from);\n    } else if (role == \"row\") {\n      const $cell = doc.resolve(sel.from + 1);\n      normalize = CellSelection.rowSelection($cell, $cell);\n    } else if (!allowTableNodeSelection) {\n      const map = TableMap.get(sel.node);\n      const start = sel.from + 1;\n      const lastCell = start + map.map[map.width * map.height - 1];\n      normalize = CellSelection.create(doc, start + 1, lastCell);\n    }\n  } else if (sel instanceof TextSelection && isCellBoundarySelection(sel)) {\n    normalize = TextSelection.create(doc, sel.from);\n  } else if (sel instanceof TextSelection && isTextSelectionAcrossCells(sel)) {\n    normalize = TextSelection.create(doc, sel.$from.start(), sel.$from.end());\n  }\n  if (normalize)\n    (tr || (tr = state.tr)).setSelection(normalize);\n  return tr;\n}\n\n// src/fixtables.ts\nimport { PluginKey as PluginKey2 } from \"prosemirror-state\";\nvar fixTablesKey = new PluginKey2(\"fix-tables\");\nfunction changedDescendants(old, cur, offset, f) {\n  const oldSize = old.childCount, curSize = cur.childCount;\n  outer:\n    for (let i = 0, j = 0; i < curSize; i++) {\n      const child = cur.child(i);\n      for (let scan = j, e = Math.min(oldSize, i + 3); scan < e; scan++) {\n        if (old.child(scan) == child) {\n          j = scan + 1;\n          offset += child.nodeSize;\n          continue outer;\n        }\n      }\n      f(child, offset);\n      if (j < oldSize && old.child(j).sameMarkup(child))\n        changedDescendants(old.child(j), child, offset + 1, f);\n      else\n        child.nodesBetween(0, child.content.size, f, offset + 1);\n      offset += child.nodeSize;\n    }\n}\nfunction fixTables(state, oldState) {\n  let tr;\n  const check = (node, pos) => {\n    if (node.type.spec.tableRole == \"table\")\n      tr = fixTable(state, node, pos, tr);\n  };\n  if (!oldState)\n    state.doc.descendants(check);\n  else if (oldState.doc != state.doc)\n    changedDescendants(oldState.doc, state.doc, 0, check);\n  return tr;\n}\nfunction fixTable(state, table, tablePos, tr) {\n  const map = TableMap.get(table);\n  if (!map.problems)\n    return tr;\n  if (!tr)\n    tr = state.tr;\n  const mustAdd = [];\n  for (let i = 0; i < map.height; i++)\n    mustAdd.push(0);\n  for (let i = 0; i < map.problems.length; i++) {\n    const prob = map.problems[i];\n    if (prob.type == \"collision\") {\n      const cell = table.nodeAt(prob.pos);\n      if (!cell)\n        continue;\n      const attrs = cell.attrs;\n      for (let j = 0; j < attrs.rowspan; j++)\n        mustAdd[prob.row + j] += prob.n;\n      tr.setNodeMarkup(\n        tr.mapping.map(tablePos + 1 + prob.pos),\n        null,\n        removeColSpan(attrs, attrs.colspan - prob.n, prob.n)\n      );\n    } else if (prob.type == \"missing\") {\n      mustAdd[prob.row] += prob.n;\n    } else if (prob.type == \"overlong_rowspan\") {\n      const cell = table.nodeAt(prob.pos);\n      if (!cell)\n        continue;\n      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, {\n        ...cell.attrs,\n        rowspan: cell.attrs.rowspan - prob.n\n      });\n    } else if (prob.type == \"colwidth mismatch\") {\n      const cell = table.nodeAt(prob.pos);\n      if (!cell)\n        continue;\n      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, {\n        ...cell.attrs,\n        colwidth: prob.colwidth\n      });\n    }\n  }\n  let first, last;\n  for (let i = 0; i < mustAdd.length; i++)\n    if (mustAdd[i]) {\n      if (first == null)\n        first = i;\n      last = i;\n    }\n  for (let i = 0, pos = tablePos + 1; i < map.height; i++) {\n    const row = table.child(i);\n    const end = pos + row.nodeSize;\n    const add = mustAdd[i];\n    if (add > 0) {\n      let role = \"cell\";\n      if (row.firstChild) {\n        role = row.firstChild.type.spec.tableRole;\n      }\n      const nodes = [];\n      for (let j = 0; j < add; j++) {\n        const node = tableNodeTypes(state.schema)[role].createAndFill();\n        if (node)\n          nodes.push(node);\n      }\n      const side = (i == 0 || first == i - 1) && last == i ? pos + 1 : end - 1;\n      tr.insert(tr.mapping.map(side), nodes);\n    }\n    pos = end;\n  }\n  return tr.setMeta(fixTablesKey, { fixTables: true });\n}\n\n// src/input.ts\nimport { Fragment as Fragment3, Slice as Slice3 } from \"prosemirror-model\";\nimport {\n  Selection as Selection2,\n  TextSelection as TextSelection2\n} from \"prosemirror-state\";\nimport { keydownHandler } from \"prosemirror-keymap\";\n\n// src/copypaste.ts\nimport { Fragment as Fragment2, Slice as Slice2 } from \"prosemirror-model\";\nimport { Transform } from \"prosemirror-transform\";\nfunction pastedCells(slice) {\n  if (!slice.size)\n    return null;\n  let { content, openStart, openEnd } = slice;\n  while (content.childCount == 1 && (openStart > 0 && openEnd > 0 || content.child(0).type.spec.tableRole == \"table\")) {\n    openStart--;\n    openEnd--;\n    content = content.child(0).content;\n  }\n  const first = content.child(0);\n  const role = first.type.spec.tableRole;\n  const schema = first.type.schema, rows = [];\n  if (role == \"row\") {\n    for (let i = 0; i < content.childCount; i++) {\n      let cells = content.child(i).content;\n      const left = i ? 0 : Math.max(0, openStart - 1);\n      const right = i < content.childCount - 1 ? 0 : Math.max(0, openEnd - 1);\n      if (left || right)\n        cells = fitSlice(\n          tableNodeTypes(schema).row,\n          new Slice2(cells, left, right)\n        ).content;\n      rows.push(cells);\n    }\n  } else if (role == \"cell\" || role == \"header_cell\") {\n    rows.push(\n      openStart || openEnd ? fitSlice(\n        tableNodeTypes(schema).row,\n        new Slice2(content, openStart, openEnd)\n      ).content : content\n    );\n  } else {\n    return null;\n  }\n  return ensureRectangular(schema, rows);\n}\nfunction ensureRectangular(schema, rows) {\n  const widths = [];\n  for (let i = 0; i < rows.length; i++) {\n    const row = rows[i];\n    for (let j = row.childCount - 1; j >= 0; j--) {\n      const { rowspan, colspan } = row.child(j).attrs;\n      for (let r = i; r < i + rowspan; r++)\n        widths[r] = (widths[r] || 0) + colspan;\n    }\n  }\n  let width = 0;\n  for (let r = 0; r < widths.length; r++)\n    width = Math.max(width, widths[r]);\n  for (let r = 0; r < widths.length; r++) {\n    if (r >= rows.length)\n      rows.push(Fragment2.empty);\n    if (widths[r] < width) {\n      const empty = tableNodeTypes(schema).cell.createAndFill();\n      const cells = [];\n      for (let i = widths[r]; i < width; i++) {\n        cells.push(empty);\n      }\n      rows[r] = rows[r].append(Fragment2.from(cells));\n    }\n  }\n  return { height: rows.length, width, rows };\n}\nfunction fitSlice(nodeType, slice) {\n  const node = nodeType.createAndFill();\n  const tr = new Transform(node).replace(0, node.content.size, slice);\n  return tr.doc;\n}\nfunction clipCells({ width, height, rows }, newWidth, newHeight) {\n  if (width != newWidth) {\n    const added = [];\n    const newRows = [];\n    for (let row = 0; row < rows.length; row++) {\n      const frag = rows[row], cells = [];\n      for (let col = added[row] || 0, i = 0; col < newWidth; i++) {\n        let cell = frag.child(i % frag.childCount);\n        if (col + cell.attrs.colspan > newWidth)\n          cell = cell.type.createChecked(\n            removeColSpan(\n              cell.attrs,\n              cell.attrs.colspan,\n              col + cell.attrs.colspan - newWidth\n            ),\n            cell.content\n          );\n        cells.push(cell);\n        col += cell.attrs.colspan;\n        for (let j = 1; j < cell.attrs.rowspan; j++)\n          added[row + j] = (added[row + j] || 0) + cell.attrs.colspan;\n      }\n      newRows.push(Fragment2.from(cells));\n    }\n    rows = newRows;\n    width = newWidth;\n  }\n  if (height != newHeight) {\n    const newRows = [];\n    for (let row = 0, i = 0; row < newHeight; row++, i++) {\n      const cells = [], source = rows[i % height];\n      for (let j = 0; j < source.childCount; j++) {\n        let cell = source.child(j);\n        if (row + cell.attrs.rowspan > newHeight)\n          cell = cell.type.create(\n            {\n              ...cell.attrs,\n              rowspan: Math.max(1, newHeight - cell.attrs.rowspan)\n            },\n            cell.content\n          );\n        cells.push(cell);\n      }\n      newRows.push(Fragment2.from(cells));\n    }\n    rows = newRows;\n    height = newHeight;\n  }\n  return { width, height, rows };\n}\nfunction growTable(tr, map, table, start, width, height, mapFrom) {\n  const schema = tr.doc.type.schema;\n  const types = tableNodeTypes(schema);\n  let empty;\n  let emptyHead;\n  if (width > map.width) {\n    for (let row = 0, rowEnd = 0; row < map.height; row++) {\n      const rowNode = table.child(row);\n      rowEnd += rowNode.nodeSize;\n      const cells = [];\n      let add;\n      if (rowNode.lastChild == null || rowNode.lastChild.type == types.cell)\n        add = empty || (empty = types.cell.createAndFill());\n      else\n        add = emptyHead || (emptyHead = types.header_cell.createAndFill());\n      for (let i = map.width; i < width; i++)\n        cells.push(add);\n      tr.insert(tr.mapping.slice(mapFrom).map(rowEnd - 1 + start), cells);\n    }\n  }\n  if (height > map.height) {\n    const cells = [];\n    for (let i = 0, start2 = (map.height - 1) * map.width; i < Math.max(map.width, width); i++) {\n      const header = i >= map.width ? false : table.nodeAt(map.map[start2 + i]).type == types.header_cell;\n      cells.push(\n        header ? emptyHead || (emptyHead = types.header_cell.createAndFill()) : empty || (empty = types.cell.createAndFill())\n      );\n    }\n    const emptyRow = types.row.create(null, Fragment2.from(cells)), rows = [];\n    for (let i = map.height; i < height; i++)\n      rows.push(emptyRow);\n    tr.insert(tr.mapping.slice(mapFrom).map(start + table.nodeSize - 2), rows);\n  }\n  return !!(empty || emptyHead);\n}\nfunction isolateHorizontal(tr, map, table, start, left, right, top, mapFrom) {\n  if (top == 0 || top == map.height)\n    return false;\n  let found = false;\n  for (let col = left; col < right; col++) {\n    const index = top * map.width + col, pos = map.map[index];\n    if (map.map[index - map.width] == pos) {\n      found = true;\n      const cell = table.nodeAt(pos);\n      const { top: cellTop, left: cellLeft } = map.findCell(pos);\n      tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + start), null, {\n        ...cell.attrs,\n        rowspan: top - cellTop\n      });\n      tr.insert(\n        tr.mapping.slice(mapFrom).map(map.positionAt(top, cellLeft, table)),\n        cell.type.createAndFill({\n          ...cell.attrs,\n          rowspan: cellTop + cell.attrs.rowspan - top\n        })\n      );\n      col += cell.attrs.colspan - 1;\n    }\n  }\n  return found;\n}\nfunction isolateVertical(tr, map, table, start, top, bottom, left, mapFrom) {\n  if (left == 0 || left == map.width)\n    return false;\n  let found = false;\n  for (let row = top; row < bottom; row++) {\n    const index = row * map.width + left, pos = map.map[index];\n    if (map.map[index - 1] == pos) {\n      found = true;\n      const cell = table.nodeAt(pos);\n      const cellLeft = map.colCount(pos);\n      const updatePos = tr.mapping.slice(mapFrom).map(pos + start);\n      tr.setNodeMarkup(\n        updatePos,\n        null,\n        removeColSpan(\n          cell.attrs,\n          left - cellLeft,\n          cell.attrs.colspan - (left - cellLeft)\n        )\n      );\n      tr.insert(\n        updatePos + cell.nodeSize,\n        cell.type.createAndFill(\n          removeColSpan(cell.attrs, 0, left - cellLeft)\n        )\n      );\n      row += cell.attrs.rowspan - 1;\n    }\n  }\n  return found;\n}\nfunction insertCells(state, dispatch, tableStart, rect, cells) {\n  let table = tableStart ? state.doc.nodeAt(tableStart - 1) : state.doc;\n  if (!table) {\n    throw new Error(\"No table found\");\n  }\n  let map = TableMap.get(table);\n  const { top, left } = rect;\n  const right = left + cells.width, bottom = top + cells.height;\n  const tr = state.tr;\n  let mapFrom = 0;\n  function recomp() {\n    table = tableStart ? tr.doc.nodeAt(tableStart - 1) : tr.doc;\n    if (!table) {\n      throw new Error(\"No table found\");\n    }\n    map = TableMap.get(table);\n    mapFrom = tr.mapping.maps.length;\n  }\n  if (growTable(tr, map, table, tableStart, right, bottom, mapFrom))\n    recomp();\n  if (isolateHorizontal(tr, map, table, tableStart, left, right, top, mapFrom))\n    recomp();\n  if (isolateHorizontal(tr, map, table, tableStart, left, right, bottom, mapFrom))\n    recomp();\n  if (isolateVertical(tr, map, table, tableStart, top, bottom, left, mapFrom))\n    recomp();\n  if (isolateVertical(tr, map, table, tableStart, top, bottom, right, mapFrom))\n    recomp();\n  for (let row = top; row < bottom; row++) {\n    const from = map.positionAt(row, left, table), to = map.positionAt(row, right, table);\n    tr.replace(\n      tr.mapping.slice(mapFrom).map(from + tableStart),\n      tr.mapping.slice(mapFrom).map(to + tableStart),\n      new Slice2(cells.rows[row - top], 0, 0)\n    );\n  }\n  recomp();\n  tr.setSelection(\n    new CellSelection(\n      tr.doc.resolve(tableStart + map.positionAt(top, left, table)),\n      tr.doc.resolve(tableStart + map.positionAt(bottom - 1, right - 1, table))\n    )\n  );\n  dispatch(tr);\n}\n\n// src/input.ts\nvar handleKeyDown = keydownHandler({\n  ArrowLeft: arrow(\"horiz\", -1),\n  ArrowRight: arrow(\"horiz\", 1),\n  ArrowUp: arrow(\"vert\", -1),\n  ArrowDown: arrow(\"vert\", 1),\n  \"Shift-ArrowLeft\": shiftArrow(\"horiz\", -1),\n  \"Shift-ArrowRight\": shiftArrow(\"horiz\", 1),\n  \"Shift-ArrowUp\": shiftArrow(\"vert\", -1),\n  \"Shift-ArrowDown\": shiftArrow(\"vert\", 1),\n  Backspace: deleteCellSelection,\n  \"Mod-Backspace\": deleteCellSelection,\n  Delete: deleteCellSelection,\n  \"Mod-Delete\": deleteCellSelection\n});\nfunction maybeSetSelection(state, dispatch, selection) {\n  if (selection.eq(state.selection))\n    return false;\n  if (dispatch)\n    dispatch(state.tr.setSelection(selection).scrollIntoView());\n  return true;\n}\nfunction arrow(axis, dir) {\n  return (state, dispatch, view) => {\n    if (!view)\n      return false;\n    const sel = state.selection;\n    if (sel instanceof CellSelection) {\n      return maybeSetSelection(\n        state,\n        dispatch,\n        Selection2.near(sel.$headCell, dir)\n      );\n    }\n    if (axis != \"horiz\" && !sel.empty)\n      return false;\n    const end = atEndOfCell(view, axis, dir);\n    if (end == null)\n      return false;\n    if (axis == \"horiz\") {\n      return maybeSetSelection(\n        state,\n        dispatch,\n        Selection2.near(state.doc.resolve(sel.head + dir), dir)\n      );\n    } else {\n      const $cell = state.doc.resolve(end);\n      const $next = nextCell($cell, axis, dir);\n      let newSel;\n      if ($next)\n        newSel = Selection2.near($next, 1);\n      else if (dir < 0)\n        newSel = Selection2.near(state.doc.resolve($cell.before(-1)), -1);\n      else\n        newSel = Selection2.near(state.doc.resolve($cell.after(-1)), 1);\n      return maybeSetSelection(state, dispatch, newSel);\n    }\n  };\n}\nfunction shiftArrow(axis, dir) {\n  return (state, dispatch, view) => {\n    if (!view)\n      return false;\n    const sel = state.selection;\n    let cellSel;\n    if (sel instanceof CellSelection) {\n      cellSel = sel;\n    } else {\n      const end = atEndOfCell(view, axis, dir);\n      if (end == null)\n        return false;\n      cellSel = new CellSelection(state.doc.resolve(end));\n    }\n    const $head = nextCell(cellSel.$headCell, axis, dir);\n    if (!$head)\n      return false;\n    return maybeSetSelection(\n      state,\n      dispatch,\n      new CellSelection(cellSel.$anchorCell, $head)\n    );\n  };\n}\nfunction deleteCellSelection(state, dispatch) {\n  const sel = state.selection;\n  if (!(sel instanceof CellSelection))\n    return false;\n  if (dispatch) {\n    const tr = state.tr;\n    const baseContent = tableNodeTypes(state.schema).cell.createAndFill().content;\n    sel.forEachCell((cell, pos) => {\n      if (!cell.content.eq(baseContent))\n        tr.replace(\n          tr.mapping.map(pos + 1),\n          tr.mapping.map(pos + cell.nodeSize - 1),\n          new Slice3(baseContent, 0, 0)\n        );\n    });\n    if (tr.docChanged)\n      dispatch(tr);\n  }\n  return true;\n}\nfunction handleTripleClick(view, pos) {\n  const doc = view.state.doc, $cell = cellAround(doc.resolve(pos));\n  if (!$cell)\n    return false;\n  view.dispatch(view.state.tr.setSelection(new CellSelection($cell)));\n  return true;\n}\nfunction handlePaste(view, _, slice) {\n  if (!isInTable(view.state))\n    return false;\n  let cells = pastedCells(slice);\n  const sel = view.state.selection;\n  if (sel instanceof CellSelection) {\n    if (!cells)\n      cells = {\n        width: 1,\n        height: 1,\n        rows: [\n          Fragment3.from(\n            fitSlice(tableNodeTypes(view.state.schema).cell, slice)\n          )\n        ]\n      };\n    const table = sel.$anchorCell.node(-1);\n    const start = sel.$anchorCell.start(-1);\n    const rect = TableMap.get(table).rectBetween(\n      sel.$anchorCell.pos - start,\n      sel.$headCell.pos - start\n    );\n    cells = clipCells(cells, rect.right - rect.left, rect.bottom - rect.top);\n    insertCells(view.state, view.dispatch, start, rect, cells);\n    return true;\n  } else if (cells) {\n    const $cell = selectionCell(view.state);\n    const start = $cell.start(-1);\n    insertCells(\n      view.state,\n      view.dispatch,\n      start,\n      TableMap.get($cell.node(-1)).findCell($cell.pos - start),\n      cells\n    );\n    return true;\n  } else {\n    return false;\n  }\n}\nfunction handleMouseDown(view, startEvent) {\n  var _a;\n  if (startEvent.ctrlKey || startEvent.metaKey)\n    return;\n  const startDOMCell = domInCell(view, startEvent.target);\n  let $anchor;\n  if (startEvent.shiftKey && view.state.selection instanceof CellSelection) {\n    setCellSelection(view.state.selection.$anchorCell, startEvent);\n    startEvent.preventDefault();\n  } else if (startEvent.shiftKey && startDOMCell && ($anchor = cellAround(view.state.selection.$anchor)) != null && ((_a = cellUnderMouse(view, startEvent)) == null ? void 0 : _a.pos) != $anchor.pos) {\n    setCellSelection($anchor, startEvent);\n    startEvent.preventDefault();\n  } else if (!startDOMCell) {\n    return;\n  }\n  function setCellSelection($anchor2, event) {\n    let $head = cellUnderMouse(view, event);\n    const starting = tableEditingKey.getState(view.state) == null;\n    if (!$head || !inSameTable($anchor2, $head)) {\n      if (starting)\n        $head = $anchor2;\n      else\n        return;\n    }\n    const selection = new CellSelection($anchor2, $head);\n    if (starting || !view.state.selection.eq(selection)) {\n      const tr = view.state.tr.setSelection(selection);\n      if (starting)\n        tr.setMeta(tableEditingKey, $anchor2.pos);\n      view.dispatch(tr);\n    }\n  }\n  function stop() {\n    view.root.removeEventListener(\"mouseup\", stop);\n    view.root.removeEventListener(\"dragstart\", stop);\n    view.root.removeEventListener(\"mousemove\", move);\n    if (tableEditingKey.getState(view.state) != null)\n      view.dispatch(view.state.tr.setMeta(tableEditingKey, -1));\n  }\n  function move(_event) {\n    const event = _event;\n    const anchor = tableEditingKey.getState(view.state);\n    let $anchor2;\n    if (anchor != null) {\n      $anchor2 = view.state.doc.resolve(anchor);\n    } else if (domInCell(view, event.target) != startDOMCell) {\n      $anchor2 = cellUnderMouse(view, startEvent);\n      if (!$anchor2)\n        return stop();\n    }\n    if ($anchor2)\n      setCellSelection($anchor2, event);\n  }\n  view.root.addEventListener(\"mouseup\", stop);\n  view.root.addEventListener(\"dragstart\", stop);\n  view.root.addEventListener(\"mousemove\", move);\n}\nfunction atEndOfCell(view, axis, dir) {\n  if (!(view.state.selection instanceof TextSelection2))\n    return null;\n  const { $head } = view.state.selection;\n  for (let d = $head.depth - 1; d >= 0; d--) {\n    const parent = $head.node(d), index = dir < 0 ? $head.index(d) : $head.indexAfter(d);\n    if (index != (dir < 0 ? 0 : parent.childCount))\n      return null;\n    if (parent.type.spec.tableRole == \"cell\" || parent.type.spec.tableRole == \"header_cell\") {\n      const cellPos = $head.before(d);\n      const dirStr = axis == \"vert\" ? dir > 0 ? \"down\" : \"up\" : dir > 0 ? \"right\" : \"left\";\n      return view.endOfTextblock(dirStr) ? cellPos : null;\n    }\n  }\n  return null;\n}\nfunction domInCell(view, dom) {\n  for (; dom && dom != view.dom; dom = dom.parentNode) {\n    if (dom.nodeName == \"TD\" || dom.nodeName == \"TH\") {\n      return dom;\n    }\n  }\n  return null;\n}\nfunction cellUnderMouse(view, event) {\n  const mousePos = view.posAtCoords({\n    left: event.clientX,\n    top: event.clientY\n  });\n  if (!mousePos)\n    return null;\n  return mousePos ? cellAround(view.state.doc.resolve(mousePos.pos)) : null;\n}\n\n// src/columnresizing.ts\nimport { Plugin, PluginKey as PluginKey3 } from \"prosemirror-state\";\nimport {\n  Decoration as Decoration2,\n  DecorationSet as DecorationSet2\n} from \"prosemirror-view\";\n\n// src/tableview.ts\nvar TableView = class {\n  constructor(node, cellMinWidth) {\n    this.node = node;\n    this.cellMinWidth = cellMinWidth;\n    this.dom = document.createElement(\"div\");\n    this.dom.className = \"tableWrapper\";\n    this.table = this.dom.appendChild(document.createElement(\"table\"));\n    this.colgroup = this.table.appendChild(document.createElement(\"colgroup\"));\n    updateColumnsOnResize(node, this.colgroup, this.table, cellMinWidth);\n    this.contentDOM = this.table.appendChild(document.createElement(\"tbody\"));\n  }\n  update(node) {\n    if (node.type != this.node.type)\n      return false;\n    this.node = node;\n    updateColumnsOnResize(node, this.colgroup, this.table, this.cellMinWidth);\n    return true;\n  }\n  ignoreMutation(record) {\n    return record.type == \"attributes\" && (record.target == this.table || this.colgroup.contains(record.target));\n  }\n};\nfunction updateColumnsOnResize(node, colgroup, table, cellMinWidth, overrideCol, overrideValue) {\n  var _a;\n  let totalWidth = 0;\n  let fixedWidth = true;\n  let nextDOM = colgroup.firstChild;\n  const row = node.firstChild;\n  if (!row)\n    return;\n  for (let i = 0, col = 0; i < row.childCount; i++) {\n    const { colspan, colwidth } = row.child(i).attrs;\n    for (let j = 0; j < colspan; j++, col++) {\n      const hasWidth = overrideCol == col ? overrideValue : colwidth && colwidth[j];\n      const cssWidth = hasWidth ? hasWidth + \"px\" : \"\";\n      totalWidth += hasWidth || cellMinWidth;\n      if (!hasWidth)\n        fixedWidth = false;\n      if (!nextDOM) {\n        colgroup.appendChild(document.createElement(\"col\")).style.width = cssWidth;\n      } else {\n        if (nextDOM.style.width != cssWidth)\n          nextDOM.style.width = cssWidth;\n        nextDOM = nextDOM.nextSibling;\n      }\n    }\n  }\n  while (nextDOM) {\n    const after = nextDOM.nextSibling;\n    (_a = nextDOM.parentNode) == null ? void 0 : _a.removeChild(nextDOM);\n    nextDOM = after;\n  }\n  if (fixedWidth) {\n    table.style.width = totalWidth + \"px\";\n    table.style.minWidth = \"\";\n  } else {\n    table.style.width = \"\";\n    table.style.minWidth = totalWidth + \"px\";\n  }\n}\n\n// src/columnresizing.ts\nvar columnResizingPluginKey = new PluginKey3(\n  \"tableColumnResizing\"\n);\nfunction columnResizing({\n  handleWidth = 5,\n  cellMinWidth = 25,\n  View = TableView,\n  lastColumnResizable = true\n} = {}) {\n  const plugin = new Plugin({\n    key: columnResizingPluginKey,\n    state: {\n      init(_, state) {\n        plugin.spec.props.nodeViews[tableNodeTypes(state.schema).table.name] = (node, view) => new View(node, cellMinWidth, view);\n        return new ResizeState(-1, false);\n      },\n      apply(tr, prev) {\n        return prev.apply(tr);\n      }\n    },\n    props: {\n      attributes: (state) => {\n        const pluginState = columnResizingPluginKey.getState(state);\n        return pluginState && pluginState.activeHandle > -1 ? { class: \"resize-cursor\" } : {};\n      },\n      handleDOMEvents: {\n        mousemove: (view, event) => {\n          handleMouseMove(\n            view,\n            event,\n            handleWidth,\n            cellMinWidth,\n            lastColumnResizable\n          );\n        },\n        mouseleave: (view) => {\n          handleMouseLeave(view);\n        },\n        mousedown: (view, event) => {\n          handleMouseDown2(view, event, cellMinWidth);\n        }\n      },\n      decorations: (state) => {\n        const pluginState = columnResizingPluginKey.getState(state);\n        if (pluginState && pluginState.activeHandle > -1) {\n          return handleDecorations(state, pluginState.activeHandle);\n        }\n      },\n      nodeViews: {}\n    }\n  });\n  return plugin;\n}\nvar ResizeState = class {\n  constructor(activeHandle, dragging) {\n    this.activeHandle = activeHandle;\n    this.dragging = dragging;\n  }\n  apply(tr) {\n    const state = this;\n    const action = tr.getMeta(columnResizingPluginKey);\n    if (action && action.setHandle != null)\n      return new ResizeState(action.setHandle, false);\n    if (action && action.setDragging !== void 0)\n      return new ResizeState(state.activeHandle, action.setDragging);\n    if (state.activeHandle > -1 && tr.docChanged) {\n      let handle = tr.mapping.map(state.activeHandle, -1);\n      if (!pointsAtCell(tr.doc.resolve(handle))) {\n        handle = -1;\n      }\n      return new ResizeState(handle, state.dragging);\n    }\n    return state;\n  }\n};\nfunction handleMouseMove(view, event, handleWidth, cellMinWidth, lastColumnResizable) {\n  const pluginState = columnResizingPluginKey.getState(view.state);\n  if (!pluginState)\n    return;\n  if (!pluginState.dragging) {\n    const target = domCellAround(event.target);\n    let cell = -1;\n    if (target) {\n      const { left, right } = target.getBoundingClientRect();\n      if (event.clientX - left <= handleWidth)\n        cell = edgeCell(view, event, \"left\");\n      else if (right - event.clientX <= handleWidth)\n        cell = edgeCell(view, event, \"right\");\n    }\n    if (cell != pluginState.activeHandle) {\n      if (!lastColumnResizable && cell !== -1) {\n        const $cell = view.state.doc.resolve(cell);\n        const table = $cell.node(-1);\n        const map = TableMap.get(table);\n        const tableStart = $cell.start(-1);\n        const col = map.colCount($cell.pos - tableStart) + $cell.nodeAfter.attrs.colspan - 1;\n        if (col == map.width - 1) {\n          return;\n        }\n      }\n      updateHandle(view, cell);\n    }\n  }\n}\nfunction handleMouseLeave(view) {\n  const pluginState = columnResizingPluginKey.getState(view.state);\n  if (pluginState && pluginState.activeHandle > -1 && !pluginState.dragging)\n    updateHandle(view, -1);\n}\nfunction handleMouseDown2(view, event, cellMinWidth) {\n  const pluginState = columnResizingPluginKey.getState(view.state);\n  if (!pluginState || pluginState.activeHandle == -1 || pluginState.dragging)\n    return false;\n  const cell = view.state.doc.nodeAt(pluginState.activeHandle);\n  const width = currentColWidth(view, pluginState.activeHandle, cell.attrs);\n  view.dispatch(\n    view.state.tr.setMeta(columnResizingPluginKey, {\n      setDragging: { startX: event.clientX, startWidth: width }\n    })\n  );\n  function finish(event2) {\n    window.removeEventListener(\"mouseup\", finish);\n    window.removeEventListener(\"mousemove\", move);\n    const pluginState2 = columnResizingPluginKey.getState(view.state);\n    if (pluginState2 == null ? void 0 : pluginState2.dragging) {\n      updateColumnWidth(\n        view,\n        pluginState2.activeHandle,\n        draggedWidth(pluginState2.dragging, event2, cellMinWidth)\n      );\n      view.dispatch(\n        view.state.tr.setMeta(columnResizingPluginKey, { setDragging: null })\n      );\n    }\n  }\n  function move(event2) {\n    if (!event2.which)\n      return finish(event2);\n    const pluginState2 = columnResizingPluginKey.getState(view.state);\n    if (!pluginState2)\n      return;\n    if (pluginState2.dragging) {\n      const dragged = draggedWidth(pluginState2.dragging, event2, cellMinWidth);\n      displayColumnWidth(view, pluginState2.activeHandle, dragged, cellMinWidth);\n    }\n  }\n  window.addEventListener(\"mouseup\", finish);\n  window.addEventListener(\"mousemove\", move);\n  event.preventDefault();\n  return true;\n}\nfunction currentColWidth(view, cellPos, { colspan, colwidth }) {\n  const width = colwidth && colwidth[colwidth.length - 1];\n  if (width)\n    return width;\n  const dom = view.domAtPos(cellPos);\n  const node = dom.node.childNodes[dom.offset];\n  let domWidth = node.offsetWidth, parts = colspan;\n  if (colwidth) {\n    for (let i = 0; i < colspan; i++)\n      if (colwidth[i]) {\n        domWidth -= colwidth[i];\n        parts--;\n      }\n  }\n  return domWidth / parts;\n}\nfunction domCellAround(target) {\n  while (target && target.nodeName != \"TD\" && target.nodeName != \"TH\")\n    target = target.classList && target.classList.contains(\"ProseMirror\") ? null : target.parentNode;\n  return target;\n}\nfunction edgeCell(view, event, side) {\n  const found = view.posAtCoords({ left: event.clientX, top: event.clientY });\n  if (!found)\n    return -1;\n  const { pos } = found;\n  const $cell = cellAround(view.state.doc.resolve(pos));\n  if (!$cell)\n    return -1;\n  if (side == \"right\")\n    return $cell.pos;\n  const map = TableMap.get($cell.node(-1)), start = $cell.start(-1);\n  const index = map.map.indexOf($cell.pos - start);\n  return index % map.width == 0 ? -1 : start + map.map[index - 1];\n}\nfunction draggedWidth(dragging, event, cellMinWidth) {\n  const offset = event.clientX - dragging.startX;\n  return Math.max(cellMinWidth, dragging.startWidth + offset);\n}\nfunction updateHandle(view, value) {\n  view.dispatch(\n    view.state.tr.setMeta(columnResizingPluginKey, { setHandle: value })\n  );\n}\nfunction updateColumnWidth(view, cell, width) {\n  const $cell = view.state.doc.resolve(cell);\n  const table = $cell.node(-1), map = TableMap.get(table), start = $cell.start(-1);\n  const col = map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;\n  const tr = view.state.tr;\n  for (let row = 0; row < map.height; row++) {\n    const mapIndex = row * map.width + col;\n    if (row && map.map[mapIndex] == map.map[mapIndex - map.width])\n      continue;\n    const pos = map.map[mapIndex];\n    const attrs = table.nodeAt(pos).attrs;\n    const index = attrs.colspan == 1 ? 0 : col - map.colCount(pos);\n    if (attrs.colwidth && attrs.colwidth[index] == width)\n      continue;\n    const colwidth = attrs.colwidth ? attrs.colwidth.slice() : zeroes(attrs.colspan);\n    colwidth[index] = width;\n    tr.setNodeMarkup(start + pos, null, { ...attrs, colwidth });\n  }\n  if (tr.docChanged)\n    view.dispatch(tr);\n}\nfunction displayColumnWidth(view, cell, width, cellMinWidth) {\n  const $cell = view.state.doc.resolve(cell);\n  const table = $cell.node(-1), start = $cell.start(-1);\n  const col = TableMap.get(table).colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;\n  let dom = view.domAtPos($cell.start(-1)).node;\n  while (dom && dom.nodeName != \"TABLE\") {\n    dom = dom.parentNode;\n  }\n  if (!dom)\n    return;\n  updateColumnsOnResize(\n    table,\n    dom.firstChild,\n    dom,\n    cellMinWidth,\n    col,\n    width\n  );\n}\nfunction zeroes(n) {\n  return Array(n).fill(0);\n}\nfunction handleDecorations(state, cell) {\n  const decorations = [];\n  const $cell = state.doc.resolve(cell);\n  const table = $cell.node(-1);\n  if (!table) {\n    return DecorationSet2.empty;\n  }\n  const map = TableMap.get(table);\n  const start = $cell.start(-1);\n  const col = map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan;\n  for (let row = 0; row < map.height; row++) {\n    const index = col + row * map.width - 1;\n    if ((col == map.width || map.map[index] != map.map[index + 1]) && (row == 0 || map.map[index - 1] != map.map[index - 1 - map.width])) {\n      const cellPos = map.map[index];\n      const pos = start + cellPos + table.nodeAt(cellPos).nodeSize - 1;\n      const dom = document.createElement(\"div\");\n      dom.className = \"column-resize-handle\";\n      decorations.push(Decoration2.widget(pos, dom));\n    }\n  }\n  return DecorationSet2.create(state.doc, decorations);\n}\n\n// src/commands.ts\nimport { Fragment as Fragment4 } from \"prosemirror-model\";\nimport {\n  TextSelection as TextSelection3\n} from \"prosemirror-state\";\nfunction selectedRect(state) {\n  const sel = state.selection;\n  const $pos = selectionCell(state);\n  const table = $pos.node(-1);\n  const tableStart = $pos.start(-1);\n  const map = TableMap.get(table);\n  const rect = sel instanceof CellSelection ? map.rectBetween(\n    sel.$anchorCell.pos - tableStart,\n    sel.$headCell.pos - tableStart\n  ) : map.findCell($pos.pos - tableStart);\n  return { ...rect, tableStart, map, table };\n}\nfunction addColumn(tr, { map, tableStart, table }, col) {\n  let refColumn = col > 0 ? -1 : 0;\n  if (columnIsHeader(map, table, col + refColumn)) {\n    refColumn = col == 0 || col == map.width ? null : 0;\n  }\n  for (let row = 0; row < map.height; row++) {\n    const index = row * map.width + col;\n    if (col > 0 && col < map.width && map.map[index - 1] == map.map[index]) {\n      const pos = map.map[index];\n      const cell = table.nodeAt(pos);\n      tr.setNodeMarkup(\n        tr.mapping.map(tableStart + pos),\n        null,\n        addColSpan(cell.attrs, col - map.colCount(pos))\n      );\n      row += cell.attrs.rowspan - 1;\n    } else {\n      const type = refColumn == null ? tableNodeTypes(table.type.schema).cell : table.nodeAt(map.map[index + refColumn]).type;\n      const pos = map.positionAt(row, col, table);\n      tr.insert(tr.mapping.map(tableStart + pos), type.createAndFill());\n    }\n  }\n  return tr;\n}\nfunction addColumnBefore(state, dispatch) {\n  if (!isInTable(state))\n    return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    dispatch(addColumn(state.tr, rect, rect.left));\n  }\n  return true;\n}\nfunction addColumnAfter(state, dispatch) {\n  if (!isInTable(state))\n    return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    dispatch(addColumn(state.tr, rect, rect.right));\n  }\n  return true;\n}\nfunction removeColumn(tr, { map, table, tableStart }, col) {\n  const mapStart = tr.mapping.maps.length;\n  for (let row = 0; row < map.height; ) {\n    const index = row * map.width + col;\n    const pos = map.map[index];\n    const cell = table.nodeAt(pos);\n    const attrs = cell.attrs;\n    if (col > 0 && map.map[index - 1] == pos || col < map.width - 1 && map.map[index + 1] == pos) {\n      tr.setNodeMarkup(\n        tr.mapping.slice(mapStart).map(tableStart + pos),\n        null,\n        removeColSpan(attrs, col - map.colCount(pos))\n      );\n    } else {\n      const start = tr.mapping.slice(mapStart).map(tableStart + pos);\n      tr.delete(start, start + cell.nodeSize);\n    }\n    row += attrs.rowspan;\n  }\n}\nfunction deleteColumn(state, dispatch) {\n  if (!isInTable(state))\n    return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    const tr = state.tr;\n    if (rect.left == 0 && rect.right == rect.map.width)\n      return false;\n    for (let i = rect.right - 1; ; i--) {\n      removeColumn(tr, rect, i);\n      if (i == rect.left)\n        break;\n      const table = rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc;\n      if (!table) {\n        throw RangeError(\"No table found\");\n      }\n      rect.table = table;\n      rect.map = TableMap.get(table);\n    }\n    dispatch(tr);\n  }\n  return true;\n}\nfunction rowIsHeader(map, table, row) {\n  var _a;\n  const headerCell = tableNodeTypes(table.type.schema).header_cell;\n  for (let col = 0; col < map.width; col++)\n    if (((_a = table.nodeAt(map.map[col + row * map.width])) == null ? void 0 : _a.type) != headerCell)\n      return false;\n  return true;\n}\nfunction addRow(tr, { map, tableStart, table }, row) {\n  var _a;\n  let rowPos = tableStart;\n  for (let i = 0; i < row; i++)\n    rowPos += table.child(i).nodeSize;\n  const cells = [];\n  let refRow = row > 0 ? -1 : 0;\n  if (rowIsHeader(map, table, row + refRow))\n    refRow = row == 0 || row == map.height ? null : 0;\n  for (let col = 0, index = map.width * row; col < map.width; col++, index++) {\n    if (row > 0 && row < map.height && map.map[index] == map.map[index - map.width]) {\n      const pos = map.map[index];\n      const attrs = table.nodeAt(pos).attrs;\n      tr.setNodeMarkup(tableStart + pos, null, {\n        ...attrs,\n        rowspan: attrs.rowspan + 1\n      });\n      col += attrs.colspan - 1;\n    } else {\n      const type = refRow == null ? tableNodeTypes(table.type.schema).cell : (_a = table.nodeAt(map.map[index + refRow * map.width])) == null ? void 0 : _a.type;\n      const node = type == null ? void 0 : type.createAndFill();\n      if (node)\n        cells.push(node);\n    }\n  }\n  tr.insert(rowPos, tableNodeTypes(table.type.schema).row.create(null, cells));\n  return tr;\n}\nfunction addRowBefore(state, dispatch) {\n  if (!isInTable(state))\n    return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    dispatch(addRow(state.tr, rect, rect.top));\n  }\n  return true;\n}\nfunction addRowAfter(state, dispatch) {\n  if (!isInTable(state))\n    return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    dispatch(addRow(state.tr, rect, rect.bottom));\n  }\n  return true;\n}\nfunction removeRow(tr, { map, table, tableStart }, row) {\n  let rowPos = 0;\n  for (let i = 0; i < row; i++)\n    rowPos += table.child(i).nodeSize;\n  const nextRow = rowPos + table.child(row).nodeSize;\n  const mapFrom = tr.mapping.maps.length;\n  tr.delete(rowPos + tableStart, nextRow + tableStart);\n  for (let col = 0, index = row * map.width; col < map.width; col++, index++) {\n    const pos = map.map[index];\n    if (row > 0 && pos == map.map[index - map.width]) {\n      const attrs = table.nodeAt(pos).attrs;\n      tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + tableStart), null, {\n        ...attrs,\n        rowspan: attrs.rowspan - 1\n      });\n      col += attrs.colspan - 1;\n    } else if (row < map.width && pos == map.map[index + map.width]) {\n      const cell = table.nodeAt(pos);\n      const attrs = cell.attrs;\n      const copy = cell.type.create(\n        { ...attrs, rowspan: cell.attrs.rowspan - 1 },\n        cell.content\n      );\n      const newPos = map.positionAt(row + 1, col, table);\n      tr.insert(tr.mapping.slice(mapFrom).map(tableStart + newPos), copy);\n      col += attrs.colspan - 1;\n    }\n  }\n}\nfunction deleteRow(state, dispatch) {\n  if (!isInTable(state))\n    return false;\n  if (dispatch) {\n    const rect = selectedRect(state), tr = state.tr;\n    if (rect.top == 0 && rect.bottom == rect.map.height)\n      return false;\n    for (let i = rect.bottom - 1; ; i--) {\n      removeRow(tr, rect, i);\n      if (i == rect.top)\n        break;\n      const table = rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc;\n      if (!table) {\n        throw RangeError(\"No table found\");\n      }\n      rect.table = table;\n      rect.map = TableMap.get(rect.table);\n    }\n    dispatch(tr);\n  }\n  return true;\n}\nfunction isEmpty(cell) {\n  const c = cell.content;\n  return c.childCount == 1 && c.child(0).isTextblock && c.child(0).childCount == 0;\n}\nfunction cellsOverlapRectangle({ width, height, map }, rect) {\n  let indexTop = rect.top * width + rect.left, indexLeft = indexTop;\n  let indexBottom = (rect.bottom - 1) * width + rect.left, indexRight = indexTop + (rect.right - rect.left - 1);\n  for (let i = rect.top; i < rect.bottom; i++) {\n    if (rect.left > 0 && map[indexLeft] == map[indexLeft - 1] || rect.right < width && map[indexRight] == map[indexRight + 1])\n      return true;\n    indexLeft += width;\n    indexRight += width;\n  }\n  for (let i = rect.left; i < rect.right; i++) {\n    if (rect.top > 0 && map[indexTop] == map[indexTop - width] || rect.bottom < height && map[indexBottom] == map[indexBottom + width])\n      return true;\n    indexTop++;\n    indexBottom++;\n  }\n  return false;\n}\nfunction mergeCells(state, dispatch) {\n  const sel = state.selection;\n  if (!(sel instanceof CellSelection) || sel.$anchorCell.pos == sel.$headCell.pos)\n    return false;\n  const rect = selectedRect(state), { map } = rect;\n  if (cellsOverlapRectangle(map, rect))\n    return false;\n  if (dispatch) {\n    const tr = state.tr;\n    const seen = {};\n    let content = Fragment4.empty;\n    let mergedPos;\n    let mergedCell;\n    for (let row = rect.top; row < rect.bottom; row++) {\n      for (let col = rect.left; col < rect.right; col++) {\n        const cellPos = map.map[row * map.width + col];\n        const cell = rect.table.nodeAt(cellPos);\n        if (seen[cellPos] || !cell)\n          continue;\n        seen[cellPos] = true;\n        if (mergedPos == null) {\n          mergedPos = cellPos;\n          mergedCell = cell;\n        } else {\n          if (!isEmpty(cell))\n            content = content.append(cell.content);\n          const mapped = tr.mapping.map(cellPos + rect.tableStart);\n          tr.delete(mapped, mapped + cell.nodeSize);\n        }\n      }\n    }\n    if (mergedPos == null || mergedCell == null) {\n      return true;\n    }\n    tr.setNodeMarkup(mergedPos + rect.tableStart, null, {\n      ...addColSpan(\n        mergedCell.attrs,\n        mergedCell.attrs.colspan,\n        rect.right - rect.left - mergedCell.attrs.colspan\n      ),\n      rowspan: rect.bottom - rect.top\n    });\n    if (content.size) {\n      const end = mergedPos + 1 + mergedCell.content.size;\n      const start = isEmpty(mergedCell) ? mergedPos + 1 : end;\n      tr.replaceWith(start + rect.tableStart, end + rect.tableStart, content);\n    }\n    tr.setSelection(\n      new CellSelection(tr.doc.resolve(mergedPos + rect.tableStart))\n    );\n    dispatch(tr);\n  }\n  return true;\n}\nfunction splitCell(state, dispatch) {\n  const nodeTypes = tableNodeTypes(state.schema);\n  return splitCellWithType(({ node }) => {\n    return nodeTypes[node.type.spec.tableRole];\n  })(state, dispatch);\n}\nfunction splitCellWithType(getCellType) {\n  return (state, dispatch) => {\n    var _a;\n    const sel = state.selection;\n    let cellNode;\n    let cellPos;\n    if (!(sel instanceof CellSelection)) {\n      cellNode = cellWrapping(sel.$from);\n      if (!cellNode)\n        return false;\n      cellPos = (_a = cellAround(sel.$from)) == null ? void 0 : _a.pos;\n    } else {\n      if (sel.$anchorCell.pos != sel.$headCell.pos)\n        return false;\n      cellNode = sel.$anchorCell.nodeAfter;\n      cellPos = sel.$anchorCell.pos;\n    }\n    if (cellNode == null || cellPos == null) {\n      return false;\n    }\n    if (cellNode.attrs.colspan == 1 && cellNode.attrs.rowspan == 1) {\n      return false;\n    }\n    if (dispatch) {\n      let baseAttrs = cellNode.attrs;\n      const attrs = [];\n      const colwidth = baseAttrs.colwidth;\n      if (baseAttrs.rowspan > 1)\n        baseAttrs = { ...baseAttrs, rowspan: 1 };\n      if (baseAttrs.colspan > 1)\n        baseAttrs = { ...baseAttrs, colspan: 1 };\n      const rect = selectedRect(state), tr = state.tr;\n      for (let i = 0; i < rect.right - rect.left; i++)\n        attrs.push(\n          colwidth ? {\n            ...baseAttrs,\n            colwidth: colwidth && colwidth[i] ? [colwidth[i]] : null\n          } : baseAttrs\n        );\n      let lastCell;\n      for (let row = rect.top; row < rect.bottom; row++) {\n        let pos = rect.map.positionAt(row, rect.left, rect.table);\n        if (row == rect.top)\n          pos += cellNode.nodeSize;\n        for (let col = rect.left, i = 0; col < rect.right; col++, i++) {\n          if (col == rect.left && row == rect.top)\n            continue;\n          tr.insert(\n            lastCell = tr.mapping.map(pos + rect.tableStart, 1),\n            getCellType({ node: cellNode, row, col }).createAndFill(attrs[i])\n          );\n        }\n      }\n      tr.setNodeMarkup(\n        cellPos,\n        getCellType({ node: cellNode, row: rect.top, col: rect.left }),\n        attrs[0]\n      );\n      if (sel instanceof CellSelection)\n        tr.setSelection(\n          new CellSelection(\n            tr.doc.resolve(sel.$anchorCell.pos),\n            lastCell ? tr.doc.resolve(lastCell) : void 0\n          )\n        );\n      dispatch(tr);\n    }\n    return true;\n  };\n}\nfunction setCellAttr(name, value) {\n  return function(state, dispatch) {\n    if (!isInTable(state))\n      return false;\n    const $cell = selectionCell(state);\n    if ($cell.nodeAfter.attrs[name] === value)\n      return false;\n    if (dispatch) {\n      const tr = state.tr;\n      if (state.selection instanceof CellSelection)\n        state.selection.forEachCell((node, pos) => {\n          if (node.attrs[name] !== value)\n            tr.setNodeMarkup(pos, null, {\n              ...node.attrs,\n              [name]: value\n            });\n        });\n      else\n        tr.setNodeMarkup($cell.pos, null, {\n          ...$cell.nodeAfter.attrs,\n          [name]: value\n        });\n      dispatch(tr);\n    }\n    return true;\n  };\n}\nfunction deprecated_toggleHeader(type) {\n  return function(state, dispatch) {\n    if (!isInTable(state))\n      return false;\n    if (dispatch) {\n      const types = tableNodeTypes(state.schema);\n      const rect = selectedRect(state), tr = state.tr;\n      const cells = rect.map.cellsInRect(\n        type == \"column\" ? {\n          left: rect.left,\n          top: 0,\n          right: rect.right,\n          bottom: rect.map.height\n        } : type == \"row\" ? {\n          left: 0,\n          top: rect.top,\n          right: rect.map.width,\n          bottom: rect.bottom\n        } : rect\n      );\n      const nodes = cells.map((pos) => rect.table.nodeAt(pos));\n      for (let i = 0; i < cells.length; i++)\n        if (nodes[i].type == types.header_cell)\n          tr.setNodeMarkup(\n            rect.tableStart + cells[i],\n            types.cell,\n            nodes[i].attrs\n          );\n      if (tr.steps.length == 0)\n        for (let i = 0; i < cells.length; i++)\n          tr.setNodeMarkup(\n            rect.tableStart + cells[i],\n            types.header_cell,\n            nodes[i].attrs\n          );\n      dispatch(tr);\n    }\n    return true;\n  };\n}\nfunction isHeaderEnabledByType(type, rect, types) {\n  const cellPositions = rect.map.cellsInRect({\n    left: 0,\n    top: 0,\n    right: type == \"row\" ? rect.map.width : 1,\n    bottom: type == \"column\" ? rect.map.height : 1\n  });\n  for (let i = 0; i < cellPositions.length; i++) {\n    const cell = rect.table.nodeAt(cellPositions[i]);\n    if (cell && cell.type !== types.header_cell) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction toggleHeader(type, options) {\n  options = options || { useDeprecatedLogic: false };\n  if (options.useDeprecatedLogic)\n    return deprecated_toggleHeader(type);\n  return function(state, dispatch) {\n    if (!isInTable(state))\n      return false;\n    if (dispatch) {\n      const types = tableNodeTypes(state.schema);\n      const rect = selectedRect(state), tr = state.tr;\n      const isHeaderRowEnabled = isHeaderEnabledByType(\"row\", rect, types);\n      const isHeaderColumnEnabled = isHeaderEnabledByType(\n        \"column\",\n        rect,\n        types\n      );\n      const isHeaderEnabled = type === \"column\" ? isHeaderRowEnabled : type === \"row\" ? isHeaderColumnEnabled : false;\n      const selectionStartsAt = isHeaderEnabled ? 1 : 0;\n      const cellsRect = type == \"column\" ? {\n        left: 0,\n        top: selectionStartsAt,\n        right: 1,\n        bottom: rect.map.height\n      } : type == \"row\" ? {\n        left: selectionStartsAt,\n        top: 0,\n        right: rect.map.width,\n        bottom: 1\n      } : rect;\n      const newType = type == \"column\" ? isHeaderColumnEnabled ? types.cell : types.header_cell : type == \"row\" ? isHeaderRowEnabled ? types.cell : types.header_cell : types.cell;\n      rect.map.cellsInRect(cellsRect).forEach((relativeCellPos) => {\n        const cellPos = relativeCellPos + rect.tableStart;\n        const cell = tr.doc.nodeAt(cellPos);\n        if (cell) {\n          tr.setNodeMarkup(cellPos, newType, cell.attrs);\n        }\n      });\n      dispatch(tr);\n    }\n    return true;\n  };\n}\nvar toggleHeaderRow = toggleHeader(\"row\", {\n  useDeprecatedLogic: true\n});\nvar toggleHeaderColumn = toggleHeader(\"column\", {\n  useDeprecatedLogic: true\n});\nvar toggleHeaderCell = toggleHeader(\"cell\", {\n  useDeprecatedLogic: true\n});\nfunction findNextCell($cell, dir) {\n  if (dir < 0) {\n    const before = $cell.nodeBefore;\n    if (before)\n      return $cell.pos - before.nodeSize;\n    for (let row = $cell.index(-1) - 1, rowEnd = $cell.before(); row >= 0; row--) {\n      const rowNode = $cell.node(-1).child(row);\n      const lastChild = rowNode.lastChild;\n      if (lastChild) {\n        return rowEnd - 1 - lastChild.nodeSize;\n      }\n      rowEnd -= rowNode.nodeSize;\n    }\n  } else {\n    if ($cell.index() < $cell.parent.childCount - 1) {\n      return $cell.pos + $cell.nodeAfter.nodeSize;\n    }\n    const table = $cell.node(-1);\n    for (let row = $cell.indexAfter(-1), rowStart = $cell.after(); row < table.childCount; row++) {\n      const rowNode = table.child(row);\n      if (rowNode.childCount)\n        return rowStart + 1;\n      rowStart += rowNode.nodeSize;\n    }\n  }\n  return null;\n}\nfunction goToNextCell(direction) {\n  return function(state, dispatch) {\n    if (!isInTable(state))\n      return false;\n    const cell = findNextCell(selectionCell(state), direction);\n    if (cell == null)\n      return false;\n    if (dispatch) {\n      const $cell = state.doc.resolve(cell);\n      dispatch(\n        state.tr.setSelection(TextSelection3.between($cell, moveCellForward($cell))).scrollIntoView()\n      );\n    }\n    return true;\n  };\n}\nfunction deleteTable(state, dispatch) {\n  const $pos = state.selection.$anchor;\n  for (let d = $pos.depth; d > 0; d--) {\n    const node = $pos.node(d);\n    if (node.type.spec.tableRole == \"table\") {\n      if (dispatch)\n        dispatch(\n          state.tr.delete($pos.before(d), $pos.after(d)).scrollIntoView()\n        );\n      return true;\n    }\n  }\n  return false;\n}\n\n// src/index.ts\nfunction tableEditing({\n  allowTableNodeSelection = false\n} = {}) {\n  return new Plugin2({\n    key: tableEditingKey,\n    state: {\n      init() {\n        return null;\n      },\n      apply(tr, cur) {\n        const set = tr.getMeta(tableEditingKey);\n        if (set != null)\n          return set == -1 ? null : set;\n        if (cur == null || !tr.docChanged)\n          return cur;\n        const { deleted, pos } = tr.mapping.mapResult(cur);\n        return deleted ? null : pos;\n      }\n    },\n    props: {\n      decorations: drawCellSelection,\n      handleDOMEvents: {\n        mousedown: handleMouseDown\n      },\n      createSelectionBetween(view) {\n        return tableEditingKey.getState(view.state) != null ? view.state.selection : null;\n      },\n      handleTripleClick,\n      handleKeyDown,\n      handlePaste\n    },\n    appendTransaction(_, oldState, state) {\n      return normalizeSelection(\n        state,\n        fixTables(state, oldState),\n        allowTableNodeSelection\n      );\n    }\n  });\n}\nexport {\n  CellBookmark,\n  CellSelection,\n  ResizeState,\n  TableMap,\n  TableView,\n  clipCells as __clipCells,\n  insertCells as __insertCells,\n  pastedCells as __pastedCells,\n  addColSpan,\n  addColumn,\n  addColumnAfter,\n  addColumnBefore,\n  addRow,\n  addRowAfter,\n  addRowBefore,\n  cellAround,\n  colCount,\n  columnIsHeader,\n  columnResizing,\n  columnResizingPluginKey,\n  deleteColumn,\n  deleteRow,\n  deleteTable,\n  findCell,\n  fixTables,\n  fixTablesKey,\n  goToNextCell,\n  handlePaste,\n  inSameTable,\n  isInTable,\n  mergeCells,\n  moveCellForward,\n  nextCell,\n  pointsAtCell,\n  removeColSpan,\n  removeColumn,\n  removeRow,\n  rowIsHeader,\n  selectedRect,\n  selectionCell,\n  setCellAttr,\n  splitCell,\n  splitCellWithType,\n  tableEditing,\n  tableEditingKey,\n  tableNodeTypes,\n  tableNodes,\n  toggleHeader,\n  toggleHeaderCell,\n  toggleHeaderColumn,\n  toggleHeaderRow,\n  updateColumnsOnResize\n};\n","import { findParentNodeClosestToPos, Node, mergeAttributes, callOrReturn, getExtensionField } from '@tiptap/core';\nimport { TextSelection } from '@tiptap/pm/state';\nimport { CellSelection, addColumnBefore, addColumnAfter, deleteColumn, addRowBefore, addRowAfter, deleteRow, deleteTable, mergeCells, splitCell, toggleHeader, toggleHeaderCell, setCellAttr, goToNextCell, fixTables, columnResizing, tableEditing } from '@tiptap/pm/tables';\n\nfunction updateColumns(node, colgroup, table, cellMinWidth, overrideCol, overrideValue) {\r\n    let totalWidth = 0;\r\n    let fixedWidth = true;\r\n    let nextDOM = colgroup.firstChild;\r\n    const row = node.firstChild;\r\n    for (let i = 0, col = 0; i < row.childCount; i += 1) {\r\n        const { colspan, colwidth } = row.child(i).attrs;\r\n        for (let j = 0; j < colspan; j += 1, col += 1) {\r\n            const hasWidth = overrideCol === col ? overrideValue : colwidth && colwidth[j];\r\n            const cssWidth = hasWidth ? `${hasWidth}px` : '';\r\n            totalWidth += hasWidth || cellMinWidth;\r\n            if (!hasWidth) {\r\n                fixedWidth = false;\r\n            }\r\n            if (!nextDOM) {\r\n                colgroup.appendChild(document.createElement('col')).style.width = cssWidth;\r\n            }\r\n            else {\r\n                if (nextDOM.style.width !== cssWidth) {\r\n                    nextDOM.style.width = cssWidth;\r\n                }\r\n                nextDOM = nextDOM.nextSibling;\r\n            }\r\n        }\r\n    }\r\n    while (nextDOM) {\r\n        const after = nextDOM.nextSibling;\r\n        nextDOM.parentNode.removeChild(nextDOM);\r\n        nextDOM = after;\r\n    }\r\n    if (fixedWidth) {\r\n        table.style.width = `${totalWidth}px`;\r\n        table.style.minWidth = '';\r\n    }\r\n    else {\r\n        table.style.width = '';\r\n        table.style.minWidth = `${totalWidth}px`;\r\n    }\r\n}\r\nclass TableView {\r\n    constructor(node, cellMinWidth) {\r\n        this.node = node;\r\n        this.cellMinWidth = cellMinWidth;\r\n        this.dom = document.createElement('div');\r\n        this.dom.className = 'tableWrapper';\r\n        this.table = this.dom.appendChild(document.createElement('table'));\r\n        this.colgroup = this.table.appendChild(document.createElement('colgroup'));\r\n        updateColumns(node, this.colgroup, this.table, cellMinWidth);\r\n        this.contentDOM = this.table.appendChild(document.createElement('tbody'));\r\n    }\r\n    update(node) {\r\n        if (node.type !== this.node.type) {\r\n            return false;\r\n        }\r\n        this.node = node;\r\n        updateColumns(node, this.colgroup, this.table, this.cellMinWidth);\r\n        return true;\r\n    }\r\n    ignoreMutation(mutation) {\r\n        return (mutation.type === 'attributes'\r\n            && (mutation.target === this.table || this.colgroup.contains(mutation.target)));\r\n    }\r\n}\n\nfunction createCell(cellType, cellContent) {\r\n    if (cellContent) {\r\n        return cellType.createChecked(null, cellContent);\r\n    }\r\n    return cellType.createAndFill();\r\n}\n\nfunction getTableNodeTypes(schema) {\r\n    if (schema.cached.tableNodeTypes) {\r\n        return schema.cached.tableNodeTypes;\r\n    }\r\n    const roles = {};\r\n    Object.keys(schema.nodes).forEach(type => {\r\n        const nodeType = schema.nodes[type];\r\n        if (nodeType.spec.tableRole) {\r\n            roles[nodeType.spec.tableRole] = nodeType;\r\n        }\r\n    });\r\n    schema.cached.tableNodeTypes = roles;\r\n    return roles;\r\n}\n\nfunction createTable(schema, rowsCount, colsCount, withHeaderRow, cellContent) {\r\n    const types = getTableNodeTypes(schema);\r\n    const headerCells = [];\r\n    const cells = [];\r\n    for (let index = 0; index < colsCount; index += 1) {\r\n        const cell = createCell(types.cell, cellContent);\r\n        if (cell) {\r\n            cells.push(cell);\r\n        }\r\n        if (withHeaderRow) {\r\n            const headerCell = createCell(types.header_cell, cellContent);\r\n            if (headerCell) {\r\n                headerCells.push(headerCell);\r\n            }\r\n        }\r\n    }\r\n    const rows = [];\r\n    for (let index = 0; index < rowsCount; index += 1) {\r\n        rows.push(types.row.createChecked(null, withHeaderRow && index === 0 ? headerCells : cells));\r\n    }\r\n    return types.table.createChecked(null, rows);\r\n}\n\nfunction isCellSelection(value) {\r\n    return value instanceof CellSelection;\r\n}\n\nconst deleteTableWhenAllCellsSelected = ({ editor }) => {\r\n    const { selection } = editor.state;\r\n    if (!isCellSelection(selection)) {\r\n        return false;\r\n    }\r\n    let cellCount = 0;\r\n    const table = findParentNodeClosestToPos(selection.ranges[0].$from, node => {\r\n        return node.type.name === 'table';\r\n    });\r\n    table === null || table === void 0 ? void 0 : table.node.descendants(node => {\r\n        if (node.type.name === 'table') {\r\n            return false;\r\n        }\r\n        if (['tableCell', 'tableHeader'].includes(node.type.name)) {\r\n            cellCount += 1;\r\n        }\r\n    });\r\n    const allCellsSelected = cellCount === selection.ranges.length;\r\n    if (!allCellsSelected) {\r\n        return false;\r\n    }\r\n    editor.commands.deleteTable();\r\n    return true;\r\n};\n\nconst Table = Node.create({\r\n    name: 'table',\r\n    // @ts-ignore\r\n    addOptions() {\r\n        return {\r\n            HTMLAttributes: {},\r\n            resizable: false,\r\n            handleWidth: 5,\r\n            cellMinWidth: 25,\r\n            // TODO: fix\r\n            View: TableView,\r\n            lastColumnResizable: true,\r\n            allowTableNodeSelection: false,\r\n        };\r\n    },\r\n    content: 'tableRow+',\r\n    tableRole: 'table',\r\n    isolating: true,\r\n    group: 'block',\r\n    parseHTML() {\r\n        return [{ tag: 'table' }];\r\n    },\r\n    renderHTML({ HTMLAttributes }) {\r\n        return ['table', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), ['tbody', 0]];\r\n    },\r\n    addCommands() {\r\n        return {\r\n            insertTable: ({ rows = 3, cols = 3, withHeaderRow = true } = {}) => ({ tr, dispatch, editor }) => {\r\n                const node = createTable(editor.schema, rows, cols, withHeaderRow);\r\n                if (dispatch) {\r\n                    const offset = tr.selection.anchor + 1;\r\n                    tr.replaceSelectionWith(node)\r\n                        .scrollIntoView()\r\n                        .setSelection(TextSelection.near(tr.doc.resolve(offset)));\r\n                }\r\n                return true;\r\n            },\r\n            addColumnBefore: () => ({ state, dispatch }) => {\r\n                return addColumnBefore(state, dispatch);\r\n            },\r\n            addColumnAfter: () => ({ state, dispatch }) => {\r\n                return addColumnAfter(state, dispatch);\r\n            },\r\n            deleteColumn: () => ({ state, dispatch }) => {\r\n                return deleteColumn(state, dispatch);\r\n            },\r\n            addRowBefore: () => ({ state, dispatch }) => {\r\n                return addRowBefore(state, dispatch);\r\n            },\r\n            addRowAfter: () => ({ state, dispatch }) => {\r\n                return addRowAfter(state, dispatch);\r\n            },\r\n            deleteRow: () => ({ state, dispatch }) => {\r\n                return deleteRow(state, dispatch);\r\n            },\r\n            deleteTable: () => ({ state, dispatch }) => {\r\n                return deleteTable(state, dispatch);\r\n            },\r\n            mergeCells: () => ({ state, dispatch }) => {\r\n                return mergeCells(state, dispatch);\r\n            },\r\n            splitCell: () => ({ state, dispatch }) => {\r\n                return splitCell(state, dispatch);\r\n            },\r\n            toggleHeaderColumn: () => ({ state, dispatch }) => {\r\n                return toggleHeader('column')(state, dispatch);\r\n            },\r\n            toggleHeaderRow: () => ({ state, dispatch }) => {\r\n                return toggleHeader('row')(state, dispatch);\r\n            },\r\n            toggleHeaderCell: () => ({ state, dispatch }) => {\r\n                return toggleHeaderCell(state, dispatch);\r\n            },\r\n            mergeOrSplit: () => ({ state, dispatch }) => {\r\n                if (mergeCells(state, dispatch)) {\r\n                    return true;\r\n                }\r\n                return splitCell(state, dispatch);\r\n            },\r\n            setCellAttribute: (name, value) => ({ state, dispatch }) => {\r\n                return setCellAttr(name, value)(state, dispatch);\r\n            },\r\n            goToNextCell: () => ({ state, dispatch }) => {\r\n                return goToNextCell(1)(state, dispatch);\r\n            },\r\n            goToPreviousCell: () => ({ state, dispatch }) => {\r\n                return goToNextCell(-1)(state, dispatch);\r\n            },\r\n            fixTables: () => ({ state, dispatch }) => {\r\n                if (dispatch) {\r\n                    fixTables(state);\r\n                }\r\n                return true;\r\n            },\r\n            setCellSelection: position => ({ tr, dispatch }) => {\r\n                if (dispatch) {\r\n                    const selection = CellSelection.create(tr.doc, position.anchorCell, position.headCell);\r\n                    // @ts-ignore\r\n                    tr.setSelection(selection);\r\n                }\r\n                return true;\r\n            },\r\n        };\r\n    },\r\n    addKeyboardShortcuts() {\r\n        return {\r\n            Tab: () => {\r\n                if (this.editor.commands.goToNextCell()) {\r\n                    return true;\r\n                }\r\n                if (!this.editor.can().addRowAfter()) {\r\n                    return false;\r\n                }\r\n                return this.editor.chain().addRowAfter().goToNextCell().run();\r\n            },\r\n            'Shift-Tab': () => this.editor.commands.goToPreviousCell(),\r\n            Backspace: deleteTableWhenAllCellsSelected,\r\n            'Mod-Backspace': deleteTableWhenAllCellsSelected,\r\n            Delete: deleteTableWhenAllCellsSelected,\r\n            'Mod-Delete': deleteTableWhenAllCellsSelected,\r\n        };\r\n    },\r\n    addProseMirrorPlugins() {\r\n        const isResizable = this.options.resizable && this.editor.isEditable;\r\n        return [\r\n            ...(isResizable\r\n                ? [\r\n                    columnResizing({\r\n                        handleWidth: this.options.handleWidth,\r\n                        cellMinWidth: this.options.cellMinWidth,\r\n                        // @ts-ignore (incorrect type)\r\n                        View: this.options.View,\r\n                        // TODO: PR for @types/prosemirror-tables\r\n                        // @ts-ignore (incorrect type)\r\n                        lastColumnResizable: this.options.lastColumnResizable,\r\n                    }),\r\n                ]\r\n                : []),\r\n            tableEditing({\r\n                allowTableNodeSelection: this.options.allowTableNodeSelection,\r\n            }),\r\n        ];\r\n    },\r\n    extendNodeSchema(extension) {\r\n        const context = {\r\n            name: extension.name,\r\n            options: extension.options,\r\n            storage: extension.storage,\r\n        };\r\n        return {\r\n            tableRole: callOrReturn(getExtensionField(extension, 'tableRole', context)),\r\n        };\r\n    },\r\n});\n\nexport { Table, createTable, Table as default };\n//# sourceMappingURL=index.js.map\n"],"names":["readFromCache","addToCache","WeakMap","cache","key","get","value","set","cacheSize","cachePos","i","length","TableMap","constructor","width","height","map","problems","this","findCell","pos","curPos","left","top","right","bottom","j","RangeError","colCount","nextCell","axis","dir","rectBetween","a","b","leftA","rightA","topA","bottomA","leftB","rightB","topB","bottomB","Math","min","max","cellsInRect","rect","result","seen","row","col","index","push","positionAt","table","rowStart","rowEnd","child","nodeSize","rowEndIndex","static","type","spec","tableRole","name","hasRowSpan","childCount","rowNode","rowWidth","prevRow","cell","attrs","rowspan","colspan","findWidth","mapPos","colWidths","e","cellNode","colwidth","h","n","start","w","colW","widthIndex","prev","expectedPos","missing","tableMap","badWidths","node","nodeAt","updated","colWidth","freshColWidth","unshift","findBadColWidths","computeMap","slice","tableNodeTypes","schema","cached","nodes","role","tableEditingKey","cellAround","$pos","d","depth","resolve","before","isInTable","state","$head","selection","selectionCell","sel","$anchorCell","$headCell","$anchor","$cell","after","nodeAfter","firstChild","doc","nodeBefore","lastChild","cellNear","head","pointsAtCell","parent","inSameTable","$cellA","$cellB","end","tableStart","moved","removeColSpan","splice","some","addColSpan","CellSelection","cells","filter","p","ranges","from","content","size","super","$from","$to","mapping","tableChanged","isRowSelection","rowSelection","isColSelection","colSelection","rows","rowContent","cellRect","extraLeft","extraRight","createAndFill","JSON","stringify","create","copy","fragment","replace","tr","mapFrom","steps","to","setSelection","replaceWith","forEachCell","f","anchorTop","headTop","anchorBottom","headBottom","anchorRect","headRect","anchorLeft","headLeft","anchorRight","headRight","eq","other","toJSON","anchor","json","anchorCell","headCell","getBookmark","CellBookmark","prototype","visible","drawCellSelection","class","fixTablesKey","changedDescendants","old","cur","offset","oldSize","curSize","outer","scan","sameMarkup","nodesBetween","fixTables","oldState","check","tablePos","mustAdd","prob","setNodeMarkup","first","last","add","side","insert","setMeta","fixTable","descendants","pastedCells","openStart","openEnd","fitSlice","widths","r","empty","append","ensureRectangular","nodeType","isolateHorizontal","found","cellTop","cellLeft","isolateVertical","updatePos","insertCells","dispatch","Error","recomp","maps","types","emptyHead","header_cell","start2","header","emptyRow","growTable","handleKeyDown","ArrowLeft","arrow","ArrowRight","ArrowUp","ArrowDown","shiftArrow","Backspace","deleteCellSelection","Delete","maybeSetSelection","scrollIntoView","view","atEndOfCell","$next","newSel","cellSel","baseContent","docChanged","handleTripleClick","handlePaste","_","newWidth","newHeight","added","newRows","frag","createChecked","source","clipCells","handleMouseDown","startEvent","_a","ctrlKey","metaKey","startDOMCell","domInCell","target","shiftKey","setCellSelection","preventDefault","cellUnderMouse","$anchor2","event","starting","getState","stop","root","removeEventListener","move","_event","addEventListener","indexAfter","cellPos","dirStr","endOfTextblock","dom","parentNode","nodeName","mousePos","posAtCoords","clientX","clientY","TableView","cellMinWidth","document","createElement","className","appendChild","colgroup","updateColumnsOnResize","contentDOM","update","ignoreMutation","record","contains","overrideCol","overrideValue","totalWidth","fixedWidth","nextDOM","hasWidth","cssWidth","style","nextSibling","removeChild","minWidth","columnResizingPluginKey","columnResizing","handleWidth","View","lastColumnResizable","plugin","init","props","nodeViews","ResizeState","apply","attributes","pluginState","activeHandle","handleDOMEvents","mousemove","dragging","classList","domCellAround","getBoundingClientRect","edgeCell","updateHandle","handleMouseMove","mouseleave","handleMouseLeave","mousedown","domAtPos","domWidth","childNodes","offsetWidth","parts","currentColWidth","finish","event2","window","pluginState2","mapIndex","zeroes","updateColumnWidth","draggedWidth","setDragging","which","dragged","displayColumnWidth","startX","startWidth","handleMouseDown2","decorations","handleDecorations","action","getMeta","setHandle","handle","indexOf","Array","fill","selectedRect","addColumn","refColumn","headerCell","columnIsHeader","removeColumn","mapStart","delete","addRow","rowPos","refRow","rowIsHeader","removeRow","nextRow","newPos","isEmpty","c","isTextblock","mergeCells","indexTop","indexLeft","indexBottom","indexRight","cellsOverlapRectangle","mergedPos","mergedCell","mapped","splitCell","nodeTypes","getCellType","cellWrapping","baseAttrs","lastCell","isHeaderEnabledByType","cellPositions","toggleHeader","options","useDeprecatedLogic","deprecated_toggleHeader","isHeaderRowEnabled","isHeaderColumnEnabled","selectionStartsAt","cellsRect","newType","forEach","relativeCellPos","toggleHeaderCell","goToNextCell","direction","findNextCell","tableEditing","allowTableNodeSelection","deleted","mapResult","createSelectionBetween","appendTransaction","normalize","afterFrom","beforeTo","test","isCellBoundarySelection","fromCellBoundaryNode","toCellBoundaryNode","parentOffset","isTextSelectionAcrossCells","normalizeSelection","updateColumns","mutation","createCell","cellType","cellContent","createTable","rowsCount","colsCount","withHeaderRow","roles","Object","keys","getTableNodeTypes","headerCells","deleteTableWhenAllCellsSelected","editor","cellCount","findParentNodeClosestToPos","includes","commands","deleteTable","Table","Node","addOptions","HTMLAttributes","resizable","isolating","group","parseHTML","tag","renderHTML","mergeAttributes","addCommands","insertTable","cols","replaceSelectionWith","addColumnBefore","addColumnAfter","deleteColumn","addRowBefore","addRowAfter","deleteRow","toggleHeaderColumn","toggleHeaderRow","mergeOrSplit","setCellAttribute","setCellAttr","goToPreviousCell","position","addKeyboardShortcuts","Tab","can","chain","run","addProseMirrorPlugins","isEditable","extendNodeSchema","extension","context","storage","callOrReturn","getExtensionField"],"sourceRoot":""}