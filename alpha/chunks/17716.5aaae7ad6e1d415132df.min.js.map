{"version":3,"file":"chunks/17716.5aaae7ad6e1d415132df.min.js","mappings":"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","sources":["webpack://@patternslib/patternslib/./node_modules/prosemirror-tables/dist/index.js","webpack://@patternslib/patternslib/./node_modules/@tiptap/extension-table/dist/index.js","webpack://@patternslib/patternslib/./node_modules/@patternslib/pat-tiptap/src/extensions/table.js"],"sourcesContent":["// src/index.ts\nimport { Plugin as Plugin2 } from \"prosemirror-state\";\n\n// src/cellselection.ts\nimport { Fragment, Slice } from \"prosemirror-model\";\nimport {\n  NodeSelection as NodeSelection2,\n  Selection,\n  SelectionRange,\n  TextSelection\n} from \"prosemirror-state\";\nimport { Decoration, DecorationSet } from \"prosemirror-view\";\n\n// src/tablemap.ts\nvar readFromCache;\nvar addToCache;\nif (typeof WeakMap != \"undefined\") {\n  let cache = /* @__PURE__ */ new WeakMap();\n  readFromCache = (key) => cache.get(key);\n  addToCache = (key, value) => {\n    cache.set(key, value);\n    return value;\n  };\n} else {\n  const cache = [];\n  const cacheSize = 10;\n  let cachePos = 0;\n  readFromCache = (key) => {\n    for (let i = 0; i < cache.length; i += 2)\n      if (cache[i] == key)\n        return cache[i + 1];\n  };\n  addToCache = (key, value) => {\n    if (cachePos == cacheSize)\n      cachePos = 0;\n    cache[cachePos++] = key;\n    return cache[cachePos++] = value;\n  };\n}\nvar TableMap = class {\n  constructor(width, height, map, problems) {\n    this.width = width;\n    this.height = height;\n    this.map = map;\n    this.problems = problems;\n  }\n  findCell(pos) {\n    for (let i = 0; i < this.map.length; i++) {\n      const curPos = this.map[i];\n      if (curPos != pos)\n        continue;\n      const left = i % this.width;\n      const top = i / this.width | 0;\n      let right = left + 1;\n      let bottom = top + 1;\n      for (let j = 1; right < this.width && this.map[i + j] == curPos; j++) {\n        right++;\n      }\n      for (let j = 1; bottom < this.height && this.map[i + this.width * j] == curPos; j++) {\n        bottom++;\n      }\n      return { left, top, right, bottom };\n    }\n    throw new RangeError(`No cell with offset ${pos} found`);\n  }\n  colCount(pos) {\n    for (let i = 0; i < this.map.length; i++) {\n      if (this.map[i] == pos) {\n        return i % this.width;\n      }\n    }\n    throw new RangeError(`No cell with offset ${pos} found`);\n  }\n  nextCell(pos, axis, dir) {\n    const { left, right, top, bottom } = this.findCell(pos);\n    if (axis == \"horiz\") {\n      if (dir < 0 ? left == 0 : right == this.width)\n        return null;\n      return this.map[top * this.width + (dir < 0 ? left - 1 : right)];\n    } else {\n      if (dir < 0 ? top == 0 : bottom == this.height)\n        return null;\n      return this.map[left + this.width * (dir < 0 ? top - 1 : bottom)];\n    }\n  }\n  rectBetween(a, b) {\n    const {\n      left: leftA,\n      right: rightA,\n      top: topA,\n      bottom: bottomA\n    } = this.findCell(a);\n    const {\n      left: leftB,\n      right: rightB,\n      top: topB,\n      bottom: bottomB\n    } = this.findCell(b);\n    return {\n      left: Math.min(leftA, leftB),\n      top: Math.min(topA, topB),\n      right: Math.max(rightA, rightB),\n      bottom: Math.max(bottomA, bottomB)\n    };\n  }\n  cellsInRect(rect) {\n    const result = [];\n    const seen = {};\n    for (let row = rect.top; row < rect.bottom; row++) {\n      for (let col = rect.left; col < rect.right; col++) {\n        const index = row * this.width + col;\n        const pos = this.map[index];\n        if (seen[pos])\n          continue;\n        seen[pos] = true;\n        if (col == rect.left && col && this.map[index - 1] == pos || row == rect.top && row && this.map[index - this.width] == pos) {\n          continue;\n        }\n        result.push(pos);\n      }\n    }\n    return result;\n  }\n  positionAt(row, col, table) {\n    for (let i = 0, rowStart = 0; ; i++) {\n      const rowEnd = rowStart + table.child(i).nodeSize;\n      if (i == row) {\n        let index = col + row * this.width;\n        const rowEndIndex = (row + 1) * this.width;\n        while (index < rowEndIndex && this.map[index] < rowStart)\n          index++;\n        return index == rowEndIndex ? rowEnd - 1 : this.map[index];\n      }\n      rowStart = rowEnd;\n    }\n  }\n  static get(table) {\n    return readFromCache(table) || addToCache(table, computeMap(table));\n  }\n};\nfunction computeMap(table) {\n  if (table.type.spec.tableRole != \"table\")\n    throw new RangeError(\"Not a table node: \" + table.type.name);\n  const width = findWidth(table), height = table.childCount;\n  const map = [];\n  let mapPos = 0;\n  let problems = null;\n  const colWidths = [];\n  for (let i = 0, e = width * height; i < e; i++)\n    map[i] = 0;\n  for (let row = 0, pos = 0; row < height; row++) {\n    const rowNode = table.child(row);\n    pos++;\n    for (let i = 0; ; i++) {\n      while (mapPos < map.length && map[mapPos] != 0)\n        mapPos++;\n      if (i == rowNode.childCount)\n        break;\n      const cellNode = rowNode.child(i);\n      const { colspan, rowspan, colwidth } = cellNode.attrs;\n      for (let h = 0; h < rowspan; h++) {\n        if (h + row >= height) {\n          (problems || (problems = [])).push({\n            type: \"overlong_rowspan\",\n            pos,\n            n: rowspan - h\n          });\n          break;\n        }\n        const start = mapPos + h * width;\n        for (let w = 0; w < colspan; w++) {\n          if (map[start + w] == 0)\n            map[start + w] = pos;\n          else\n            (problems || (problems = [])).push({\n              type: \"collision\",\n              row,\n              pos,\n              n: colspan - w\n            });\n          const colW = colwidth && colwidth[w];\n          if (colW) {\n            const widthIndex = (start + w) % width * 2, prev = colWidths[widthIndex];\n            if (prev == null || prev != colW && colWidths[widthIndex + 1] == 1) {\n              colWidths[widthIndex] = colW;\n              colWidths[widthIndex + 1] = 1;\n            } else if (prev == colW) {\n              colWidths[widthIndex + 1]++;\n            }\n          }\n        }\n      }\n      mapPos += colspan;\n      pos += cellNode.nodeSize;\n    }\n    const expectedPos = (row + 1) * width;\n    let missing = 0;\n    while (mapPos < expectedPos)\n      if (map[mapPos++] == 0)\n        missing++;\n    if (missing)\n      (problems || (problems = [])).push({ type: \"missing\", row, n: missing });\n    pos++;\n  }\n  const tableMap = new TableMap(width, height, map, problems);\n  let badWidths = false;\n  for (let i = 0; !badWidths && i < colWidths.length; i += 2)\n    if (colWidths[i] != null && colWidths[i + 1] < height)\n      badWidths = true;\n  if (badWidths)\n    findBadColWidths(tableMap, colWidths, table);\n  return tableMap;\n}\nfunction findWidth(table) {\n  let width = -1;\n  let hasRowSpan = false;\n  for (let row = 0; row < table.childCount; row++) {\n    const rowNode = table.child(row);\n    let rowWidth = 0;\n    if (hasRowSpan)\n      for (let j = 0; j < row; j++) {\n        const prevRow = table.child(j);\n        for (let i = 0; i < prevRow.childCount; i++) {\n          const cell = prevRow.child(i);\n          if (j + cell.attrs.rowspan > row)\n            rowWidth += cell.attrs.colspan;\n        }\n      }\n    for (let i = 0; i < rowNode.childCount; i++) {\n      const cell = rowNode.child(i);\n      rowWidth += cell.attrs.colspan;\n      if (cell.attrs.rowspan > 1)\n        hasRowSpan = true;\n    }\n    if (width == -1)\n      width = rowWidth;\n    else if (width != rowWidth)\n      width = Math.max(width, rowWidth);\n  }\n  return width;\n}\nfunction findBadColWidths(map, colWidths, table) {\n  if (!map.problems)\n    map.problems = [];\n  const seen = {};\n  for (let i = 0; i < map.map.length; i++) {\n    const pos = map.map[i];\n    if (seen[pos])\n      continue;\n    seen[pos] = true;\n    const node = table.nodeAt(pos);\n    if (!node) {\n      throw new RangeError(`No cell with offset ${pos} found`);\n    }\n    let updated = null;\n    const attrs = node.attrs;\n    for (let j = 0; j < attrs.colspan; j++) {\n      const col = (i + j) % map.width;\n      const colWidth = colWidths[col * 2];\n      if (colWidth != null && (!attrs.colwidth || attrs.colwidth[j] != colWidth))\n        (updated || (updated = freshColWidth(attrs)))[j] = colWidth;\n    }\n    if (updated)\n      map.problems.unshift({\n        type: \"colwidth mismatch\",\n        pos,\n        colwidth: updated\n      });\n  }\n}\nfunction freshColWidth(attrs) {\n  if (attrs.colwidth)\n    return attrs.colwidth.slice();\n  const result = [];\n  for (let i = 0; i < attrs.colspan; i++)\n    result.push(0);\n  return result;\n}\n\n// src/util.ts\nimport { PluginKey } from \"prosemirror-state\";\n\n// src/schema.ts\nfunction getCellAttrs(dom, extraAttrs) {\n  if (typeof dom === \"string\") {\n    return {};\n  }\n  const widthAttr = dom.getAttribute(\"data-colwidth\");\n  const widths = widthAttr && /^\\d+(,\\d+)*$/.test(widthAttr) ? widthAttr.split(\",\").map((s) => Number(s)) : null;\n  const colspan = Number(dom.getAttribute(\"colspan\") || 1);\n  const result = {\n    colspan,\n    rowspan: Number(dom.getAttribute(\"rowspan\") || 1),\n    colwidth: widths && widths.length == colspan ? widths : null\n  };\n  for (const prop in extraAttrs) {\n    const getter = extraAttrs[prop].getFromDOM;\n    const value = getter && getter(dom);\n    if (value != null) {\n      result[prop] = value;\n    }\n  }\n  return result;\n}\nfunction setCellAttrs(node, extraAttrs) {\n  const attrs = {};\n  if (node.attrs.colspan != 1)\n    attrs.colspan = node.attrs.colspan;\n  if (node.attrs.rowspan != 1)\n    attrs.rowspan = node.attrs.rowspan;\n  if (node.attrs.colwidth)\n    attrs[\"data-colwidth\"] = node.attrs.colwidth.join(\",\");\n  for (const prop in extraAttrs) {\n    const setter = extraAttrs[prop].setDOMAttr;\n    if (setter)\n      setter(node.attrs[prop], attrs);\n  }\n  return attrs;\n}\nfunction tableNodes(options) {\n  const extraAttrs = options.cellAttributes || {};\n  const cellAttrs = {\n    colspan: { default: 1 },\n    rowspan: { default: 1 },\n    colwidth: { default: null }\n  };\n  for (const prop in extraAttrs)\n    cellAttrs[prop] = { default: extraAttrs[prop].default };\n  return {\n    table: {\n      content: \"table_row+\",\n      tableRole: \"table\",\n      isolating: true,\n      group: options.tableGroup,\n      parseDOM: [{ tag: \"table\" }],\n      toDOM() {\n        return [\"table\", [\"tbody\", 0]];\n      }\n    },\n    table_row: {\n      content: \"(table_cell | table_header)*\",\n      tableRole: \"row\",\n      parseDOM: [{ tag: \"tr\" }],\n      toDOM() {\n        return [\"tr\", 0];\n      }\n    },\n    table_cell: {\n      content: options.cellContent,\n      attrs: cellAttrs,\n      tableRole: \"cell\",\n      isolating: true,\n      parseDOM: [\n        { tag: \"td\", getAttrs: (dom) => getCellAttrs(dom, extraAttrs) }\n      ],\n      toDOM(node) {\n        return [\"td\", setCellAttrs(node, extraAttrs), 0];\n      }\n    },\n    table_header: {\n      content: options.cellContent,\n      attrs: cellAttrs,\n      tableRole: \"header_cell\",\n      isolating: true,\n      parseDOM: [\n        { tag: \"th\", getAttrs: (dom) => getCellAttrs(dom, extraAttrs) }\n      ],\n      toDOM(node) {\n        return [\"th\", setCellAttrs(node, extraAttrs), 0];\n      }\n    }\n  };\n}\nfunction tableNodeTypes(schema) {\n  let result = schema.cached.tableNodeTypes;\n  if (!result) {\n    result = schema.cached.tableNodeTypes = {};\n    for (const name in schema.nodes) {\n      const type = schema.nodes[name], role = type.spec.tableRole;\n      if (role)\n        result[role] = type;\n    }\n  }\n  return result;\n}\n\n// src/util.ts\nvar tableEditingKey = new PluginKey(\"selectingCells\");\nfunction cellAround($pos) {\n  for (let d = $pos.depth - 1; d > 0; d--)\n    if ($pos.node(d).type.spec.tableRole == \"row\")\n      return $pos.node(0).resolve($pos.before(d + 1));\n  return null;\n}\nfunction cellWrapping($pos) {\n  for (let d = $pos.depth; d > 0; d--) {\n    const role = $pos.node(d).type.spec.tableRole;\n    if (role === \"cell\" || role === \"header_cell\")\n      return $pos.node(d);\n  }\n  return null;\n}\nfunction isInTable(state) {\n  const $head = state.selection.$head;\n  for (let d = $head.depth; d > 0; d--)\n    if ($head.node(d).type.spec.tableRole == \"row\")\n      return true;\n  return false;\n}\nfunction selectionCell(state) {\n  const sel = state.selection;\n  if (\"$anchorCell\" in sel && sel.$anchorCell) {\n    return sel.$anchorCell.pos > sel.$headCell.pos ? sel.$anchorCell : sel.$headCell;\n  } else if (\"node\" in sel && sel.node && sel.node.type.spec.tableRole == \"cell\") {\n    return sel.$anchor;\n  }\n  const $cell = cellAround(sel.$head) || cellNear(sel.$head);\n  if ($cell) {\n    return $cell;\n  }\n  throw new RangeError(`No cell found around position ${sel.head}`);\n}\nfunction cellNear($pos) {\n  for (let after = $pos.nodeAfter, pos = $pos.pos; after; after = after.firstChild, pos++) {\n    const role = after.type.spec.tableRole;\n    if (role == \"cell\" || role == \"header_cell\")\n      return $pos.doc.resolve(pos);\n  }\n  for (let before = $pos.nodeBefore, pos = $pos.pos; before; before = before.lastChild, pos--) {\n    const role = before.type.spec.tableRole;\n    if (role == \"cell\" || role == \"header_cell\")\n      return $pos.doc.resolve(pos - before.nodeSize);\n  }\n}\nfunction pointsAtCell($pos) {\n  return $pos.parent.type.spec.tableRole == \"row\" && !!$pos.nodeAfter;\n}\nfunction moveCellForward($pos) {\n  return $pos.node(0).resolve($pos.pos + $pos.nodeAfter.nodeSize);\n}\nfunction inSameTable($cellA, $cellB) {\n  return $cellA.depth == $cellB.depth && $cellA.pos >= $cellB.start(-1) && $cellA.pos <= $cellB.end(-1);\n}\nfunction findCell($pos) {\n  return TableMap.get($pos.node(-1)).findCell($pos.pos - $pos.start(-1));\n}\nfunction colCount($pos) {\n  return TableMap.get($pos.node(-1)).colCount($pos.pos - $pos.start(-1));\n}\nfunction nextCell($pos, axis, dir) {\n  const table = $pos.node(-1);\n  const map = TableMap.get(table);\n  const tableStart = $pos.start(-1);\n  const moved = map.nextCell($pos.pos - tableStart, axis, dir);\n  return moved == null ? null : $pos.node(0).resolve(tableStart + moved);\n}\nfunction removeColSpan(attrs, pos, n = 1) {\n  const result = { ...attrs, colspan: attrs.colspan - n };\n  if (result.colwidth) {\n    result.colwidth = result.colwidth.slice();\n    result.colwidth.splice(pos, n);\n    if (!result.colwidth.some((w) => w > 0))\n      result.colwidth = null;\n  }\n  return result;\n}\nfunction addColSpan(attrs, pos, n = 1) {\n  const result = { ...attrs, colspan: attrs.colspan + n };\n  if (result.colwidth) {\n    result.colwidth = result.colwidth.slice();\n    for (let i = 0; i < n; i++)\n      result.colwidth.splice(pos, 0, 0);\n  }\n  return result;\n}\nfunction columnIsHeader(map, table, col) {\n  const headerCell = tableNodeTypes(table.type.schema).header_cell;\n  for (let row = 0; row < map.height; row++)\n    if (table.nodeAt(map.map[col + row * map.width]).type != headerCell)\n      return false;\n  return true;\n}\n\n// src/cellselection.ts\nvar CellSelection = class extends Selection {\n  constructor($anchorCell, $headCell = $anchorCell) {\n    const table = $anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = $anchorCell.start(-1);\n    const rect = map.rectBetween(\n      $anchorCell.pos - tableStart,\n      $headCell.pos - tableStart\n    );\n    const doc = $anchorCell.node(0);\n    const cells = map.cellsInRect(rect).filter((p) => p != $headCell.pos - tableStart);\n    cells.unshift($headCell.pos - tableStart);\n    const ranges = cells.map((pos) => {\n      const cell = table.nodeAt(pos);\n      if (!cell) {\n        throw RangeError(`No cell with offset ${pos} found`);\n      }\n      const from = tableStart + pos + 1;\n      return new SelectionRange(\n        doc.resolve(from),\n        doc.resolve(from + cell.content.size)\n      );\n    });\n    super(ranges[0].$from, ranges[0].$to, ranges);\n    this.$anchorCell = $anchorCell;\n    this.$headCell = $headCell;\n  }\n  map(doc, mapping) {\n    const $anchorCell = doc.resolve(mapping.map(this.$anchorCell.pos));\n    const $headCell = doc.resolve(mapping.map(this.$headCell.pos));\n    if (pointsAtCell($anchorCell) && pointsAtCell($headCell) && inSameTable($anchorCell, $headCell)) {\n      const tableChanged = this.$anchorCell.node(-1) != $anchorCell.node(-1);\n      if (tableChanged && this.isRowSelection())\n        return CellSelection.rowSelection($anchorCell, $headCell);\n      else if (tableChanged && this.isColSelection())\n        return CellSelection.colSelection($anchorCell, $headCell);\n      else\n        return new CellSelection($anchorCell, $headCell);\n    }\n    return TextSelection.between($anchorCell, $headCell);\n  }\n  content() {\n    const table = this.$anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = this.$anchorCell.start(-1);\n    const rect = map.rectBetween(\n      this.$anchorCell.pos - tableStart,\n      this.$headCell.pos - tableStart\n    );\n    const seen = {};\n    const rows = [];\n    for (let row = rect.top; row < rect.bottom; row++) {\n      const rowContent = [];\n      for (let index = row * map.width + rect.left, col = rect.left; col < rect.right; col++, index++) {\n        const pos = map.map[index];\n        if (seen[pos])\n          continue;\n        seen[pos] = true;\n        const cellRect = map.findCell(pos);\n        let cell = table.nodeAt(pos);\n        if (!cell) {\n          throw RangeError(`No cell with offset ${pos} found`);\n        }\n        const extraLeft = rect.left - cellRect.left;\n        const extraRight = cellRect.right - rect.right;\n        if (extraLeft > 0 || extraRight > 0) {\n          let attrs = cell.attrs;\n          if (extraLeft > 0) {\n            attrs = removeColSpan(attrs, 0, extraLeft);\n          }\n          if (extraRight > 0) {\n            attrs = removeColSpan(\n              attrs,\n              attrs.colspan - extraRight,\n              extraRight\n            );\n          }\n          if (cellRect.left < rect.left) {\n            cell = cell.type.createAndFill(attrs);\n            if (!cell) {\n              throw RangeError(\n                `Could not create cell with attrs ${JSON.stringify(attrs)}`\n              );\n            }\n          } else {\n            cell = cell.type.create(attrs, cell.content);\n          }\n        }\n        if (cellRect.top < rect.top || cellRect.bottom > rect.bottom) {\n          const attrs = {\n            ...cell.attrs,\n            rowspan: Math.min(cellRect.bottom, rect.bottom) - Math.max(cellRect.top, rect.top)\n          };\n          if (cellRect.top < rect.top) {\n            cell = cell.type.createAndFill(attrs);\n          } else {\n            cell = cell.type.create(attrs, cell.content);\n          }\n        }\n        rowContent.push(cell);\n      }\n      rows.push(table.child(row).copy(Fragment.from(rowContent)));\n    }\n    const fragment = this.isColSelection() && this.isRowSelection() ? table : rows;\n    return new Slice(Fragment.from(fragment), 1, 1);\n  }\n  replace(tr, content = Slice.empty) {\n    const mapFrom = tr.steps.length, ranges = this.ranges;\n    for (let i = 0; i < ranges.length; i++) {\n      const { $from, $to } = ranges[i], mapping = tr.mapping.slice(mapFrom);\n      tr.replace(\n        mapping.map($from.pos),\n        mapping.map($to.pos),\n        i ? Slice.empty : content\n      );\n    }\n    const sel = Selection.findFrom(\n      tr.doc.resolve(tr.mapping.slice(mapFrom).map(this.to)),\n      -1\n    );\n    if (sel)\n      tr.setSelection(sel);\n  }\n  replaceWith(tr, node) {\n    this.replace(tr, new Slice(Fragment.from(node), 0, 0));\n  }\n  forEachCell(f) {\n    const table = this.$anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = this.$anchorCell.start(-1);\n    const cells = map.cellsInRect(\n      map.rectBetween(\n        this.$anchorCell.pos - tableStart,\n        this.$headCell.pos - tableStart\n      )\n    );\n    for (let i = 0; i < cells.length; i++) {\n      f(table.nodeAt(cells[i]), tableStart + cells[i]);\n    }\n  }\n  isColSelection() {\n    const anchorTop = this.$anchorCell.index(-1);\n    const headTop = this.$headCell.index(-1);\n    if (Math.min(anchorTop, headTop) > 0)\n      return false;\n    const anchorBottom = anchorTop + this.$anchorCell.nodeAfter.attrs.rowspan;\n    const headBottom = headTop + this.$headCell.nodeAfter.attrs.rowspan;\n    return Math.max(anchorBottom, headBottom) == this.$headCell.node(-1).childCount;\n  }\n  static colSelection($anchorCell, $headCell = $anchorCell) {\n    const table = $anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = $anchorCell.start(-1);\n    const anchorRect = map.findCell($anchorCell.pos - tableStart);\n    const headRect = map.findCell($headCell.pos - tableStart);\n    const doc = $anchorCell.node(0);\n    if (anchorRect.top <= headRect.top) {\n      if (anchorRect.top > 0)\n        $anchorCell = doc.resolve(tableStart + map.map[anchorRect.left]);\n      if (headRect.bottom < map.height)\n        $headCell = doc.resolve(\n          tableStart + map.map[map.width * (map.height - 1) + headRect.right - 1]\n        );\n    } else {\n      if (headRect.top > 0)\n        $headCell = doc.resolve(tableStart + map.map[headRect.left]);\n      if (anchorRect.bottom < map.height)\n        $anchorCell = doc.resolve(\n          tableStart + map.map[map.width * (map.height - 1) + anchorRect.right - 1]\n        );\n    }\n    return new CellSelection($anchorCell, $headCell);\n  }\n  isRowSelection() {\n    const table = this.$anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = this.$anchorCell.start(-1);\n    const anchorLeft = map.colCount(this.$anchorCell.pos - tableStart);\n    const headLeft = map.colCount(this.$headCell.pos - tableStart);\n    if (Math.min(anchorLeft, headLeft) > 0)\n      return false;\n    const anchorRight = anchorLeft + this.$anchorCell.nodeAfter.attrs.colspan;\n    const headRight = headLeft + this.$headCell.nodeAfter.attrs.colspan;\n    return Math.max(anchorRight, headRight) == map.width;\n  }\n  eq(other) {\n    return other instanceof CellSelection && other.$anchorCell.pos == this.$anchorCell.pos && other.$headCell.pos == this.$headCell.pos;\n  }\n  static rowSelection($anchorCell, $headCell = $anchorCell) {\n    const table = $anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = $anchorCell.start(-1);\n    const anchorRect = map.findCell($anchorCell.pos - tableStart);\n    const headRect = map.findCell($headCell.pos - tableStart);\n    const doc = $anchorCell.node(0);\n    if (anchorRect.left <= headRect.left) {\n      if (anchorRect.left > 0)\n        $anchorCell = doc.resolve(\n          tableStart + map.map[anchorRect.top * map.width]\n        );\n      if (headRect.right < map.width)\n        $headCell = doc.resolve(\n          tableStart + map.map[map.width * (headRect.top + 1) - 1]\n        );\n    } else {\n      if (headRect.left > 0)\n        $headCell = doc.resolve(tableStart + map.map[headRect.top * map.width]);\n      if (anchorRect.right < map.width)\n        $anchorCell = doc.resolve(\n          tableStart + map.map[map.width * (anchorRect.top + 1) - 1]\n        );\n    }\n    return new CellSelection($anchorCell, $headCell);\n  }\n  toJSON() {\n    return {\n      type: \"cell\",\n      anchor: this.$anchorCell.pos,\n      head: this.$headCell.pos\n    };\n  }\n  static fromJSON(doc, json) {\n    return new CellSelection(doc.resolve(json.anchor), doc.resolve(json.head));\n  }\n  static create(doc, anchorCell, headCell = anchorCell) {\n    return new CellSelection(doc.resolve(anchorCell), doc.resolve(headCell));\n  }\n  getBookmark() {\n    return new CellBookmark(this.$anchorCell.pos, this.$headCell.pos);\n  }\n};\nCellSelection.prototype.visible = false;\nSelection.jsonID(\"cell\", CellSelection);\nvar CellBookmark = class {\n  constructor(anchor, head) {\n    this.anchor = anchor;\n    this.head = head;\n  }\n  map(mapping) {\n    return new CellBookmark(mapping.map(this.anchor), mapping.map(this.head));\n  }\n  resolve(doc) {\n    const $anchorCell = doc.resolve(this.anchor), $headCell = doc.resolve(this.head);\n    if ($anchorCell.parent.type.spec.tableRole == \"row\" && $headCell.parent.type.spec.tableRole == \"row\" && $anchorCell.index() < $anchorCell.parent.childCount && $headCell.index() < $headCell.parent.childCount && inSameTable($anchorCell, $headCell))\n      return new CellSelection($anchorCell, $headCell);\n    else\n      return Selection.near($headCell, 1);\n  }\n};\nfunction drawCellSelection(state) {\n  if (!(state.selection instanceof CellSelection))\n    return null;\n  const cells = [];\n  state.selection.forEachCell((node, pos) => {\n    cells.push(\n      Decoration.node(pos, pos + node.nodeSize, { class: \"selectedCell\" })\n    );\n  });\n  return DecorationSet.create(state.doc, cells);\n}\nfunction isCellBoundarySelection({ $from, $to }) {\n  if ($from.pos == $to.pos || $from.pos < $from.pos - 6)\n    return false;\n  let afterFrom = $from.pos;\n  let beforeTo = $to.pos;\n  let depth = $from.depth;\n  for (; depth >= 0; depth--, afterFrom++)\n    if ($from.after(depth + 1) < $from.end(depth))\n      break;\n  for (let d = $to.depth; d >= 0; d--, beforeTo--)\n    if ($to.before(d + 1) > $to.start(d))\n      break;\n  return afterFrom == beforeTo && /row|table/.test($from.node(depth).type.spec.tableRole);\n}\nfunction isTextSelectionAcrossCells({ $from, $to }) {\n  let fromCellBoundaryNode;\n  let toCellBoundaryNode;\n  for (let i = $from.depth; i > 0; i--) {\n    const node = $from.node(i);\n    if (node.type.spec.tableRole === \"cell\" || node.type.spec.tableRole === \"header_cell\") {\n      fromCellBoundaryNode = node;\n      break;\n    }\n  }\n  for (let i = $to.depth; i > 0; i--) {\n    const node = $to.node(i);\n    if (node.type.spec.tableRole === \"cell\" || node.type.spec.tableRole === \"header_cell\") {\n      toCellBoundaryNode = node;\n      break;\n    }\n  }\n  return fromCellBoundaryNode !== toCellBoundaryNode && $to.parentOffset === 0;\n}\nfunction normalizeSelection(state, tr, allowTableNodeSelection) {\n  const sel = (tr || state).selection;\n  const doc = (tr || state).doc;\n  let normalize;\n  let role;\n  if (sel instanceof NodeSelection2 && (role = sel.node.type.spec.tableRole)) {\n    if (role == \"cell\" || role == \"header_cell\") {\n      normalize = CellSelection.create(doc, sel.from);\n    } else if (role == \"row\") {\n      const $cell = doc.resolve(sel.from + 1);\n      normalize = CellSelection.rowSelection($cell, $cell);\n    } else if (!allowTableNodeSelection) {\n      const map = TableMap.get(sel.node);\n      const start = sel.from + 1;\n      const lastCell = start + map.map[map.width * map.height - 1];\n      normalize = CellSelection.create(doc, start + 1, lastCell);\n    }\n  } else if (sel instanceof TextSelection && isCellBoundarySelection(sel)) {\n    normalize = TextSelection.create(doc, sel.from);\n  } else if (sel instanceof TextSelection && isTextSelectionAcrossCells(sel)) {\n    normalize = TextSelection.create(doc, sel.$from.start(), sel.$from.end());\n  }\n  if (normalize)\n    (tr || (tr = state.tr)).setSelection(normalize);\n  return tr;\n}\n\n// src/fixtables.ts\nimport { PluginKey as PluginKey2 } from \"prosemirror-state\";\nvar fixTablesKey = new PluginKey2(\"fix-tables\");\nfunction changedDescendants(old, cur, offset, f) {\n  const oldSize = old.childCount, curSize = cur.childCount;\n  outer:\n    for (let i = 0, j = 0; i < curSize; i++) {\n      const child = cur.child(i);\n      for (let scan = j, e = Math.min(oldSize, i + 3); scan < e; scan++) {\n        if (old.child(scan) == child) {\n          j = scan + 1;\n          offset += child.nodeSize;\n          continue outer;\n        }\n      }\n      f(child, offset);\n      if (j < oldSize && old.child(j).sameMarkup(child))\n        changedDescendants(old.child(j), child, offset + 1, f);\n      else\n        child.nodesBetween(0, child.content.size, f, offset + 1);\n      offset += child.nodeSize;\n    }\n}\nfunction fixTables(state, oldState) {\n  let tr;\n  const check = (node, pos) => {\n    if (node.type.spec.tableRole == \"table\")\n      tr = fixTable(state, node, pos, tr);\n  };\n  if (!oldState)\n    state.doc.descendants(check);\n  else if (oldState.doc != state.doc)\n    changedDescendants(oldState.doc, state.doc, 0, check);\n  return tr;\n}\nfunction fixTable(state, table, tablePos, tr) {\n  const map = TableMap.get(table);\n  if (!map.problems)\n    return tr;\n  if (!tr)\n    tr = state.tr;\n  const mustAdd = [];\n  for (let i = 0; i < map.height; i++)\n    mustAdd.push(0);\n  for (let i = 0; i < map.problems.length; i++) {\n    const prob = map.problems[i];\n    if (prob.type == \"collision\") {\n      const cell = table.nodeAt(prob.pos);\n      if (!cell)\n        continue;\n      const attrs = cell.attrs;\n      for (let j = 0; j < attrs.rowspan; j++)\n        mustAdd[prob.row + j] += prob.n;\n      tr.setNodeMarkup(\n        tr.mapping.map(tablePos + 1 + prob.pos),\n        null,\n        removeColSpan(attrs, attrs.colspan - prob.n, prob.n)\n      );\n    } else if (prob.type == \"missing\") {\n      mustAdd[prob.row] += prob.n;\n    } else if (prob.type == \"overlong_rowspan\") {\n      const cell = table.nodeAt(prob.pos);\n      if (!cell)\n        continue;\n      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, {\n        ...cell.attrs,\n        rowspan: cell.attrs.rowspan - prob.n\n      });\n    } else if (prob.type == \"colwidth mismatch\") {\n      const cell = table.nodeAt(prob.pos);\n      if (!cell)\n        continue;\n      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, {\n        ...cell.attrs,\n        colwidth: prob.colwidth\n      });\n    }\n  }\n  let first, last;\n  for (let i = 0; i < mustAdd.length; i++)\n    if (mustAdd[i]) {\n      if (first == null)\n        first = i;\n      last = i;\n    }\n  for (let i = 0, pos = tablePos + 1; i < map.height; i++) {\n    const row = table.child(i);\n    const end = pos + row.nodeSize;\n    const add = mustAdd[i];\n    if (add > 0) {\n      let role = \"cell\";\n      if (row.firstChild) {\n        role = row.firstChild.type.spec.tableRole;\n      }\n      const nodes = [];\n      for (let j = 0; j < add; j++) {\n        const node = tableNodeTypes(state.schema)[role].createAndFill();\n        if (node)\n          nodes.push(node);\n      }\n      const side = (i == 0 || first == i - 1) && last == i ? pos + 1 : end - 1;\n      tr.insert(tr.mapping.map(side), nodes);\n    }\n    pos = end;\n  }\n  return tr.setMeta(fixTablesKey, { fixTables: true });\n}\n\n// src/input.ts\nimport { Fragment as Fragment3, Slice as Slice3 } from \"prosemirror-model\";\nimport {\n  Selection as Selection2,\n  TextSelection as TextSelection2\n} from \"prosemirror-state\";\nimport { keydownHandler } from \"prosemirror-keymap\";\n\n// src/copypaste.ts\nimport { Fragment as Fragment2, Slice as Slice2 } from \"prosemirror-model\";\nimport { Transform } from \"prosemirror-transform\";\nfunction pastedCells(slice) {\n  if (!slice.size)\n    return null;\n  let { content, openStart, openEnd } = slice;\n  while (content.childCount == 1 && (openStart > 0 && openEnd > 0 || content.child(0).type.spec.tableRole == \"table\")) {\n    openStart--;\n    openEnd--;\n    content = content.child(0).content;\n  }\n  const first = content.child(0);\n  const role = first.type.spec.tableRole;\n  const schema = first.type.schema, rows = [];\n  if (role == \"row\") {\n    for (let i = 0; i < content.childCount; i++) {\n      let cells = content.child(i).content;\n      const left = i ? 0 : Math.max(0, openStart - 1);\n      const right = i < content.childCount - 1 ? 0 : Math.max(0, openEnd - 1);\n      if (left || right)\n        cells = fitSlice(\n          tableNodeTypes(schema).row,\n          new Slice2(cells, left, right)\n        ).content;\n      rows.push(cells);\n    }\n  } else if (role == \"cell\" || role == \"header_cell\") {\n    rows.push(\n      openStart || openEnd ? fitSlice(\n        tableNodeTypes(schema).row,\n        new Slice2(content, openStart, openEnd)\n      ).content : content\n    );\n  } else {\n    return null;\n  }\n  return ensureRectangular(schema, rows);\n}\nfunction ensureRectangular(schema, rows) {\n  const widths = [];\n  for (let i = 0; i < rows.length; i++) {\n    const row = rows[i];\n    for (let j = row.childCount - 1; j >= 0; j--) {\n      const { rowspan, colspan } = row.child(j).attrs;\n      for (let r = i; r < i + rowspan; r++)\n        widths[r] = (widths[r] || 0) + colspan;\n    }\n  }\n  let width = 0;\n  for (let r = 0; r < widths.length; r++)\n    width = Math.max(width, widths[r]);\n  for (let r = 0; r < widths.length; r++) {\n    if (r >= rows.length)\n      rows.push(Fragment2.empty);\n    if (widths[r] < width) {\n      const empty = tableNodeTypes(schema).cell.createAndFill();\n      const cells = [];\n      for (let i = widths[r]; i < width; i++) {\n        cells.push(empty);\n      }\n      rows[r] = rows[r].append(Fragment2.from(cells));\n    }\n  }\n  return { height: rows.length, width, rows };\n}\nfunction fitSlice(nodeType, slice) {\n  const node = nodeType.createAndFill();\n  const tr = new Transform(node).replace(0, node.content.size, slice);\n  return tr.doc;\n}\nfunction clipCells({ width, height, rows }, newWidth, newHeight) {\n  if (width != newWidth) {\n    const added = [];\n    const newRows = [];\n    for (let row = 0; row < rows.length; row++) {\n      const frag = rows[row], cells = [];\n      for (let col = added[row] || 0, i = 0; col < newWidth; i++) {\n        let cell = frag.child(i % frag.childCount);\n        if (col + cell.attrs.colspan > newWidth)\n          cell = cell.type.createChecked(\n            removeColSpan(\n              cell.attrs,\n              cell.attrs.colspan,\n              col + cell.attrs.colspan - newWidth\n            ),\n            cell.content\n          );\n        cells.push(cell);\n        col += cell.attrs.colspan;\n        for (let j = 1; j < cell.attrs.rowspan; j++)\n          added[row + j] = (added[row + j] || 0) + cell.attrs.colspan;\n      }\n      newRows.push(Fragment2.from(cells));\n    }\n    rows = newRows;\n    width = newWidth;\n  }\n  if (height != newHeight) {\n    const newRows = [];\n    for (let row = 0, i = 0; row < newHeight; row++, i++) {\n      const cells = [], source = rows[i % height];\n      for (let j = 0; j < source.childCount; j++) {\n        let cell = source.child(j);\n        if (row + cell.attrs.rowspan > newHeight)\n          cell = cell.type.create(\n            {\n              ...cell.attrs,\n              rowspan: Math.max(1, newHeight - cell.attrs.rowspan)\n            },\n            cell.content\n          );\n        cells.push(cell);\n      }\n      newRows.push(Fragment2.from(cells));\n    }\n    rows = newRows;\n    height = newHeight;\n  }\n  return { width, height, rows };\n}\nfunction growTable(tr, map, table, start, width, height, mapFrom) {\n  const schema = tr.doc.type.schema;\n  const types = tableNodeTypes(schema);\n  let empty;\n  let emptyHead;\n  if (width > map.width) {\n    for (let row = 0, rowEnd = 0; row < map.height; row++) {\n      const rowNode = table.child(row);\n      rowEnd += rowNode.nodeSize;\n      const cells = [];\n      let add;\n      if (rowNode.lastChild == null || rowNode.lastChild.type == types.cell)\n        add = empty || (empty = types.cell.createAndFill());\n      else\n        add = emptyHead || (emptyHead = types.header_cell.createAndFill());\n      for (let i = map.width; i < width; i++)\n        cells.push(add);\n      tr.insert(tr.mapping.slice(mapFrom).map(rowEnd - 1 + start), cells);\n    }\n  }\n  if (height > map.height) {\n    const cells = [];\n    for (let i = 0, start2 = (map.height - 1) * map.width; i < Math.max(map.width, width); i++) {\n      const header = i >= map.width ? false : table.nodeAt(map.map[start2 + i]).type == types.header_cell;\n      cells.push(\n        header ? emptyHead || (emptyHead = types.header_cell.createAndFill()) : empty || (empty = types.cell.createAndFill())\n      );\n    }\n    const emptyRow = types.row.create(null, Fragment2.from(cells)), rows = [];\n    for (let i = map.height; i < height; i++)\n      rows.push(emptyRow);\n    tr.insert(tr.mapping.slice(mapFrom).map(start + table.nodeSize - 2), rows);\n  }\n  return !!(empty || emptyHead);\n}\nfunction isolateHorizontal(tr, map, table, start, left, right, top, mapFrom) {\n  if (top == 0 || top == map.height)\n    return false;\n  let found = false;\n  for (let col = left; col < right; col++) {\n    const index = top * map.width + col, pos = map.map[index];\n    if (map.map[index - map.width] == pos) {\n      found = true;\n      const cell = table.nodeAt(pos);\n      const { top: cellTop, left: cellLeft } = map.findCell(pos);\n      tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + start), null, {\n        ...cell.attrs,\n        rowspan: top - cellTop\n      });\n      tr.insert(\n        tr.mapping.slice(mapFrom).map(map.positionAt(top, cellLeft, table)),\n        cell.type.createAndFill({\n          ...cell.attrs,\n          rowspan: cellTop + cell.attrs.rowspan - top\n        })\n      );\n      col += cell.attrs.colspan - 1;\n    }\n  }\n  return found;\n}\nfunction isolateVertical(tr, map, table, start, top, bottom, left, mapFrom) {\n  if (left == 0 || left == map.width)\n    return false;\n  let found = false;\n  for (let row = top; row < bottom; row++) {\n    const index = row * map.width + left, pos = map.map[index];\n    if (map.map[index - 1] == pos) {\n      found = true;\n      const cell = table.nodeAt(pos);\n      const cellLeft = map.colCount(pos);\n      const updatePos = tr.mapping.slice(mapFrom).map(pos + start);\n      tr.setNodeMarkup(\n        updatePos,\n        null,\n        removeColSpan(\n          cell.attrs,\n          left - cellLeft,\n          cell.attrs.colspan - (left - cellLeft)\n        )\n      );\n      tr.insert(\n        updatePos + cell.nodeSize,\n        cell.type.createAndFill(\n          removeColSpan(cell.attrs, 0, left - cellLeft)\n        )\n      );\n      row += cell.attrs.rowspan - 1;\n    }\n  }\n  return found;\n}\nfunction insertCells(state, dispatch, tableStart, rect, cells) {\n  let table = tableStart ? state.doc.nodeAt(tableStart - 1) : state.doc;\n  if (!table) {\n    throw new Error(\"No table found\");\n  }\n  let map = TableMap.get(table);\n  const { top, left } = rect;\n  const right = left + cells.width, bottom = top + cells.height;\n  const tr = state.tr;\n  let mapFrom = 0;\n  function recomp() {\n    table = tableStart ? tr.doc.nodeAt(tableStart - 1) : tr.doc;\n    if (!table) {\n      throw new Error(\"No table found\");\n    }\n    map = TableMap.get(table);\n    mapFrom = tr.mapping.maps.length;\n  }\n  if (growTable(tr, map, table, tableStart, right, bottom, mapFrom))\n    recomp();\n  if (isolateHorizontal(tr, map, table, tableStart, left, right, top, mapFrom))\n    recomp();\n  if (isolateHorizontal(tr, map, table, tableStart, left, right, bottom, mapFrom))\n    recomp();\n  if (isolateVertical(tr, map, table, tableStart, top, bottom, left, mapFrom))\n    recomp();\n  if (isolateVertical(tr, map, table, tableStart, top, bottom, right, mapFrom))\n    recomp();\n  for (let row = top; row < bottom; row++) {\n    const from = map.positionAt(row, left, table), to = map.positionAt(row, right, table);\n    tr.replace(\n      tr.mapping.slice(mapFrom).map(from + tableStart),\n      tr.mapping.slice(mapFrom).map(to + tableStart),\n      new Slice2(cells.rows[row - top], 0, 0)\n    );\n  }\n  recomp();\n  tr.setSelection(\n    new CellSelection(\n      tr.doc.resolve(tableStart + map.positionAt(top, left, table)),\n      tr.doc.resolve(tableStart + map.positionAt(bottom - 1, right - 1, table))\n    )\n  );\n  dispatch(tr);\n}\n\n// src/input.ts\nvar handleKeyDown = keydownHandler({\n  ArrowLeft: arrow(\"horiz\", -1),\n  ArrowRight: arrow(\"horiz\", 1),\n  ArrowUp: arrow(\"vert\", -1),\n  ArrowDown: arrow(\"vert\", 1),\n  \"Shift-ArrowLeft\": shiftArrow(\"horiz\", -1),\n  \"Shift-ArrowRight\": shiftArrow(\"horiz\", 1),\n  \"Shift-ArrowUp\": shiftArrow(\"vert\", -1),\n  \"Shift-ArrowDown\": shiftArrow(\"vert\", 1),\n  Backspace: deleteCellSelection,\n  \"Mod-Backspace\": deleteCellSelection,\n  Delete: deleteCellSelection,\n  \"Mod-Delete\": deleteCellSelection\n});\nfunction maybeSetSelection(state, dispatch, selection) {\n  if (selection.eq(state.selection))\n    return false;\n  if (dispatch)\n    dispatch(state.tr.setSelection(selection).scrollIntoView());\n  return true;\n}\nfunction arrow(axis, dir) {\n  return (state, dispatch, view) => {\n    if (!view)\n      return false;\n    const sel = state.selection;\n    if (sel instanceof CellSelection) {\n      return maybeSetSelection(\n        state,\n        dispatch,\n        Selection2.near(sel.$headCell, dir)\n      );\n    }\n    if (axis != \"horiz\" && !sel.empty)\n      return false;\n    const end = atEndOfCell(view, axis, dir);\n    if (end == null)\n      return false;\n    if (axis == \"horiz\") {\n      return maybeSetSelection(\n        state,\n        dispatch,\n        Selection2.near(state.doc.resolve(sel.head + dir), dir)\n      );\n    } else {\n      const $cell = state.doc.resolve(end);\n      const $next = nextCell($cell, axis, dir);\n      let newSel;\n      if ($next)\n        newSel = Selection2.near($next, 1);\n      else if (dir < 0)\n        newSel = Selection2.near(state.doc.resolve($cell.before(-1)), -1);\n      else\n        newSel = Selection2.near(state.doc.resolve($cell.after(-1)), 1);\n      return maybeSetSelection(state, dispatch, newSel);\n    }\n  };\n}\nfunction shiftArrow(axis, dir) {\n  return (state, dispatch, view) => {\n    if (!view)\n      return false;\n    const sel = state.selection;\n    let cellSel;\n    if (sel instanceof CellSelection) {\n      cellSel = sel;\n    } else {\n      const end = atEndOfCell(view, axis, dir);\n      if (end == null)\n        return false;\n      cellSel = new CellSelection(state.doc.resolve(end));\n    }\n    const $head = nextCell(cellSel.$headCell, axis, dir);\n    if (!$head)\n      return false;\n    return maybeSetSelection(\n      state,\n      dispatch,\n      new CellSelection(cellSel.$anchorCell, $head)\n    );\n  };\n}\nfunction deleteCellSelection(state, dispatch) {\n  const sel = state.selection;\n  if (!(sel instanceof CellSelection))\n    return false;\n  if (dispatch) {\n    const tr = state.tr;\n    const baseContent = tableNodeTypes(state.schema).cell.createAndFill().content;\n    sel.forEachCell((cell, pos) => {\n      if (!cell.content.eq(baseContent))\n        tr.replace(\n          tr.mapping.map(pos + 1),\n          tr.mapping.map(pos + cell.nodeSize - 1),\n          new Slice3(baseContent, 0, 0)\n        );\n    });\n    if (tr.docChanged)\n      dispatch(tr);\n  }\n  return true;\n}\nfunction handleTripleClick(view, pos) {\n  const doc = view.state.doc, $cell = cellAround(doc.resolve(pos));\n  if (!$cell)\n    return false;\n  view.dispatch(view.state.tr.setSelection(new CellSelection($cell)));\n  return true;\n}\nfunction handlePaste(view, _, slice) {\n  if (!isInTable(view.state))\n    return false;\n  let cells = pastedCells(slice);\n  const sel = view.state.selection;\n  if (sel instanceof CellSelection) {\n    if (!cells)\n      cells = {\n        width: 1,\n        height: 1,\n        rows: [\n          Fragment3.from(\n            fitSlice(tableNodeTypes(view.state.schema).cell, slice)\n          )\n        ]\n      };\n    const table = sel.$anchorCell.node(-1);\n    const start = sel.$anchorCell.start(-1);\n    const rect = TableMap.get(table).rectBetween(\n      sel.$anchorCell.pos - start,\n      sel.$headCell.pos - start\n    );\n    cells = clipCells(cells, rect.right - rect.left, rect.bottom - rect.top);\n    insertCells(view.state, view.dispatch, start, rect, cells);\n    return true;\n  } else if (cells) {\n    const $cell = selectionCell(view.state);\n    const start = $cell.start(-1);\n    insertCells(\n      view.state,\n      view.dispatch,\n      start,\n      TableMap.get($cell.node(-1)).findCell($cell.pos - start),\n      cells\n    );\n    return true;\n  } else {\n    return false;\n  }\n}\nfunction handleMouseDown(view, startEvent) {\n  var _a;\n  if (startEvent.ctrlKey || startEvent.metaKey)\n    return;\n  const startDOMCell = domInCell(view, startEvent.target);\n  let $anchor;\n  if (startEvent.shiftKey && view.state.selection instanceof CellSelection) {\n    setCellSelection(view.state.selection.$anchorCell, startEvent);\n    startEvent.preventDefault();\n  } else if (startEvent.shiftKey && startDOMCell && ($anchor = cellAround(view.state.selection.$anchor)) != null && ((_a = cellUnderMouse(view, startEvent)) == null ? void 0 : _a.pos) != $anchor.pos) {\n    setCellSelection($anchor, startEvent);\n    startEvent.preventDefault();\n  } else if (!startDOMCell) {\n    return;\n  }\n  function setCellSelection($anchor2, event) {\n    let $head = cellUnderMouse(view, event);\n    const starting = tableEditingKey.getState(view.state) == null;\n    if (!$head || !inSameTable($anchor2, $head)) {\n      if (starting)\n        $head = $anchor2;\n      else\n        return;\n    }\n    const selection = new CellSelection($anchor2, $head);\n    if (starting || !view.state.selection.eq(selection)) {\n      const tr = view.state.tr.setSelection(selection);\n      if (starting)\n        tr.setMeta(tableEditingKey, $anchor2.pos);\n      view.dispatch(tr);\n    }\n  }\n  function stop() {\n    view.root.removeEventListener(\"mouseup\", stop);\n    view.root.removeEventListener(\"dragstart\", stop);\n    view.root.removeEventListener(\"mousemove\", move);\n    if (tableEditingKey.getState(view.state) != null)\n      view.dispatch(view.state.tr.setMeta(tableEditingKey, -1));\n  }\n  function move(_event) {\n    const event = _event;\n    const anchor = tableEditingKey.getState(view.state);\n    let $anchor2;\n    if (anchor != null) {\n      $anchor2 = view.state.doc.resolve(anchor);\n    } else if (domInCell(view, event.target) != startDOMCell) {\n      $anchor2 = cellUnderMouse(view, startEvent);\n      if (!$anchor2)\n        return stop();\n    }\n    if ($anchor2)\n      setCellSelection($anchor2, event);\n  }\n  view.root.addEventListener(\"mouseup\", stop);\n  view.root.addEventListener(\"dragstart\", stop);\n  view.root.addEventListener(\"mousemove\", move);\n}\nfunction atEndOfCell(view, axis, dir) {\n  if (!(view.state.selection instanceof TextSelection2))\n    return null;\n  const { $head } = view.state.selection;\n  for (let d = $head.depth - 1; d >= 0; d--) {\n    const parent = $head.node(d), index = dir < 0 ? $head.index(d) : $head.indexAfter(d);\n    if (index != (dir < 0 ? 0 : parent.childCount))\n      return null;\n    if (parent.type.spec.tableRole == \"cell\" || parent.type.spec.tableRole == \"header_cell\") {\n      const cellPos = $head.before(d);\n      const dirStr = axis == \"vert\" ? dir > 0 ? \"down\" : \"up\" : dir > 0 ? \"right\" : \"left\";\n      return view.endOfTextblock(dirStr) ? cellPos : null;\n    }\n  }\n  return null;\n}\nfunction domInCell(view, dom) {\n  for (; dom && dom != view.dom; dom = dom.parentNode) {\n    if (dom.nodeName == \"TD\" || dom.nodeName == \"TH\") {\n      return dom;\n    }\n  }\n  return null;\n}\nfunction cellUnderMouse(view, event) {\n  const mousePos = view.posAtCoords({\n    left: event.clientX,\n    top: event.clientY\n  });\n  if (!mousePos)\n    return null;\n  return mousePos ? cellAround(view.state.doc.resolve(mousePos.pos)) : null;\n}\n\n// src/columnresizing.ts\nimport { Plugin, PluginKey as PluginKey3 } from \"prosemirror-state\";\nimport {\n  Decoration as Decoration2,\n  DecorationSet as DecorationSet2\n} from \"prosemirror-view\";\n\n// src/tableview.ts\nvar TableView = class {\n  constructor(node, cellMinWidth) {\n    this.node = node;\n    this.cellMinWidth = cellMinWidth;\n    this.dom = document.createElement(\"div\");\n    this.dom.className = \"tableWrapper\";\n    this.table = this.dom.appendChild(document.createElement(\"table\"));\n    this.colgroup = this.table.appendChild(document.createElement(\"colgroup\"));\n    updateColumnsOnResize(node, this.colgroup, this.table, cellMinWidth);\n    this.contentDOM = this.table.appendChild(document.createElement(\"tbody\"));\n  }\n  update(node) {\n    if (node.type != this.node.type)\n      return false;\n    this.node = node;\n    updateColumnsOnResize(node, this.colgroup, this.table, this.cellMinWidth);\n    return true;\n  }\n  ignoreMutation(record) {\n    return record.type == \"attributes\" && (record.target == this.table || this.colgroup.contains(record.target));\n  }\n};\nfunction updateColumnsOnResize(node, colgroup, table, cellMinWidth, overrideCol, overrideValue) {\n  var _a;\n  let totalWidth = 0;\n  let fixedWidth = true;\n  let nextDOM = colgroup.firstChild;\n  const row = node.firstChild;\n  if (!row)\n    return;\n  for (let i = 0, col = 0; i < row.childCount; i++) {\n    const { colspan, colwidth } = row.child(i).attrs;\n    for (let j = 0; j < colspan; j++, col++) {\n      const hasWidth = overrideCol == col ? overrideValue : colwidth && colwidth[j];\n      const cssWidth = hasWidth ? hasWidth + \"px\" : \"\";\n      totalWidth += hasWidth || cellMinWidth;\n      if (!hasWidth)\n        fixedWidth = false;\n      if (!nextDOM) {\n        colgroup.appendChild(document.createElement(\"col\")).style.width = cssWidth;\n      } else {\n        if (nextDOM.style.width != cssWidth)\n          nextDOM.style.width = cssWidth;\n        nextDOM = nextDOM.nextSibling;\n      }\n    }\n  }\n  while (nextDOM) {\n    const after = nextDOM.nextSibling;\n    (_a = nextDOM.parentNode) == null ? void 0 : _a.removeChild(nextDOM);\n    nextDOM = after;\n  }\n  if (fixedWidth) {\n    table.style.width = totalWidth + \"px\";\n    table.style.minWidth = \"\";\n  } else {\n    table.style.width = \"\";\n    table.style.minWidth = totalWidth + \"px\";\n  }\n}\n\n// src/columnresizing.ts\nvar columnResizingPluginKey = new PluginKey3(\n  \"tableColumnResizing\"\n);\nfunction columnResizing({\n  handleWidth = 5,\n  cellMinWidth = 25,\n  View = TableView,\n  lastColumnResizable = true\n} = {}) {\n  const plugin = new Plugin({\n    key: columnResizingPluginKey,\n    state: {\n      init(_, state) {\n        plugin.spec.props.nodeViews[tableNodeTypes(state.schema).table.name] = (node, view) => new View(node, cellMinWidth, view);\n        return new ResizeState(-1, false);\n      },\n      apply(tr, prev) {\n        return prev.apply(tr);\n      }\n    },\n    props: {\n      attributes: (state) => {\n        const pluginState = columnResizingPluginKey.getState(state);\n        return pluginState && pluginState.activeHandle > -1 ? { class: \"resize-cursor\" } : {};\n      },\n      handleDOMEvents: {\n        mousemove: (view, event) => {\n          handleMouseMove(\n            view,\n            event,\n            handleWidth,\n            cellMinWidth,\n            lastColumnResizable\n          );\n        },\n        mouseleave: (view) => {\n          handleMouseLeave(view);\n        },\n        mousedown: (view, event) => {\n          handleMouseDown2(view, event, cellMinWidth);\n        }\n      },\n      decorations: (state) => {\n        const pluginState = columnResizingPluginKey.getState(state);\n        if (pluginState && pluginState.activeHandle > -1) {\n          return handleDecorations(state, pluginState.activeHandle);\n        }\n      },\n      nodeViews: {}\n    }\n  });\n  return plugin;\n}\nvar ResizeState = class {\n  constructor(activeHandle, dragging) {\n    this.activeHandle = activeHandle;\n    this.dragging = dragging;\n  }\n  apply(tr) {\n    const state = this;\n    const action = tr.getMeta(columnResizingPluginKey);\n    if (action && action.setHandle != null)\n      return new ResizeState(action.setHandle, false);\n    if (action && action.setDragging !== void 0)\n      return new ResizeState(state.activeHandle, action.setDragging);\n    if (state.activeHandle > -1 && tr.docChanged) {\n      let handle = tr.mapping.map(state.activeHandle, -1);\n      if (!pointsAtCell(tr.doc.resolve(handle))) {\n        handle = -1;\n      }\n      return new ResizeState(handle, state.dragging);\n    }\n    return state;\n  }\n};\nfunction handleMouseMove(view, event, handleWidth, cellMinWidth, lastColumnResizable) {\n  const pluginState = columnResizingPluginKey.getState(view.state);\n  if (!pluginState)\n    return;\n  if (!pluginState.dragging) {\n    const target = domCellAround(event.target);\n    let cell = -1;\n    if (target) {\n      const { left, right } = target.getBoundingClientRect();\n      if (event.clientX - left <= handleWidth)\n        cell = edgeCell(view, event, \"left\");\n      else if (right - event.clientX <= handleWidth)\n        cell = edgeCell(view, event, \"right\");\n    }\n    if (cell != pluginState.activeHandle) {\n      if (!lastColumnResizable && cell !== -1) {\n        const $cell = view.state.doc.resolve(cell);\n        const table = $cell.node(-1);\n        const map = TableMap.get(table);\n        const tableStart = $cell.start(-1);\n        const col = map.colCount($cell.pos - tableStart) + $cell.nodeAfter.attrs.colspan - 1;\n        if (col == map.width - 1) {\n          return;\n        }\n      }\n      updateHandle(view, cell);\n    }\n  }\n}\nfunction handleMouseLeave(view) {\n  const pluginState = columnResizingPluginKey.getState(view.state);\n  if (pluginState && pluginState.activeHandle > -1 && !pluginState.dragging)\n    updateHandle(view, -1);\n}\nfunction handleMouseDown2(view, event, cellMinWidth) {\n  const pluginState = columnResizingPluginKey.getState(view.state);\n  if (!pluginState || pluginState.activeHandle == -1 || pluginState.dragging)\n    return false;\n  const cell = view.state.doc.nodeAt(pluginState.activeHandle);\n  const width = currentColWidth(view, pluginState.activeHandle, cell.attrs);\n  view.dispatch(\n    view.state.tr.setMeta(columnResizingPluginKey, {\n      setDragging: { startX: event.clientX, startWidth: width }\n    })\n  );\n  function finish(event2) {\n    window.removeEventListener(\"mouseup\", finish);\n    window.removeEventListener(\"mousemove\", move);\n    const pluginState2 = columnResizingPluginKey.getState(view.state);\n    if (pluginState2 == null ? void 0 : pluginState2.dragging) {\n      updateColumnWidth(\n        view,\n        pluginState2.activeHandle,\n        draggedWidth(pluginState2.dragging, event2, cellMinWidth)\n      );\n      view.dispatch(\n        view.state.tr.setMeta(columnResizingPluginKey, { setDragging: null })\n      );\n    }\n  }\n  function move(event2) {\n    if (!event2.which)\n      return finish(event2);\n    const pluginState2 = columnResizingPluginKey.getState(view.state);\n    if (!pluginState2)\n      return;\n    if (pluginState2.dragging) {\n      const dragged = draggedWidth(pluginState2.dragging, event2, cellMinWidth);\n      displayColumnWidth(view, pluginState2.activeHandle, dragged, cellMinWidth);\n    }\n  }\n  window.addEventListener(\"mouseup\", finish);\n  window.addEventListener(\"mousemove\", move);\n  event.preventDefault();\n  return true;\n}\nfunction currentColWidth(view, cellPos, { colspan, colwidth }) {\n  const width = colwidth && colwidth[colwidth.length - 1];\n  if (width)\n    return width;\n  const dom = view.domAtPos(cellPos);\n  const node = dom.node.childNodes[dom.offset];\n  let domWidth = node.offsetWidth, parts = colspan;\n  if (colwidth) {\n    for (let i = 0; i < colspan; i++)\n      if (colwidth[i]) {\n        domWidth -= colwidth[i];\n        parts--;\n      }\n  }\n  return domWidth / parts;\n}\nfunction domCellAround(target) {\n  while (target && target.nodeName != \"TD\" && target.nodeName != \"TH\")\n    target = target.classList && target.classList.contains(\"ProseMirror\") ? null : target.parentNode;\n  return target;\n}\nfunction edgeCell(view, event, side) {\n  const found = view.posAtCoords({ left: event.clientX, top: event.clientY });\n  if (!found)\n    return -1;\n  const { pos } = found;\n  const $cell = cellAround(view.state.doc.resolve(pos));\n  if (!$cell)\n    return -1;\n  if (side == \"right\")\n    return $cell.pos;\n  const map = TableMap.get($cell.node(-1)), start = $cell.start(-1);\n  const index = map.map.indexOf($cell.pos - start);\n  return index % map.width == 0 ? -1 : start + map.map[index - 1];\n}\nfunction draggedWidth(dragging, event, cellMinWidth) {\n  const offset = event.clientX - dragging.startX;\n  return Math.max(cellMinWidth, dragging.startWidth + offset);\n}\nfunction updateHandle(view, value) {\n  view.dispatch(\n    view.state.tr.setMeta(columnResizingPluginKey, { setHandle: value })\n  );\n}\nfunction updateColumnWidth(view, cell, width) {\n  const $cell = view.state.doc.resolve(cell);\n  const table = $cell.node(-1), map = TableMap.get(table), start = $cell.start(-1);\n  const col = map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;\n  const tr = view.state.tr;\n  for (let row = 0; row < map.height; row++) {\n    const mapIndex = row * map.width + col;\n    if (row && map.map[mapIndex] == map.map[mapIndex - map.width])\n      continue;\n    const pos = map.map[mapIndex];\n    const attrs = table.nodeAt(pos).attrs;\n    const index = attrs.colspan == 1 ? 0 : col - map.colCount(pos);\n    if (attrs.colwidth && attrs.colwidth[index] == width)\n      continue;\n    const colwidth = attrs.colwidth ? attrs.colwidth.slice() : zeroes(attrs.colspan);\n    colwidth[index] = width;\n    tr.setNodeMarkup(start + pos, null, { ...attrs, colwidth });\n  }\n  if (tr.docChanged)\n    view.dispatch(tr);\n}\nfunction displayColumnWidth(view, cell, width, cellMinWidth) {\n  const $cell = view.state.doc.resolve(cell);\n  const table = $cell.node(-1), start = $cell.start(-1);\n  const col = TableMap.get(table).colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;\n  let dom = view.domAtPos($cell.start(-1)).node;\n  while (dom && dom.nodeName != \"TABLE\") {\n    dom = dom.parentNode;\n  }\n  if (!dom)\n    return;\n  updateColumnsOnResize(\n    table,\n    dom.firstChild,\n    dom,\n    cellMinWidth,\n    col,\n    width\n  );\n}\nfunction zeroes(n) {\n  return Array(n).fill(0);\n}\nfunction handleDecorations(state, cell) {\n  const decorations = [];\n  const $cell = state.doc.resolve(cell);\n  const table = $cell.node(-1);\n  if (!table) {\n    return DecorationSet2.empty;\n  }\n  const map = TableMap.get(table);\n  const start = $cell.start(-1);\n  const col = map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan;\n  for (let row = 0; row < map.height; row++) {\n    const index = col + row * map.width - 1;\n    if ((col == map.width || map.map[index] != map.map[index + 1]) && (row == 0 || map.map[index - 1] != map.map[index - 1 - map.width])) {\n      const cellPos = map.map[index];\n      const pos = start + cellPos + table.nodeAt(cellPos).nodeSize - 1;\n      const dom = document.createElement(\"div\");\n      dom.className = \"column-resize-handle\";\n      decorations.push(Decoration2.widget(pos, dom));\n    }\n  }\n  return DecorationSet2.create(state.doc, decorations);\n}\n\n// src/commands.ts\nimport { Fragment as Fragment4 } from \"prosemirror-model\";\nimport {\n  TextSelection as TextSelection3\n} from \"prosemirror-state\";\nfunction selectedRect(state) {\n  const sel = state.selection;\n  const $pos = selectionCell(state);\n  const table = $pos.node(-1);\n  const tableStart = $pos.start(-1);\n  const map = TableMap.get(table);\n  const rect = sel instanceof CellSelection ? map.rectBetween(\n    sel.$anchorCell.pos - tableStart,\n    sel.$headCell.pos - tableStart\n  ) : map.findCell($pos.pos - tableStart);\n  return { ...rect, tableStart, map, table };\n}\nfunction addColumn(tr, { map, tableStart, table }, col) {\n  let refColumn = col > 0 ? -1 : 0;\n  if (columnIsHeader(map, table, col + refColumn)) {\n    refColumn = col == 0 || col == map.width ? null : 0;\n  }\n  for (let row = 0; row < map.height; row++) {\n    const index = row * map.width + col;\n    if (col > 0 && col < map.width && map.map[index - 1] == map.map[index]) {\n      const pos = map.map[index];\n      const cell = table.nodeAt(pos);\n      tr.setNodeMarkup(\n        tr.mapping.map(tableStart + pos),\n        null,\n        addColSpan(cell.attrs, col - map.colCount(pos))\n      );\n      row += cell.attrs.rowspan - 1;\n    } else {\n      const type = refColumn == null ? tableNodeTypes(table.type.schema).cell : table.nodeAt(map.map[index + refColumn]).type;\n      const pos = map.positionAt(row, col, table);\n      tr.insert(tr.mapping.map(tableStart + pos), type.createAndFill());\n    }\n  }\n  return tr;\n}\nfunction addColumnBefore(state, dispatch) {\n  if (!isInTable(state))\n    return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    dispatch(addColumn(state.tr, rect, rect.left));\n  }\n  return true;\n}\nfunction addColumnAfter(state, dispatch) {\n  if (!isInTable(state))\n    return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    dispatch(addColumn(state.tr, rect, rect.right));\n  }\n  return true;\n}\nfunction removeColumn(tr, { map, table, tableStart }, col) {\n  const mapStart = tr.mapping.maps.length;\n  for (let row = 0; row < map.height; ) {\n    const index = row * map.width + col;\n    const pos = map.map[index];\n    const cell = table.nodeAt(pos);\n    const attrs = cell.attrs;\n    if (col > 0 && map.map[index - 1] == pos || col < map.width - 1 && map.map[index + 1] == pos) {\n      tr.setNodeMarkup(\n        tr.mapping.slice(mapStart).map(tableStart + pos),\n        null,\n        removeColSpan(attrs, col - map.colCount(pos))\n      );\n    } else {\n      const start = tr.mapping.slice(mapStart).map(tableStart + pos);\n      tr.delete(start, start + cell.nodeSize);\n    }\n    row += attrs.rowspan;\n  }\n}\nfunction deleteColumn(state, dispatch) {\n  if (!isInTable(state))\n    return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    const tr = state.tr;\n    if (rect.left == 0 && rect.right == rect.map.width)\n      return false;\n    for (let i = rect.right - 1; ; i--) {\n      removeColumn(tr, rect, i);\n      if (i == rect.left)\n        break;\n      const table = rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc;\n      if (!table) {\n        throw RangeError(\"No table found\");\n      }\n      rect.table = table;\n      rect.map = TableMap.get(table);\n    }\n    dispatch(tr);\n  }\n  return true;\n}\nfunction rowIsHeader(map, table, row) {\n  var _a;\n  const headerCell = tableNodeTypes(table.type.schema).header_cell;\n  for (let col = 0; col < map.width; col++)\n    if (((_a = table.nodeAt(map.map[col + row * map.width])) == null ? void 0 : _a.type) != headerCell)\n      return false;\n  return true;\n}\nfunction addRow(tr, { map, tableStart, table }, row) {\n  var _a;\n  let rowPos = tableStart;\n  for (let i = 0; i < row; i++)\n    rowPos += table.child(i).nodeSize;\n  const cells = [];\n  let refRow = row > 0 ? -1 : 0;\n  if (rowIsHeader(map, table, row + refRow))\n    refRow = row == 0 || row == map.height ? null : 0;\n  for (let col = 0, index = map.width * row; col < map.width; col++, index++) {\n    if (row > 0 && row < map.height && map.map[index] == map.map[index - map.width]) {\n      const pos = map.map[index];\n      const attrs = table.nodeAt(pos).attrs;\n      tr.setNodeMarkup(tableStart + pos, null, {\n        ...attrs,\n        rowspan: attrs.rowspan + 1\n      });\n      col += attrs.colspan - 1;\n    } else {\n      const type = refRow == null ? tableNodeTypes(table.type.schema).cell : (_a = table.nodeAt(map.map[index + refRow * map.width])) == null ? void 0 : _a.type;\n      const node = type == null ? void 0 : type.createAndFill();\n      if (node)\n        cells.push(node);\n    }\n  }\n  tr.insert(rowPos, tableNodeTypes(table.type.schema).row.create(null, cells));\n  return tr;\n}\nfunction addRowBefore(state, dispatch) {\n  if (!isInTable(state))\n    return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    dispatch(addRow(state.tr, rect, rect.top));\n  }\n  return true;\n}\nfunction addRowAfter(state, dispatch) {\n  if (!isInTable(state))\n    return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    dispatch(addRow(state.tr, rect, rect.bottom));\n  }\n  return true;\n}\nfunction removeRow(tr, { map, table, tableStart }, row) {\n  let rowPos = 0;\n  for (let i = 0; i < row; i++)\n    rowPos += table.child(i).nodeSize;\n  const nextRow = rowPos + table.child(row).nodeSize;\n  const mapFrom = tr.mapping.maps.length;\n  tr.delete(rowPos + tableStart, nextRow + tableStart);\n  for (let col = 0, index = row * map.width; col < map.width; col++, index++) {\n    const pos = map.map[index];\n    if (row > 0 && pos == map.map[index - map.width]) {\n      const attrs = table.nodeAt(pos).attrs;\n      tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + tableStart), null, {\n        ...attrs,\n        rowspan: attrs.rowspan - 1\n      });\n      col += attrs.colspan - 1;\n    } else if (row < map.width && pos == map.map[index + map.width]) {\n      const cell = table.nodeAt(pos);\n      const attrs = cell.attrs;\n      const copy = cell.type.create(\n        { ...attrs, rowspan: cell.attrs.rowspan - 1 },\n        cell.content\n      );\n      const newPos = map.positionAt(row + 1, col, table);\n      tr.insert(tr.mapping.slice(mapFrom).map(tableStart + newPos), copy);\n      col += attrs.colspan - 1;\n    }\n  }\n}\nfunction deleteRow(state, dispatch) {\n  if (!isInTable(state))\n    return false;\n  if (dispatch) {\n    const rect = selectedRect(state), tr = state.tr;\n    if (rect.top == 0 && rect.bottom == rect.map.height)\n      return false;\n    for (let i = rect.bottom - 1; ; i--) {\n      removeRow(tr, rect, i);\n      if (i == rect.top)\n        break;\n      const table = rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc;\n      if (!table) {\n        throw RangeError(\"No table found\");\n      }\n      rect.table = table;\n      rect.map = TableMap.get(rect.table);\n    }\n    dispatch(tr);\n  }\n  return true;\n}\nfunction isEmpty(cell) {\n  const c = cell.content;\n  return c.childCount == 1 && c.child(0).isTextblock && c.child(0).childCount == 0;\n}\nfunction cellsOverlapRectangle({ width, height, map }, rect) {\n  let indexTop = rect.top * width + rect.left, indexLeft = indexTop;\n  let indexBottom = (rect.bottom - 1) * width + rect.left, indexRight = indexTop + (rect.right - rect.left - 1);\n  for (let i = rect.top; i < rect.bottom; i++) {\n    if (rect.left > 0 && map[indexLeft] == map[indexLeft - 1] || rect.right < width && map[indexRight] == map[indexRight + 1])\n      return true;\n    indexLeft += width;\n    indexRight += width;\n  }\n  for (let i = rect.left; i < rect.right; i++) {\n    if (rect.top > 0 && map[indexTop] == map[indexTop - width] || rect.bottom < height && map[indexBottom] == map[indexBottom + width])\n      return true;\n    indexTop++;\n    indexBottom++;\n  }\n  return false;\n}\nfunction mergeCells(state, dispatch) {\n  const sel = state.selection;\n  if (!(sel instanceof CellSelection) || sel.$anchorCell.pos == sel.$headCell.pos)\n    return false;\n  const rect = selectedRect(state), { map } = rect;\n  if (cellsOverlapRectangle(map, rect))\n    return false;\n  if (dispatch) {\n    const tr = state.tr;\n    const seen = {};\n    let content = Fragment4.empty;\n    let mergedPos;\n    let mergedCell;\n    for (let row = rect.top; row < rect.bottom; row++) {\n      for (let col = rect.left; col < rect.right; col++) {\n        const cellPos = map.map[row * map.width + col];\n        const cell = rect.table.nodeAt(cellPos);\n        if (seen[cellPos] || !cell)\n          continue;\n        seen[cellPos] = true;\n        if (mergedPos == null) {\n          mergedPos = cellPos;\n          mergedCell = cell;\n        } else {\n          if (!isEmpty(cell))\n            content = content.append(cell.content);\n          const mapped = tr.mapping.map(cellPos + rect.tableStart);\n          tr.delete(mapped, mapped + cell.nodeSize);\n        }\n      }\n    }\n    if (mergedPos == null || mergedCell == null) {\n      return true;\n    }\n    tr.setNodeMarkup(mergedPos + rect.tableStart, null, {\n      ...addColSpan(\n        mergedCell.attrs,\n        mergedCell.attrs.colspan,\n        rect.right - rect.left - mergedCell.attrs.colspan\n      ),\n      rowspan: rect.bottom - rect.top\n    });\n    if (content.size) {\n      const end = mergedPos + 1 + mergedCell.content.size;\n      const start = isEmpty(mergedCell) ? mergedPos + 1 : end;\n      tr.replaceWith(start + rect.tableStart, end + rect.tableStart, content);\n    }\n    tr.setSelection(\n      new CellSelection(tr.doc.resolve(mergedPos + rect.tableStart))\n    );\n    dispatch(tr);\n  }\n  return true;\n}\nfunction splitCell(state, dispatch) {\n  const nodeTypes = tableNodeTypes(state.schema);\n  return splitCellWithType(({ node }) => {\n    return nodeTypes[node.type.spec.tableRole];\n  })(state, dispatch);\n}\nfunction splitCellWithType(getCellType) {\n  return (state, dispatch) => {\n    var _a;\n    const sel = state.selection;\n    let cellNode;\n    let cellPos;\n    if (!(sel instanceof CellSelection)) {\n      cellNode = cellWrapping(sel.$from);\n      if (!cellNode)\n        return false;\n      cellPos = (_a = cellAround(sel.$from)) == null ? void 0 : _a.pos;\n    } else {\n      if (sel.$anchorCell.pos != sel.$headCell.pos)\n        return false;\n      cellNode = sel.$anchorCell.nodeAfter;\n      cellPos = sel.$anchorCell.pos;\n    }\n    if (cellNode == null || cellPos == null) {\n      return false;\n    }\n    if (cellNode.attrs.colspan == 1 && cellNode.attrs.rowspan == 1) {\n      return false;\n    }\n    if (dispatch) {\n      let baseAttrs = cellNode.attrs;\n      const attrs = [];\n      const colwidth = baseAttrs.colwidth;\n      if (baseAttrs.rowspan > 1)\n        baseAttrs = { ...baseAttrs, rowspan: 1 };\n      if (baseAttrs.colspan > 1)\n        baseAttrs = { ...baseAttrs, colspan: 1 };\n      const rect = selectedRect(state), tr = state.tr;\n      for (let i = 0; i < rect.right - rect.left; i++)\n        attrs.push(\n          colwidth ? {\n            ...baseAttrs,\n            colwidth: colwidth && colwidth[i] ? [colwidth[i]] : null\n          } : baseAttrs\n        );\n      let lastCell;\n      for (let row = rect.top; row < rect.bottom; row++) {\n        let pos = rect.map.positionAt(row, rect.left, rect.table);\n        if (row == rect.top)\n          pos += cellNode.nodeSize;\n        for (let col = rect.left, i = 0; col < rect.right; col++, i++) {\n          if (col == rect.left && row == rect.top)\n            continue;\n          tr.insert(\n            lastCell = tr.mapping.map(pos + rect.tableStart, 1),\n            getCellType({ node: cellNode, row, col }).createAndFill(attrs[i])\n          );\n        }\n      }\n      tr.setNodeMarkup(\n        cellPos,\n        getCellType({ node: cellNode, row: rect.top, col: rect.left }),\n        attrs[0]\n      );\n      if (sel instanceof CellSelection)\n        tr.setSelection(\n          new CellSelection(\n            tr.doc.resolve(sel.$anchorCell.pos),\n            lastCell ? tr.doc.resolve(lastCell) : void 0\n          )\n        );\n      dispatch(tr);\n    }\n    return true;\n  };\n}\nfunction setCellAttr(name, value) {\n  return function(state, dispatch) {\n    if (!isInTable(state))\n      return false;\n    const $cell = selectionCell(state);\n    if ($cell.nodeAfter.attrs[name] === value)\n      return false;\n    if (dispatch) {\n      const tr = state.tr;\n      if (state.selection instanceof CellSelection)\n        state.selection.forEachCell((node, pos) => {\n          if (node.attrs[name] !== value)\n            tr.setNodeMarkup(pos, null, {\n              ...node.attrs,\n              [name]: value\n            });\n        });\n      else\n        tr.setNodeMarkup($cell.pos, null, {\n          ...$cell.nodeAfter.attrs,\n          [name]: value\n        });\n      dispatch(tr);\n    }\n    return true;\n  };\n}\nfunction deprecated_toggleHeader(type) {\n  return function(state, dispatch) {\n    if (!isInTable(state))\n      return false;\n    if (dispatch) {\n      const types = tableNodeTypes(state.schema);\n      const rect = selectedRect(state), tr = state.tr;\n      const cells = rect.map.cellsInRect(\n        type == \"column\" ? {\n          left: rect.left,\n          top: 0,\n          right: rect.right,\n          bottom: rect.map.height\n        } : type == \"row\" ? {\n          left: 0,\n          top: rect.top,\n          right: rect.map.width,\n          bottom: rect.bottom\n        } : rect\n      );\n      const nodes = cells.map((pos) => rect.table.nodeAt(pos));\n      for (let i = 0; i < cells.length; i++)\n        if (nodes[i].type == types.header_cell)\n          tr.setNodeMarkup(\n            rect.tableStart + cells[i],\n            types.cell,\n            nodes[i].attrs\n          );\n      if (tr.steps.length == 0)\n        for (let i = 0; i < cells.length; i++)\n          tr.setNodeMarkup(\n            rect.tableStart + cells[i],\n            types.header_cell,\n            nodes[i].attrs\n          );\n      dispatch(tr);\n    }\n    return true;\n  };\n}\nfunction isHeaderEnabledByType(type, rect, types) {\n  const cellPositions = rect.map.cellsInRect({\n    left: 0,\n    top: 0,\n    right: type == \"row\" ? rect.map.width : 1,\n    bottom: type == \"column\" ? rect.map.height : 1\n  });\n  for (let i = 0; i < cellPositions.length; i++) {\n    const cell = rect.table.nodeAt(cellPositions[i]);\n    if (cell && cell.type !== types.header_cell) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction toggleHeader(type, options) {\n  options = options || { useDeprecatedLogic: false };\n  if (options.useDeprecatedLogic)\n    return deprecated_toggleHeader(type);\n  return function(state, dispatch) {\n    if (!isInTable(state))\n      return false;\n    if (dispatch) {\n      const types = tableNodeTypes(state.schema);\n      const rect = selectedRect(state), tr = state.tr;\n      const isHeaderRowEnabled = isHeaderEnabledByType(\"row\", rect, types);\n      const isHeaderColumnEnabled = isHeaderEnabledByType(\n        \"column\",\n        rect,\n        types\n      );\n      const isHeaderEnabled = type === \"column\" ? isHeaderRowEnabled : type === \"row\" ? isHeaderColumnEnabled : false;\n      const selectionStartsAt = isHeaderEnabled ? 1 : 0;\n      const cellsRect = type == \"column\" ? {\n        left: 0,\n        top: selectionStartsAt,\n        right: 1,\n        bottom: rect.map.height\n      } : type == \"row\" ? {\n        left: selectionStartsAt,\n        top: 0,\n        right: rect.map.width,\n        bottom: 1\n      } : rect;\n      const newType = type == \"column\" ? isHeaderColumnEnabled ? types.cell : types.header_cell : type == \"row\" ? isHeaderRowEnabled ? types.cell : types.header_cell : types.cell;\n      rect.map.cellsInRect(cellsRect).forEach((relativeCellPos) => {\n        const cellPos = relativeCellPos + rect.tableStart;\n        const cell = tr.doc.nodeAt(cellPos);\n        if (cell) {\n          tr.setNodeMarkup(cellPos, newType, cell.attrs);\n        }\n      });\n      dispatch(tr);\n    }\n    return true;\n  };\n}\nvar toggleHeaderRow = toggleHeader(\"row\", {\n  useDeprecatedLogic: true\n});\nvar toggleHeaderColumn = toggleHeader(\"column\", {\n  useDeprecatedLogic: true\n});\nvar toggleHeaderCell = toggleHeader(\"cell\", {\n  useDeprecatedLogic: true\n});\nfunction findNextCell($cell, dir) {\n  if (dir < 0) {\n    const before = $cell.nodeBefore;\n    if (before)\n      return $cell.pos - before.nodeSize;\n    for (let row = $cell.index(-1) - 1, rowEnd = $cell.before(); row >= 0; row--) {\n      const rowNode = $cell.node(-1).child(row);\n      const lastChild = rowNode.lastChild;\n      if (lastChild) {\n        return rowEnd - 1 - lastChild.nodeSize;\n      }\n      rowEnd -= rowNode.nodeSize;\n    }\n  } else {\n    if ($cell.index() < $cell.parent.childCount - 1) {\n      return $cell.pos + $cell.nodeAfter.nodeSize;\n    }\n    const table = $cell.node(-1);\n    for (let row = $cell.indexAfter(-1), rowStart = $cell.after(); row < table.childCount; row++) {\n      const rowNode = table.child(row);\n      if (rowNode.childCount)\n        return rowStart + 1;\n      rowStart += rowNode.nodeSize;\n    }\n  }\n  return null;\n}\nfunction goToNextCell(direction) {\n  return function(state, dispatch) {\n    if (!isInTable(state))\n      return false;\n    const cell = findNextCell(selectionCell(state), direction);\n    if (cell == null)\n      return false;\n    if (dispatch) {\n      const $cell = state.doc.resolve(cell);\n      dispatch(\n        state.tr.setSelection(TextSelection3.between($cell, moveCellForward($cell))).scrollIntoView()\n      );\n    }\n    return true;\n  };\n}\nfunction deleteTable(state, dispatch) {\n  const $pos = state.selection.$anchor;\n  for (let d = $pos.depth; d > 0; d--) {\n    const node = $pos.node(d);\n    if (node.type.spec.tableRole == \"table\") {\n      if (dispatch)\n        dispatch(\n          state.tr.delete($pos.before(d), $pos.after(d)).scrollIntoView()\n        );\n      return true;\n    }\n  }\n  return false;\n}\n\n// src/index.ts\nfunction tableEditing({\n  allowTableNodeSelection = false\n} = {}) {\n  return new Plugin2({\n    key: tableEditingKey,\n    state: {\n      init() {\n        return null;\n      },\n      apply(tr, cur) {\n        const set = tr.getMeta(tableEditingKey);\n        if (set != null)\n          return set == -1 ? null : set;\n        if (cur == null || !tr.docChanged)\n          return cur;\n        const { deleted, pos } = tr.mapping.mapResult(cur);\n        return deleted ? null : pos;\n      }\n    },\n    props: {\n      decorations: drawCellSelection,\n      handleDOMEvents: {\n        mousedown: handleMouseDown\n      },\n      createSelectionBetween(view) {\n        return tableEditingKey.getState(view.state) != null ? view.state.selection : null;\n      },\n      handleTripleClick,\n      handleKeyDown,\n      handlePaste\n    },\n    appendTransaction(_, oldState, state) {\n      return normalizeSelection(\n        state,\n        fixTables(state, oldState),\n        allowTableNodeSelection\n      );\n    }\n  });\n}\nexport {\n  CellBookmark,\n  CellSelection,\n  ResizeState,\n  TableMap,\n  TableView,\n  clipCells as __clipCells,\n  insertCells as __insertCells,\n  pastedCells as __pastedCells,\n  addColSpan,\n  addColumn,\n  addColumnAfter,\n  addColumnBefore,\n  addRow,\n  addRowAfter,\n  addRowBefore,\n  cellAround,\n  colCount,\n  columnIsHeader,\n  columnResizing,\n  columnResizingPluginKey,\n  deleteColumn,\n  deleteRow,\n  deleteTable,\n  findCell,\n  fixTables,\n  fixTablesKey,\n  goToNextCell,\n  handlePaste,\n  inSameTable,\n  isInTable,\n  mergeCells,\n  moveCellForward,\n  nextCell,\n  pointsAtCell,\n  removeColSpan,\n  removeColumn,\n  removeRow,\n  rowIsHeader,\n  selectedRect,\n  selectionCell,\n  setCellAttr,\n  splitCell,\n  splitCellWithType,\n  tableEditing,\n  tableEditingKey,\n  tableNodeTypes,\n  tableNodes,\n  toggleHeader,\n  toggleHeaderCell,\n  toggleHeaderColumn,\n  toggleHeaderRow,\n  updateColumnsOnResize\n};\n","import { findParentNodeClosestToPos, Node, mergeAttributes, callOrReturn, getExtensionField } from '@tiptap/core';\nimport { TextSelection } from '@tiptap/pm/state';\nimport { CellSelection, addColumnBefore, addColumnAfter, deleteColumn, addRowBefore, addRowAfter, deleteRow, deleteTable, mergeCells, splitCell, toggleHeader, toggleHeaderCell, setCellAttr, goToNextCell, fixTables, columnResizing, tableEditing } from '@tiptap/pm/tables';\n\nfunction updateColumns(node, colgroup, table, cellMinWidth, overrideCol, overrideValue) {\r\n    let totalWidth = 0;\r\n    let fixedWidth = true;\r\n    let nextDOM = colgroup.firstChild;\r\n    const row = node.firstChild;\r\n    for (let i = 0, col = 0; i < row.childCount; i += 1) {\r\n        const { colspan, colwidth } = row.child(i).attrs;\r\n        for (let j = 0; j < colspan; j += 1, col += 1) {\r\n            const hasWidth = overrideCol === col ? overrideValue : colwidth && colwidth[j];\r\n            const cssWidth = hasWidth ? `${hasWidth}px` : '';\r\n            totalWidth += hasWidth || cellMinWidth;\r\n            if (!hasWidth) {\r\n                fixedWidth = false;\r\n            }\r\n            if (!nextDOM) {\r\n                colgroup.appendChild(document.createElement('col')).style.width = cssWidth;\r\n            }\r\n            else {\r\n                if (nextDOM.style.width !== cssWidth) {\r\n                    nextDOM.style.width = cssWidth;\r\n                }\r\n                nextDOM = nextDOM.nextSibling;\r\n            }\r\n        }\r\n    }\r\n    while (nextDOM) {\r\n        const after = nextDOM.nextSibling;\r\n        nextDOM.parentNode.removeChild(nextDOM);\r\n        nextDOM = after;\r\n    }\r\n    if (fixedWidth) {\r\n        table.style.width = `${totalWidth}px`;\r\n        table.style.minWidth = '';\r\n    }\r\n    else {\r\n        table.style.width = '';\r\n        table.style.minWidth = `${totalWidth}px`;\r\n    }\r\n}\r\nclass TableView {\r\n    constructor(node, cellMinWidth) {\r\n        this.node = node;\r\n        this.cellMinWidth = cellMinWidth;\r\n        this.dom = document.createElement('div');\r\n        this.dom.className = 'tableWrapper';\r\n        this.table = this.dom.appendChild(document.createElement('table'));\r\n        this.colgroup = this.table.appendChild(document.createElement('colgroup'));\r\n        updateColumns(node, this.colgroup, this.table, cellMinWidth);\r\n        this.contentDOM = this.table.appendChild(document.createElement('tbody'));\r\n    }\r\n    update(node) {\r\n        if (node.type !== this.node.type) {\r\n            return false;\r\n        }\r\n        this.node = node;\r\n        updateColumns(node, this.colgroup, this.table, this.cellMinWidth);\r\n        return true;\r\n    }\r\n    ignoreMutation(mutation) {\r\n        return (mutation.type === 'attributes'\r\n            && (mutation.target === this.table || this.colgroup.contains(mutation.target)));\r\n    }\r\n}\n\nfunction createCell(cellType, cellContent) {\r\n    if (cellContent) {\r\n        return cellType.createChecked(null, cellContent);\r\n    }\r\n    return cellType.createAndFill();\r\n}\n\nfunction getTableNodeTypes(schema) {\r\n    if (schema.cached.tableNodeTypes) {\r\n        return schema.cached.tableNodeTypes;\r\n    }\r\n    const roles = {};\r\n    Object.keys(schema.nodes).forEach(type => {\r\n        const nodeType = schema.nodes[type];\r\n        if (nodeType.spec.tableRole) {\r\n            roles[nodeType.spec.tableRole] = nodeType;\r\n        }\r\n    });\r\n    schema.cached.tableNodeTypes = roles;\r\n    return roles;\r\n}\n\nfunction createTable(schema, rowsCount, colsCount, withHeaderRow, cellContent) {\r\n    const types = getTableNodeTypes(schema);\r\n    const headerCells = [];\r\n    const cells = [];\r\n    for (let index = 0; index < colsCount; index += 1) {\r\n        const cell = createCell(types.cell, cellContent);\r\n        if (cell) {\r\n            cells.push(cell);\r\n        }\r\n        if (withHeaderRow) {\r\n            const headerCell = createCell(types.header_cell, cellContent);\r\n            if (headerCell) {\r\n                headerCells.push(headerCell);\r\n            }\r\n        }\r\n    }\r\n    const rows = [];\r\n    for (let index = 0; index < rowsCount; index += 1) {\r\n        rows.push(types.row.createChecked(null, withHeaderRow && index === 0 ? headerCells : cells));\r\n    }\r\n    return types.table.createChecked(null, rows);\r\n}\n\nfunction isCellSelection(value) {\r\n    return value instanceof CellSelection;\r\n}\n\nconst deleteTableWhenAllCellsSelected = ({ editor }) => {\r\n    const { selection } = editor.state;\r\n    if (!isCellSelection(selection)) {\r\n        return false;\r\n    }\r\n    let cellCount = 0;\r\n    const table = findParentNodeClosestToPos(selection.ranges[0].$from, node => {\r\n        return node.type.name === 'table';\r\n    });\r\n    table === null || table === void 0 ? void 0 : table.node.descendants(node => {\r\n        if (node.type.name === 'table') {\r\n            return false;\r\n        }\r\n        if (['tableCell', 'tableHeader'].includes(node.type.name)) {\r\n            cellCount += 1;\r\n        }\r\n    });\r\n    const allCellsSelected = cellCount === selection.ranges.length;\r\n    if (!allCellsSelected) {\r\n        return false;\r\n    }\r\n    editor.commands.deleteTable();\r\n    return true;\r\n};\n\nconst Table = Node.create({\r\n    name: 'table',\r\n    // @ts-ignore\r\n    addOptions() {\r\n        return {\r\n            HTMLAttributes: {},\r\n            resizable: false,\r\n            handleWidth: 5,\r\n            cellMinWidth: 25,\r\n            // TODO: fix\r\n            View: TableView,\r\n            lastColumnResizable: true,\r\n            allowTableNodeSelection: false,\r\n        };\r\n    },\r\n    content: 'tableRow+',\r\n    tableRole: 'table',\r\n    isolating: true,\r\n    group: 'block',\r\n    parseHTML() {\r\n        return [{ tag: 'table' }];\r\n    },\r\n    renderHTML({ HTMLAttributes }) {\r\n        return ['table', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), ['tbody', 0]];\r\n    },\r\n    addCommands() {\r\n        return {\r\n            insertTable: ({ rows = 3, cols = 3, withHeaderRow = true } = {}) => ({ tr, dispatch, editor }) => {\r\n                const node = createTable(editor.schema, rows, cols, withHeaderRow);\r\n                if (dispatch) {\r\n                    const offset = tr.selection.anchor + 1;\r\n                    tr.replaceSelectionWith(node)\r\n                        .scrollIntoView()\r\n                        .setSelection(TextSelection.near(tr.doc.resolve(offset)));\r\n                }\r\n                return true;\r\n            },\r\n            addColumnBefore: () => ({ state, dispatch }) => {\r\n                return addColumnBefore(state, dispatch);\r\n            },\r\n            addColumnAfter: () => ({ state, dispatch }) => {\r\n                return addColumnAfter(state, dispatch);\r\n            },\r\n            deleteColumn: () => ({ state, dispatch }) => {\r\n                return deleteColumn(state, dispatch);\r\n            },\r\n            addRowBefore: () => ({ state, dispatch }) => {\r\n                return addRowBefore(state, dispatch);\r\n            },\r\n            addRowAfter: () => ({ state, dispatch }) => {\r\n                return addRowAfter(state, dispatch);\r\n            },\r\n            deleteRow: () => ({ state, dispatch }) => {\r\n                return deleteRow(state, dispatch);\r\n            },\r\n            deleteTable: () => ({ state, dispatch }) => {\r\n                return deleteTable(state, dispatch);\r\n            },\r\n            mergeCells: () => ({ state, dispatch }) => {\r\n                return mergeCells(state, dispatch);\r\n            },\r\n            splitCell: () => ({ state, dispatch }) => {\r\n                return splitCell(state, dispatch);\r\n            },\r\n            toggleHeaderColumn: () => ({ state, dispatch }) => {\r\n                return toggleHeader('column')(state, dispatch);\r\n            },\r\n            toggleHeaderRow: () => ({ state, dispatch }) => {\r\n                return toggleHeader('row')(state, dispatch);\r\n            },\r\n            toggleHeaderCell: () => ({ state, dispatch }) => {\r\n                return toggleHeaderCell(state, dispatch);\r\n            },\r\n            mergeOrSplit: () => ({ state, dispatch }) => {\r\n                if (mergeCells(state, dispatch)) {\r\n                    return true;\r\n                }\r\n                return splitCell(state, dispatch);\r\n            },\r\n            setCellAttribute: (name, value) => ({ state, dispatch }) => {\r\n                return setCellAttr(name, value)(state, dispatch);\r\n            },\r\n            goToNextCell: () => ({ state, dispatch }) => {\r\n                return goToNextCell(1)(state, dispatch);\r\n            },\r\n            goToPreviousCell: () => ({ state, dispatch }) => {\r\n                return goToNextCell(-1)(state, dispatch);\r\n            },\r\n            fixTables: () => ({ state, dispatch }) => {\r\n                if (dispatch) {\r\n                    fixTables(state);\r\n                }\r\n                return true;\r\n            },\r\n            setCellSelection: position => ({ tr, dispatch }) => {\r\n                if (dispatch) {\r\n                    const selection = CellSelection.create(tr.doc, position.anchorCell, position.headCell);\r\n                    // @ts-ignore\r\n                    tr.setSelection(selection);\r\n                }\r\n                return true;\r\n            },\r\n        };\r\n    },\r\n    addKeyboardShortcuts() {\r\n        return {\r\n            Tab: () => {\r\n                if (this.editor.commands.goToNextCell()) {\r\n                    return true;\r\n                }\r\n                if (!this.editor.can().addRowAfter()) {\r\n                    return false;\r\n                }\r\n                return this.editor.chain().addRowAfter().goToNextCell().run();\r\n            },\r\n            'Shift-Tab': () => this.editor.commands.goToPreviousCell(),\r\n            Backspace: deleteTableWhenAllCellsSelected,\r\n            'Mod-Backspace': deleteTableWhenAllCellsSelected,\r\n            Delete: deleteTableWhenAllCellsSelected,\r\n            'Mod-Delete': deleteTableWhenAllCellsSelected,\r\n        };\r\n    },\r\n    addProseMirrorPlugins() {\r\n        const isResizable = this.options.resizable && this.editor.isEditable;\r\n        return [\r\n            ...(isResizable\r\n                ? [\r\n                    columnResizing({\r\n                        handleWidth: this.options.handleWidth,\r\n                        cellMinWidth: this.options.cellMinWidth,\r\n                        // @ts-ignore (incorrect type)\r\n                        View: this.options.View,\r\n                        // TODO: PR for @types/prosemirror-tables\r\n                        // @ts-ignore (incorrect type)\r\n                        lastColumnResizable: this.options.lastColumnResizable,\r\n                    }),\r\n                ]\r\n                : []),\r\n            tableEditing({\r\n                allowTableNodeSelection: this.options.allowTableNodeSelection,\r\n            }),\r\n        ];\r\n    },\r\n    extendNodeSchema(extension) {\r\n        const context = {\r\n            name: extension.name,\r\n            options: extension.options,\r\n            storage: extension.storage,\r\n        };\r\n        return {\r\n            tableRole: callOrReturn(getExtensionField(extension, 'tableRole', context)),\r\n        };\r\n    },\r\n});\n\nexport { Table, createTable, Table as default };\n//# sourceMappingURL=index.js.map\n","import { mergeAttributes } from \"@tiptap/core\";\nimport { Table as TipTapTable } from \"@tiptap/extension-table\";\n\nexport const factory = () => {\n    return TipTapTable.extend({\n        parseHTML() {\n            return [\n                {\n                    tag: \"table\",\n                    getAttrs: (node) =>\n                        node.closest(\"div.scroll-table\") === null && null,\n                },\n                {\n                    tag: \"div\",\n                    getAttrs: (node) =>\n                        node.matches(\".scroll-table\").getElementsByTagName(\"table\") !==\n                            null && null,\n                },\n            ];\n        },\n        renderHTML({ HTMLAttributes }) {\n            return [\n                \"div\",\n                { class: \"scroll-table\" },\n                [\n                    \"table\",\n                    mergeAttributes(this.options.HTMLAttributes, HTMLAttributes),\n                    0,\n                ],\n            ];\n        },\n    });\n};\n"],"names":["readFromCache","addToCache","WeakMap","cache","key","get","value","set","cacheSize","cachePos","i","length","TableMap","constructor","width","height","map","problems","this","findCell","pos","curPos","left","top","right","bottom","j","RangeError","colCount","nextCell","axis","dir","rectBetween","a","b","leftA","rightA","topA","bottomA","leftB","rightB","topB","bottomB","Math","min","max","cellsInRect","rect","result","seen","row","col","index","push","positionAt","table","rowStart","rowEnd","child","nodeSize","rowEndIndex","static","type","spec","tableRole","name","hasRowSpan","childCount","rowNode","rowWidth","prevRow","cell","attrs","rowspan","colspan","findWidth","mapPos","colWidths","e","cellNode","colwidth","h","n","start","w","colW","widthIndex","prev","expectedPos","missing","tableMap","badWidths","node","nodeAt","updated","colWidth","freshColWidth","unshift","findBadColWidths","computeMap","slice","tableNodeTypes","schema","cached","nodes","role","tableEditingKey","cellAround","$pos","d","depth","resolve","before","isInTable","state","$head","selection","selectionCell","sel","$anchorCell","$headCell","$anchor","$cell","after","nodeAfter","firstChild","doc","nodeBefore","lastChild","cellNear","head","pointsAtCell","parent","inSameTable","$cellA","$cellB","end","tableStart","moved","removeColSpan","splice","some","addColSpan","CellSelection","cells","filter","p","ranges","from","content","size","super","$from","$to","mapping","tableChanged","isRowSelection","rowSelection","isColSelection","colSelection","between","rows","rowContent","cellRect","extraLeft","extraRight","createAndFill","JSON","stringify","create","copy","fragment","replace","tr","empty","mapFrom","steps","findFrom","to","setSelection","replaceWith","forEachCell","f","anchorTop","headTop","anchorBottom","headBottom","anchorRect","headRect","anchorLeft","headLeft","anchorRight","headRight","eq","other","toJSON","anchor","json","anchorCell","headCell","getBookmark","CellBookmark","prototype","visible","jsonID","near","drawCellSelection","class","fixTablesKey","changedDescendants","old","cur","offset","oldSize","curSize","outer","scan","sameMarkup","nodesBetween","fixTables","oldState","check","tablePos","mustAdd","prob","setNodeMarkup","first","last","add","side","insert","setMeta","fixTable","descendants","pastedCells","openStart","openEnd","fitSlice","widths","r","append","ensureRectangular","nodeType","isolateHorizontal","found","cellTop","cellLeft","isolateVertical","updatePos","insertCells","dispatch","Error","recomp","maps","types","emptyHead","header_cell","start2","header","emptyRow","growTable","handleKeyDown","ArrowLeft","arrow","ArrowRight","ArrowUp","ArrowDown","shiftArrow","Backspace","deleteCellSelection","Delete","maybeSetSelection","scrollIntoView","view","atEndOfCell","$next","newSel","cellSel","baseContent","docChanged","handleTripleClick","handlePaste","_","newWidth","newHeight","added","newRows","frag","createChecked","source","clipCells","handleMouseDown","startEvent","_a","ctrlKey","metaKey","startDOMCell","domInCell","target","shiftKey","setCellSelection","preventDefault","cellUnderMouse","$anchor2","event","starting","getState","stop","root","removeEventListener","move","_event","addEventListener","indexAfter","cellPos","dirStr","endOfTextblock","dom","parentNode","nodeName","mousePos","posAtCoords","clientX","clientY","TableView","cellMinWidth","document","createElement","className","appendChild","colgroup","updateColumnsOnResize","contentDOM","update","ignoreMutation","record","contains","overrideCol","overrideValue","totalWidth","fixedWidth","nextDOM","hasWidth","cssWidth","style","nextSibling","removeChild","minWidth","columnResizingPluginKey","columnResizing","handleWidth","View","lastColumnResizable","plugin","init","props","nodeViews","ResizeState","apply","attributes","pluginState","activeHandle","handleDOMEvents","mousemove","dragging","classList","domCellAround","getBoundingClientRect","edgeCell","updateHandle","handleMouseMove","mouseleave","handleMouseLeave","mousedown","domAtPos","domWidth","childNodes","offsetWidth","parts","currentColWidth","finish","event2","window","pluginState2","mapIndex","zeroes","updateColumnWidth","draggedWidth","setDragging","which","dragged","displayColumnWidth","startX","startWidth","handleMouseDown2","decorations","widget","handleDecorations","action","getMeta","setHandle","handle","indexOf","Array","fill","selectedRect","addColumn","refColumn","headerCell","columnIsHeader","removeColumn","mapStart","delete","addRow","rowPos","refRow","rowIsHeader","removeRow","nextRow","newPos","isEmpty","c","isTextblock","mergeCells","indexTop","indexLeft","indexBottom","indexRight","cellsOverlapRectangle","mergedPos","mergedCell","mapped","splitCell","nodeTypes","getCellType","cellWrapping","baseAttrs","lastCell","isHeaderEnabledByType","cellPositions","toggleHeader","options","useDeprecatedLogic","deprecated_toggleHeader","isHeaderRowEnabled","isHeaderColumnEnabled","selectionStartsAt","cellsRect","newType","forEach","relativeCellPos","toggleHeaderCell","goToNextCell","direction","findNextCell","tableEditing","allowTableNodeSelection","deleted","mapResult","createSelectionBetween","appendTransaction","normalize","afterFrom","beforeTo","test","isCellBoundarySelection","fromCellBoundaryNode","toCellBoundaryNode","parentOffset","isTextSelectionAcrossCells","normalizeSelection","updateColumns","mutation","createCell","cellType","cellContent","createTable","rowsCount","colsCount","withHeaderRow","roles","Object","keys","getTableNodeTypes","headerCells","deleteTableWhenAllCellsSelected","editor","cellCount","findParentNodeClosestToPos","includes","commands","deleteTable","Table","Node","addOptions","HTMLAttributes","resizable","isolating","group","parseHTML","tag","renderHTML","mergeAttributes","addCommands","insertTable","cols","replaceSelectionWith","addColumnBefore","addColumnAfter","deleteColumn","addRowBefore","addRowAfter","deleteRow","toggleHeaderColumn","toggleHeaderRow","mergeOrSplit","setCellAttribute","setCellAttr","goToPreviousCell","position","addKeyboardShortcuts","Tab","can","chain","run","addProseMirrorPlugins","isEditable","extendNodeSchema","extension","context","storage","callOrReturn","getExtensionField","factory","TipTapTable","extend","getAttrs","closest","matches","getElementsByTagName","_ref"],"sourceRoot":""}