{"version":3,"file":"chunks/84819.617437439428f3b7105e.min.js","mappings":"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","sources":["webpack://@patternslib/patternslib/./node_modules/rope-sequence/dist/index.es.js","webpack://@patternslib/patternslib/./node_modules/prosemirror-history/node_modules/prosemirror-state/dist/index.js","webpack://@patternslib/patternslib/./node_modules/prosemirror-history/dist/index.js","webpack://@patternslib/patternslib/./node_modules/@patternslib/pat-tiptap/node_modules/@tiptap/extension-history/dist/tiptap-extension-history.esm.js"],"sourcesContent":["var GOOD_LEAF_SIZE = 200;\n\n// :: class<T> A rope sequence is a persistent sequence data structure\n// that supports appending, prepending, and slicing without doing a\n// full copy. It is represented as a mostly-balanced tree.\nvar RopeSequence = function RopeSequence () {};\n\nRopeSequence.prototype.append = function append (other) {\n  if (!other.length) { return this }\n  other = RopeSequence.from(other);\n\n  return (!this.length && other) ||\n    (other.length < GOOD_LEAF_SIZE && this.leafAppend(other)) ||\n    (this.length < GOOD_LEAF_SIZE && other.leafPrepend(this)) ||\n    this.appendInner(other)\n};\n\n// :: (union<[T], RopeSequence<T>>) → RopeSequence<T>\n// Prepend an array or other rope to this one, returning a new rope.\nRopeSequence.prototype.prepend = function prepend (other) {\n  if (!other.length) { return this }\n  return RopeSequence.from(other).append(this)\n};\n\nRopeSequence.prototype.appendInner = function appendInner (other) {\n  return new Append(this, other)\n};\n\n// :: (?number, ?number) → RopeSequence<T>\n// Create a rope repesenting a sub-sequence of this rope.\nRopeSequence.prototype.slice = function slice (from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.length;\n\n  if (from >= to) { return RopeSequence.empty }\n  return this.sliceInner(Math.max(0, from), Math.min(this.length, to))\n};\n\n// :: (number) → T\n// Retrieve the element at the given position from this rope.\nRopeSequence.prototype.get = function get (i) {\n  if (i < 0 || i >= this.length) { return undefined }\n  return this.getInner(i)\n};\n\n// :: ((element: T, index: number) → ?bool, ?number, ?number)\n// Call the given function for each element between the given\n// indices. This tends to be more efficient than looping over the\n// indices and calling `get`, because it doesn't have to descend the\n// tree for every element.\nRopeSequence.prototype.forEach = function forEach (f, from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.length;\n\n  if (from <= to)\n    { this.forEachInner(f, from, to, 0); }\n  else\n    { this.forEachInvertedInner(f, from, to, 0); }\n};\n\n// :: ((element: T, index: number) → U, ?number, ?number) → [U]\n// Map the given functions over the elements of the rope, producing\n// a flat array.\nRopeSequence.prototype.map = function map (f, from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.length;\n\n  var result = [];\n  this.forEach(function (elt, i) { return result.push(f(elt, i)); }, from, to);\n  return result\n};\n\n// :: (?union<[T], RopeSequence<T>>) → RopeSequence<T>\n// Create a rope representing the given array, or return the rope\n// itself if a rope was given.\nRopeSequence.from = function from (values) {\n  if (values instanceof RopeSequence) { return values }\n  return values && values.length ? new Leaf(values) : RopeSequence.empty\n};\n\nvar Leaf = /*@__PURE__*/(function (RopeSequence) {\n  function Leaf(values) {\n    RopeSequence.call(this);\n    this.values = values;\n  }\n\n  if ( RopeSequence ) Leaf.__proto__ = RopeSequence;\n  Leaf.prototype = Object.create( RopeSequence && RopeSequence.prototype );\n  Leaf.prototype.constructor = Leaf;\n\n  var prototypeAccessors = { length: { configurable: true },depth: { configurable: true } };\n\n  Leaf.prototype.flatten = function flatten () {\n    return this.values\n  };\n\n  Leaf.prototype.sliceInner = function sliceInner (from, to) {\n    if (from == 0 && to == this.length) { return this }\n    return new Leaf(this.values.slice(from, to))\n  };\n\n  Leaf.prototype.getInner = function getInner (i) {\n    return this.values[i]\n  };\n\n  Leaf.prototype.forEachInner = function forEachInner (f, from, to, start) {\n    for (var i = from; i < to; i++)\n      { if (f(this.values[i], start + i) === false) { return false } }\n  };\n\n  Leaf.prototype.forEachInvertedInner = function forEachInvertedInner (f, from, to, start) {\n    for (var i = from - 1; i >= to; i--)\n      { if (f(this.values[i], start + i) === false) { return false } }\n  };\n\n  Leaf.prototype.leafAppend = function leafAppend (other) {\n    if (this.length + other.length <= GOOD_LEAF_SIZE)\n      { return new Leaf(this.values.concat(other.flatten())) }\n  };\n\n  Leaf.prototype.leafPrepend = function leafPrepend (other) {\n    if (this.length + other.length <= GOOD_LEAF_SIZE)\n      { return new Leaf(other.flatten().concat(this.values)) }\n  };\n\n  prototypeAccessors.length.get = function () { return this.values.length };\n\n  prototypeAccessors.depth.get = function () { return 0 };\n\n  Object.defineProperties( Leaf.prototype, prototypeAccessors );\n\n  return Leaf;\n}(RopeSequence));\n\n// :: RopeSequence\n// The empty rope sequence.\nRopeSequence.empty = new Leaf([]);\n\nvar Append = /*@__PURE__*/(function (RopeSequence) {\n  function Append(left, right) {\n    RopeSequence.call(this);\n    this.left = left;\n    this.right = right;\n    this.length = left.length + right.length;\n    this.depth = Math.max(left.depth, right.depth) + 1;\n  }\n\n  if ( RopeSequence ) Append.__proto__ = RopeSequence;\n  Append.prototype = Object.create( RopeSequence && RopeSequence.prototype );\n  Append.prototype.constructor = Append;\n\n  Append.prototype.flatten = function flatten () {\n    return this.left.flatten().concat(this.right.flatten())\n  };\n\n  Append.prototype.getInner = function getInner (i) {\n    return i < this.left.length ? this.left.get(i) : this.right.get(i - this.left.length)\n  };\n\n  Append.prototype.forEachInner = function forEachInner (f, from, to, start) {\n    var leftLen = this.left.length;\n    if (from < leftLen &&\n        this.left.forEachInner(f, from, Math.min(to, leftLen), start) === false)\n      { return false }\n    if (to > leftLen &&\n        this.right.forEachInner(f, Math.max(from - leftLen, 0), Math.min(this.length, to) - leftLen, start + leftLen) === false)\n      { return false }\n  };\n\n  Append.prototype.forEachInvertedInner = function forEachInvertedInner (f, from, to, start) {\n    var leftLen = this.left.length;\n    if (from > leftLen &&\n        this.right.forEachInvertedInner(f, from - leftLen, Math.max(to, leftLen) - leftLen, start + leftLen) === false)\n      { return false }\n    if (to < leftLen &&\n        this.left.forEachInvertedInner(f, Math.min(from, leftLen), to, start) === false)\n      { return false }\n  };\n\n  Append.prototype.sliceInner = function sliceInner (from, to) {\n    if (from == 0 && to == this.length) { return this }\n    var leftLen = this.left.length;\n    if (to <= leftLen) { return this.left.slice(from, to) }\n    if (from >= leftLen) { return this.right.slice(from - leftLen, to - leftLen) }\n    return this.left.slice(from, leftLen).append(this.right.slice(0, to - leftLen))\n  };\n\n  Append.prototype.leafAppend = function leafAppend (other) {\n    var inner = this.right.leafAppend(other);\n    if (inner) { return new Append(this.left, inner) }\n  };\n\n  Append.prototype.leafPrepend = function leafPrepend (other) {\n    var inner = this.left.leafPrepend(other);\n    if (inner) { return new Append(inner, this.right) }\n  };\n\n  Append.prototype.appendInner = function appendInner (other) {\n    if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1)\n      { return new Append(this.left, new Append(this.right, other)) }\n    return new Append(this, other)\n  };\n\n  return Append;\n}(RopeSequence));\n\nvar ropeSequence = RopeSequence;\n\nexport default ropeSequence;\n","import { Slice, Fragment, Mark, Node } from 'prosemirror-model';\nimport { ReplaceStep, ReplaceAroundStep, Transform } from 'prosemirror-transform';\n\nconst classesById = Object.create(null);\n/**\nSuperclass for editor selections. Every selection type should\nextend this. Should not be instantiated directly.\n*/\nclass Selection {\n    /**\n    Initialize a selection with the head and anchor and ranges. If no\n    ranges are given, constructs a single range across `$anchor` and\n    `$head`.\n    */\n    constructor(\n    /**\n    The resolved anchor of the selection (the side that stays in\n    place when the selection is modified).\n    */\n    $anchor, \n    /**\n    The resolved head of the selection (the side that moves when\n    the selection is modified).\n    */\n    $head, ranges) {\n        this.$anchor = $anchor;\n        this.$head = $head;\n        this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];\n    }\n    /**\n    The selection's anchor, as an unresolved position.\n    */\n    get anchor() { return this.$anchor.pos; }\n    /**\n    The selection's head.\n    */\n    get head() { return this.$head.pos; }\n    /**\n    The lower bound of the selection's main range.\n    */\n    get from() { return this.$from.pos; }\n    /**\n    The upper bound of the selection's main range.\n    */\n    get to() { return this.$to.pos; }\n    /**\n    The resolved lower  bound of the selection's main range.\n    */\n    get $from() {\n        return this.ranges[0].$from;\n    }\n    /**\n    The resolved upper bound of the selection's main range.\n    */\n    get $to() {\n        return this.ranges[0].$to;\n    }\n    /**\n    Indicates whether the selection contains any content.\n    */\n    get empty() {\n        let ranges = this.ranges;\n        for (let i = 0; i < ranges.length; i++)\n            if (ranges[i].$from.pos != ranges[i].$to.pos)\n                return false;\n        return true;\n    }\n    /**\n    Get the content of this selection as a slice.\n    */\n    content() {\n        return this.$from.doc.slice(this.from, this.to, true);\n    }\n    /**\n    Replace the selection with a slice or, if no slice is given,\n    delete the selection. Will append to the given transaction.\n    */\n    replace(tr, content = Slice.empty) {\n        // Put the new selection at the position after the inserted\n        // content. When that ended in an inline node, search backwards,\n        // to get the position after that node. If not, search forward.\n        let lastNode = content.content.lastChild, lastParent = null;\n        for (let i = 0; i < content.openEnd; i++) {\n            lastParent = lastNode;\n            lastNode = lastNode.lastChild;\n        }\n        let mapFrom = tr.steps.length, ranges = this.ranges;\n        for (let i = 0; i < ranges.length; i++) {\n            let { $from, $to } = ranges[i], mapping = tr.mapping.slice(mapFrom);\n            tr.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i ? Slice.empty : content);\n            if (i == 0)\n                selectionToInsertionEnd(tr, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1);\n        }\n    }\n    /**\n    Replace the selection with the given node, appending the changes\n    to the given transaction.\n    */\n    replaceWith(tr, node) {\n        let mapFrom = tr.steps.length, ranges = this.ranges;\n        for (let i = 0; i < ranges.length; i++) {\n            let { $from, $to } = ranges[i], mapping = tr.mapping.slice(mapFrom);\n            let from = mapping.map($from.pos), to = mapping.map($to.pos);\n            if (i) {\n                tr.deleteRange(from, to);\n            }\n            else {\n                tr.replaceRangeWith(from, to, node);\n                selectionToInsertionEnd(tr, mapFrom, node.isInline ? -1 : 1);\n            }\n        }\n    }\n    /**\n    Find a valid cursor or leaf node selection starting at the given\n    position and searching back if `dir` is negative, and forward if\n    positive. When `textOnly` is true, only consider cursor\n    selections. Will return null when no valid selection position is\n    found.\n    */\n    static findFrom($pos, dir, textOnly = false) {\n        let inner = $pos.parent.inlineContent ? new TextSelection($pos)\n            : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);\n        if (inner)\n            return inner;\n        for (let depth = $pos.depth - 1; depth >= 0; depth--) {\n            let found = dir < 0\n                ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly)\n                : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);\n            if (found)\n                return found;\n        }\n        return null;\n    }\n    /**\n    Find a valid cursor or leaf node selection near the given\n    position. Searches forward first by default, but if `bias` is\n    negative, it will search backwards first.\n    */\n    static near($pos, bias = 1) {\n        return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0));\n    }\n    /**\n    Find the cursor or leaf node selection closest to the start of\n    the given document. Will return an\n    [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position\n    exists.\n    */\n    static atStart(doc) {\n        return findSelectionIn(doc, doc, 0, 0, 1) || new AllSelection(doc);\n    }\n    /**\n    Find the cursor or leaf node selection closest to the end of the\n    given document.\n    */\n    static atEnd(doc) {\n        return findSelectionIn(doc, doc, doc.content.size, doc.childCount, -1) || new AllSelection(doc);\n    }\n    /**\n    Deserialize the JSON representation of a selection. Must be\n    implemented for custom classes (as a static class method).\n    */\n    static fromJSON(doc, json) {\n        if (!json || !json.type)\n            throw new RangeError(\"Invalid input for Selection.fromJSON\");\n        let cls = classesById[json.type];\n        if (!cls)\n            throw new RangeError(`No selection type ${json.type} defined`);\n        return cls.fromJSON(doc, json);\n    }\n    /**\n    To be able to deserialize selections from JSON, custom selection\n    classes must register themselves with an ID string, so that they\n    can be disambiguated. Try to pick something that's unlikely to\n    clash with classes from other modules.\n    */\n    static jsonID(id, selectionClass) {\n        if (id in classesById)\n            throw new RangeError(\"Duplicate use of selection JSON ID \" + id);\n        classesById[id] = selectionClass;\n        selectionClass.prototype.jsonID = id;\n        return selectionClass;\n    }\n    /**\n    Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,\n    which is a value that can be mapped without having access to a\n    current document, and later resolved to a real selection for a\n    given document again. (This is used mostly by the history to\n    track and restore old selections.) The default implementation of\n    this method just converts the selection to a text selection and\n    returns the bookmark for that.\n    */\n    getBookmark() {\n        return TextSelection.between(this.$anchor, this.$head).getBookmark();\n    }\n}\nSelection.prototype.visible = true;\n/**\nRepresents a selected range in a document.\n*/\nclass SelectionRange {\n    /**\n    Create a range.\n    */\n    constructor(\n    /**\n    The lower bound of the range.\n    */\n    $from, \n    /**\n    The upper bound of the range.\n    */\n    $to) {\n        this.$from = $from;\n        this.$to = $to;\n    }\n}\nlet warnedAboutTextSelection = false;\nfunction checkTextSelection($pos) {\n    if (!warnedAboutTextSelection && !$pos.parent.inlineContent) {\n        warnedAboutTextSelection = true;\n        console[\"warn\"](\"TextSelection endpoint not pointing into a node with inline content (\" + $pos.parent.type.name + \")\");\n    }\n}\n/**\nA text selection represents a classical editor selection, with a\nhead (the moving side) and anchor (immobile side), both of which\npoint into textblock nodes. It can be empty (a regular cursor\nposition).\n*/\nclass TextSelection extends Selection {\n    /**\n    Construct a text selection between the given points.\n    */\n    constructor($anchor, $head = $anchor) {\n        checkTextSelection($anchor);\n        checkTextSelection($head);\n        super($anchor, $head);\n    }\n    /**\n    Returns a resolved position if this is a cursor selection (an\n    empty text selection), and null otherwise.\n    */\n    get $cursor() { return this.$anchor.pos == this.$head.pos ? this.$head : null; }\n    map(doc, mapping) {\n        let $head = doc.resolve(mapping.map(this.head));\n        if (!$head.parent.inlineContent)\n            return Selection.near($head);\n        let $anchor = doc.resolve(mapping.map(this.anchor));\n        return new TextSelection($anchor.parent.inlineContent ? $anchor : $head, $head);\n    }\n    replace(tr, content = Slice.empty) {\n        super.replace(tr, content);\n        if (content == Slice.empty) {\n            let marks = this.$from.marksAcross(this.$to);\n            if (marks)\n                tr.ensureMarks(marks);\n        }\n    }\n    eq(other) {\n        return other instanceof TextSelection && other.anchor == this.anchor && other.head == this.head;\n    }\n    getBookmark() {\n        return new TextBookmark(this.anchor, this.head);\n    }\n    toJSON() {\n        return { type: \"text\", anchor: this.anchor, head: this.head };\n    }\n    /**\n    @internal\n    */\n    static fromJSON(doc, json) {\n        if (typeof json.anchor != \"number\" || typeof json.head != \"number\")\n            throw new RangeError(\"Invalid input for TextSelection.fromJSON\");\n        return new TextSelection(doc.resolve(json.anchor), doc.resolve(json.head));\n    }\n    /**\n    Create a text selection from non-resolved positions.\n    */\n    static create(doc, anchor, head = anchor) {\n        let $anchor = doc.resolve(anchor);\n        return new this($anchor, head == anchor ? $anchor : doc.resolve(head));\n    }\n    /**\n    Return a text selection that spans the given positions or, if\n    they aren't text positions, find a text selection near them.\n    `bias` determines whether the method searches forward (default)\n    or backwards (negative number) first. Will fall back to calling\n    [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document\n    doesn't contain a valid text position.\n    */\n    static between($anchor, $head, bias) {\n        let dPos = $anchor.pos - $head.pos;\n        if (!bias || dPos)\n            bias = dPos >= 0 ? 1 : -1;\n        if (!$head.parent.inlineContent) {\n            let found = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true);\n            if (found)\n                $head = found.$head;\n            else\n                return Selection.near($head, bias);\n        }\n        if (!$anchor.parent.inlineContent) {\n            if (dPos == 0) {\n                $anchor = $head;\n            }\n            else {\n                $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor;\n                if (($anchor.pos < $head.pos) != (dPos < 0))\n                    $anchor = $head;\n            }\n        }\n        return new TextSelection($anchor, $head);\n    }\n}\nSelection.jsonID(\"text\", TextSelection);\nclass TextBookmark {\n    constructor(anchor, head) {\n        this.anchor = anchor;\n        this.head = head;\n    }\n    map(mapping) {\n        return new TextBookmark(mapping.map(this.anchor), mapping.map(this.head));\n    }\n    resolve(doc) {\n        return TextSelection.between(doc.resolve(this.anchor), doc.resolve(this.head));\n    }\n}\n/**\nA node selection is a selection that points at a single node. All\nnodes marked [selectable](https://prosemirror.net/docs/ref/#model.NodeSpec.selectable) can be the\ntarget of a node selection. In such a selection, `from` and `to`\npoint directly before and after the selected node, `anchor` equals\n`from`, and `head` equals `to`..\n*/\nclass NodeSelection extends Selection {\n    /**\n    Create a node selection. Does not verify the validity of its\n    argument.\n    */\n    constructor($pos) {\n        let node = $pos.nodeAfter;\n        let $end = $pos.node(0).resolve($pos.pos + node.nodeSize);\n        super($pos, $end);\n        this.node = node;\n    }\n    map(doc, mapping) {\n        let { deleted, pos } = mapping.mapResult(this.anchor);\n        let $pos = doc.resolve(pos);\n        if (deleted)\n            return Selection.near($pos);\n        return new NodeSelection($pos);\n    }\n    content() {\n        return new Slice(Fragment.from(this.node), 0, 0);\n    }\n    eq(other) {\n        return other instanceof NodeSelection && other.anchor == this.anchor;\n    }\n    toJSON() {\n        return { type: \"node\", anchor: this.anchor };\n    }\n    getBookmark() { return new NodeBookmark(this.anchor); }\n    /**\n    @internal\n    */\n    static fromJSON(doc, json) {\n        if (typeof json.anchor != \"number\")\n            throw new RangeError(\"Invalid input for NodeSelection.fromJSON\");\n        return new NodeSelection(doc.resolve(json.anchor));\n    }\n    /**\n    Create a node selection from non-resolved positions.\n    */\n    static create(doc, from) {\n        return new NodeSelection(doc.resolve(from));\n    }\n    /**\n    Determines whether the given node may be selected as a node\n    selection.\n    */\n    static isSelectable(node) {\n        return !node.isText && node.type.spec.selectable !== false;\n    }\n}\nNodeSelection.prototype.visible = false;\nSelection.jsonID(\"node\", NodeSelection);\nclass NodeBookmark {\n    constructor(anchor) {\n        this.anchor = anchor;\n    }\n    map(mapping) {\n        let { deleted, pos } = mapping.mapResult(this.anchor);\n        return deleted ? new TextBookmark(pos, pos) : new NodeBookmark(pos);\n    }\n    resolve(doc) {\n        let $pos = doc.resolve(this.anchor), node = $pos.nodeAfter;\n        if (node && NodeSelection.isSelectable(node))\n            return new NodeSelection($pos);\n        return Selection.near($pos);\n    }\n}\n/**\nA selection type that represents selecting the whole document\n(which can not necessarily be expressed with a text selection, when\nthere are for example leaf block nodes at the start or end of the\ndocument).\n*/\nclass AllSelection extends Selection {\n    /**\n    Create an all-selection over the given document.\n    */\n    constructor(doc) {\n        super(doc.resolve(0), doc.resolve(doc.content.size));\n    }\n    replace(tr, content = Slice.empty) {\n        if (content == Slice.empty) {\n            tr.delete(0, tr.doc.content.size);\n            let sel = Selection.atStart(tr.doc);\n            if (!sel.eq(tr.selection))\n                tr.setSelection(sel);\n        }\n        else {\n            super.replace(tr, content);\n        }\n    }\n    toJSON() { return { type: \"all\" }; }\n    /**\n    @internal\n    */\n    static fromJSON(doc) { return new AllSelection(doc); }\n    map(doc) { return new AllSelection(doc); }\n    eq(other) { return other instanceof AllSelection; }\n    getBookmark() { return AllBookmark; }\n}\nSelection.jsonID(\"all\", AllSelection);\nconst AllBookmark = {\n    map() { return this; },\n    resolve(doc) { return new AllSelection(doc); }\n};\n// FIXME we'll need some awareness of text direction when scanning for selections\n// Try to find a selection inside the given node. `pos` points at the\n// position where the search starts. When `text` is true, only return\n// text selections.\nfunction findSelectionIn(doc, node, pos, index, dir, text = false) {\n    if (node.inlineContent)\n        return TextSelection.create(doc, pos);\n    for (let i = index - (dir > 0 ? 0 : 1); dir > 0 ? i < node.childCount : i >= 0; i += dir) {\n        let child = node.child(i);\n        if (!child.isAtom) {\n            let inner = findSelectionIn(doc, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text);\n            if (inner)\n                return inner;\n        }\n        else if (!text && NodeSelection.isSelectable(child)) {\n            return NodeSelection.create(doc, pos - (dir < 0 ? child.nodeSize : 0));\n        }\n        pos += child.nodeSize * dir;\n    }\n    return null;\n}\nfunction selectionToInsertionEnd(tr, startLen, bias) {\n    let last = tr.steps.length - 1;\n    if (last < startLen)\n        return;\n    let step = tr.steps[last];\n    if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep))\n        return;\n    let map = tr.mapping.maps[last], end;\n    map.forEach((_from, _to, _newFrom, newTo) => { if (end == null)\n        end = newTo; });\n    tr.setSelection(Selection.near(tr.doc.resolve(end), bias));\n}\n\nconst UPDATED_SEL = 1, UPDATED_MARKS = 2, UPDATED_SCROLL = 4;\n/**\nAn editor state transaction, which can be applied to a state to\ncreate an updated state. Use\n[`EditorState.tr`](https://prosemirror.net/docs/ref/#state.EditorState.tr) to create an instance.\n\nTransactions track changes to the document (they are a subclass of\n[`Transform`](https://prosemirror.net/docs/ref/#transform.Transform)), but also other state changes,\nlike selection updates and adjustments of the set of [stored\nmarks](https://prosemirror.net/docs/ref/#state.EditorState.storedMarks). In addition, you can store\nmetadata properties in a transaction, which are extra pieces of\ninformation that client code or plugins can use to describe what a\ntransaction represents, so that they can update their [own\nstate](https://prosemirror.net/docs/ref/#state.StateField) accordingly.\n\nThe [editor view](https://prosemirror.net/docs/ref/#view.EditorView) uses a few metadata properties:\nit will attach a property `\"pointer\"` with the value `true` to\nselection transactions directly caused by mouse or touch input, and\na `\"uiEvent\"` property of that may be `\"paste\"`, `\"cut\"`, or `\"drop\"`.\n*/\nclass Transaction extends Transform {\n    /**\n    @internal\n    */\n    constructor(state) {\n        super(state.doc);\n        // The step count for which the current selection is valid.\n        this.curSelectionFor = 0;\n        // Bitfield to track which aspects of the state were updated by\n        // this transaction.\n        this.updated = 0;\n        // Object used to store metadata properties for the transaction.\n        this.meta = Object.create(null);\n        this.time = Date.now();\n        this.curSelection = state.selection;\n        this.storedMarks = state.storedMarks;\n    }\n    /**\n    The transaction's current selection. This defaults to the editor\n    selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the\n    transaction, but can be overwritten with\n    [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).\n    */\n    get selection() {\n        if (this.curSelectionFor < this.steps.length) {\n            this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));\n            this.curSelectionFor = this.steps.length;\n        }\n        return this.curSelection;\n    }\n    /**\n    Update the transaction's current selection. Will determine the\n    selection that the editor gets when the transaction is applied.\n    */\n    setSelection(selection) {\n        if (selection.$from.doc != this.doc)\n            throw new RangeError(\"Selection passed to setSelection must point at the current document\");\n        this.curSelection = selection;\n        this.curSelectionFor = this.steps.length;\n        this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS;\n        this.storedMarks = null;\n        return this;\n    }\n    /**\n    Whether the selection was explicitly updated by this transaction.\n    */\n    get selectionSet() {\n        return (this.updated & UPDATED_SEL) > 0;\n    }\n    /**\n    Set the current stored marks.\n    */\n    setStoredMarks(marks) {\n        this.storedMarks = marks;\n        this.updated |= UPDATED_MARKS;\n        return this;\n    }\n    /**\n    Make sure the current stored marks or, if that is null, the marks\n    at the selection, match the given set of marks. Does nothing if\n    this is already the case.\n    */\n    ensureMarks(marks) {\n        if (!Mark.sameSet(this.storedMarks || this.selection.$from.marks(), marks))\n            this.setStoredMarks(marks);\n        return this;\n    }\n    /**\n    Add a mark to the set of stored marks.\n    */\n    addStoredMark(mark) {\n        return this.ensureMarks(mark.addToSet(this.storedMarks || this.selection.$head.marks()));\n    }\n    /**\n    Remove a mark or mark type from the set of stored marks.\n    */\n    removeStoredMark(mark) {\n        return this.ensureMarks(mark.removeFromSet(this.storedMarks || this.selection.$head.marks()));\n    }\n    /**\n    Whether the stored marks were explicitly set for this transaction.\n    */\n    get storedMarksSet() {\n        return (this.updated & UPDATED_MARKS) > 0;\n    }\n    /**\n    @internal\n    */\n    addStep(step, doc) {\n        super.addStep(step, doc);\n        this.updated = this.updated & ~UPDATED_MARKS;\n        this.storedMarks = null;\n    }\n    /**\n    Update the timestamp for the transaction.\n    */\n    setTime(time) {\n        this.time = time;\n        return this;\n    }\n    /**\n    Replace the current selection with the given slice.\n    */\n    replaceSelection(slice) {\n        this.selection.replace(this, slice);\n        return this;\n    }\n    /**\n    Replace the selection with the given node. When `inheritMarks` is\n    true and the content is inline, it inherits the marks from the\n    place where it is inserted.\n    */\n    replaceSelectionWith(node, inheritMarks = true) {\n        let selection = this.selection;\n        if (inheritMarks)\n            node = node.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : (selection.$from.marksAcross(selection.$to) || Mark.none)));\n        selection.replaceWith(this, node);\n        return this;\n    }\n    /**\n    Delete the selection.\n    */\n    deleteSelection() {\n        this.selection.replace(this);\n        return this;\n    }\n    /**\n    Replace the given range, or the selection if no range is given,\n    with a text node containing the given string.\n    */\n    insertText(text, from, to) {\n        let schema = this.doc.type.schema;\n        if (from == null) {\n            if (!text)\n                return this.deleteSelection();\n            return this.replaceSelectionWith(schema.text(text), true);\n        }\n        else {\n            if (to == null)\n                to = from;\n            to = to == null ? from : to;\n            if (!text)\n                return this.deleteRange(from, to);\n            let marks = this.storedMarks;\n            if (!marks) {\n                let $from = this.doc.resolve(from);\n                marks = to == from ? $from.marks() : $from.marksAcross(this.doc.resolve(to));\n            }\n            this.replaceRangeWith(from, to, schema.text(text, marks));\n            if (!this.selection.empty)\n                this.setSelection(Selection.near(this.selection.$to));\n            return this;\n        }\n    }\n    /**\n    Store a metadata property in this transaction, keyed either by\n    name or by plugin.\n    */\n    setMeta(key, value) {\n        this.meta[typeof key == \"string\" ? key : key.key] = value;\n        return this;\n    }\n    /**\n    Retrieve a metadata property for a given name or plugin.\n    */\n    getMeta(key) {\n        return this.meta[typeof key == \"string\" ? key : key.key];\n    }\n    /**\n    Returns true if this transaction doesn't contain any metadata,\n    and can thus safely be extended.\n    */\n    get isGeneric() {\n        for (let _ in this.meta)\n            return false;\n        return true;\n    }\n    /**\n    Indicate that the editor should scroll the selection into view\n    when updated to the state produced by this transaction.\n    */\n    scrollIntoView() {\n        this.updated |= UPDATED_SCROLL;\n        return this;\n    }\n    /**\n    True when this transaction has had `scrollIntoView` called on it.\n    */\n    get scrolledIntoView() {\n        return (this.updated & UPDATED_SCROLL) > 0;\n    }\n}\n\nfunction bind(f, self) {\n    return !self || !f ? f : f.bind(self);\n}\nclass FieldDesc {\n    constructor(name, desc, self) {\n        this.name = name;\n        this.init = bind(desc.init, self);\n        this.apply = bind(desc.apply, self);\n    }\n}\nconst baseFields = [\n    new FieldDesc(\"doc\", {\n        init(config) { return config.doc || config.schema.topNodeType.createAndFill(); },\n        apply(tr) { return tr.doc; }\n    }),\n    new FieldDesc(\"selection\", {\n        init(config, instance) { return config.selection || Selection.atStart(instance.doc); },\n        apply(tr) { return tr.selection; }\n    }),\n    new FieldDesc(\"storedMarks\", {\n        init(config) { return config.storedMarks || null; },\n        apply(tr, _marks, _old, state) { return state.selection.$cursor ? tr.storedMarks : null; }\n    }),\n    new FieldDesc(\"scrollToSelection\", {\n        init() { return 0; },\n        apply(tr, prev) { return tr.scrolledIntoView ? prev + 1 : prev; }\n    })\n];\n// Object wrapping the part of a state object that stays the same\n// across transactions. Stored in the state's `config` property.\nclass Configuration {\n    constructor(schema, plugins) {\n        this.schema = schema;\n        this.plugins = [];\n        this.pluginsByKey = Object.create(null);\n        this.fields = baseFields.slice();\n        if (plugins)\n            plugins.forEach(plugin => {\n                if (this.pluginsByKey[plugin.key])\n                    throw new RangeError(\"Adding different instances of a keyed plugin (\" + plugin.key + \")\");\n                this.plugins.push(plugin);\n                this.pluginsByKey[plugin.key] = plugin;\n                if (plugin.spec.state)\n                    this.fields.push(new FieldDesc(plugin.key, plugin.spec.state, plugin));\n            });\n    }\n}\n/**\nThe state of a ProseMirror editor is represented by an object of\nthis type. A state is a persistent data structure—it isn't\nupdated, but rather a new state value is computed from an old one\nusing the [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) method.\n\nA state holds a number of built-in fields, and plugins can\n[define](https://prosemirror.net/docs/ref/#state.PluginSpec.state) additional fields.\n*/\nclass EditorState {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    @internal\n    */\n    config) {\n        this.config = config;\n    }\n    /**\n    The schema of the state's document.\n    */\n    get schema() {\n        return this.config.schema;\n    }\n    /**\n    The plugins that are active in this state.\n    */\n    get plugins() {\n        return this.config.plugins;\n    }\n    /**\n    Apply the given transaction to produce a new state.\n    */\n    apply(tr) {\n        return this.applyTransaction(tr).state;\n    }\n    /**\n    @ignore\n    */\n    filterTransaction(tr, ignore = -1) {\n        for (let i = 0; i < this.config.plugins.length; i++)\n            if (i != ignore) {\n                let plugin = this.config.plugins[i];\n                if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr, this))\n                    return false;\n            }\n        return true;\n    }\n    /**\n    Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that\n    returns the precise transactions that were applied (which might\n    be influenced by the [transaction\n    hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of\n    plugins) along with the new state.\n    */\n    applyTransaction(rootTr) {\n        if (!this.filterTransaction(rootTr))\n            return { state: this, transactions: [] };\n        let trs = [rootTr], newState = this.applyInner(rootTr), seen = null;\n        // This loop repeatedly gives plugins a chance to respond to\n        // transactions as new transactions are added, making sure to only\n        // pass the transactions the plugin did not see before.\n        for (;;) {\n            let haveNew = false;\n            for (let i = 0; i < this.config.plugins.length; i++) {\n                let plugin = this.config.plugins[i];\n                if (plugin.spec.appendTransaction) {\n                    let n = seen ? seen[i].n : 0, oldState = seen ? seen[i].state : this;\n                    let tr = n < trs.length &&\n                        plugin.spec.appendTransaction.call(plugin, n ? trs.slice(n) : trs, oldState, newState);\n                    if (tr && newState.filterTransaction(tr, i)) {\n                        tr.setMeta(\"appendedTransaction\", rootTr);\n                        if (!seen) {\n                            seen = [];\n                            for (let j = 0; j < this.config.plugins.length; j++)\n                                seen.push(j < i ? { state: newState, n: trs.length } : { state: this, n: 0 });\n                        }\n                        trs.push(tr);\n                        newState = newState.applyInner(tr);\n                        haveNew = true;\n                    }\n                    if (seen)\n                        seen[i] = { state: newState, n: trs.length };\n                }\n            }\n            if (!haveNew)\n                return { state: newState, transactions: trs };\n        }\n    }\n    /**\n    @internal\n    */\n    applyInner(tr) {\n        if (!tr.before.eq(this.doc))\n            throw new RangeError(\"Applying a mismatched transaction\");\n        let newInstance = new EditorState(this.config), fields = this.config.fields;\n        for (let i = 0; i < fields.length; i++) {\n            let field = fields[i];\n            newInstance[field.name] = field.apply(tr, this[field.name], this, newInstance);\n        }\n        return newInstance;\n    }\n    /**\n    Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.\n    */\n    get tr() { return new Transaction(this); }\n    /**\n    Create a new state.\n    */\n    static create(config) {\n        let $config = new Configuration(config.doc ? config.doc.type.schema : config.schema, config.plugins);\n        let instance = new EditorState($config);\n        for (let i = 0; i < $config.fields.length; i++)\n            instance[$config.fields[i].name] = $config.fields[i].init(config, instance);\n        return instance;\n    }\n    /**\n    Create a new state based on this one, but with an adjusted set\n    of active plugins. State fields that exist in both sets of\n    plugins are kept unchanged. Those that no longer exist are\n    dropped, and those that are new are initialized using their\n    [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new\n    configuration object..\n    */\n    reconfigure(config) {\n        let $config = new Configuration(this.schema, config.plugins);\n        let fields = $config.fields, instance = new EditorState($config);\n        for (let i = 0; i < fields.length; i++) {\n            let name = fields[i].name;\n            instance[name] = this.hasOwnProperty(name) ? this[name] : fields[i].init(config, instance);\n        }\n        return instance;\n    }\n    /**\n    Serialize this state to JSON. If you want to serialize the state\n    of plugins, pass an object mapping property names to use in the\n    resulting JSON object to plugin objects. The argument may also be\n    a string or number, in which case it is ignored, to support the\n    way `JSON.stringify` calls `toString` methods.\n    */\n    toJSON(pluginFields) {\n        let result = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };\n        if (this.storedMarks)\n            result.storedMarks = this.storedMarks.map(m => m.toJSON());\n        if (pluginFields && typeof pluginFields == 'object')\n            for (let prop in pluginFields) {\n                if (prop == \"doc\" || prop == \"selection\")\n                    throw new RangeError(\"The JSON fields `doc` and `selection` are reserved\");\n                let plugin = pluginFields[prop], state = plugin.spec.state;\n                if (state && state.toJSON)\n                    result[prop] = state.toJSON.call(plugin, this[plugin.key]);\n            }\n        return result;\n    }\n    /**\n    Deserialize a JSON representation of a state. `config` should\n    have at least a `schema` field, and should contain array of\n    plugins to initialize the state with. `pluginFields` can be used\n    to deserialize the state of plugins, by associating plugin\n    instances with the property names they use in the JSON object.\n    */\n    static fromJSON(config, json, pluginFields) {\n        if (!json)\n            throw new RangeError(\"Invalid input for EditorState.fromJSON\");\n        if (!config.schema)\n            throw new RangeError(\"Required config field 'schema' missing\");\n        let $config = new Configuration(config.schema, config.plugins);\n        let instance = new EditorState($config);\n        $config.fields.forEach(field => {\n            if (field.name == \"doc\") {\n                instance.doc = Node.fromJSON(config.schema, json.doc);\n            }\n            else if (field.name == \"selection\") {\n                instance.selection = Selection.fromJSON(instance.doc, json.selection);\n            }\n            else if (field.name == \"storedMarks\") {\n                if (json.storedMarks)\n                    instance.storedMarks = json.storedMarks.map(config.schema.markFromJSON);\n            }\n            else {\n                if (pluginFields)\n                    for (let prop in pluginFields) {\n                        let plugin = pluginFields[prop], state = plugin.spec.state;\n                        if (plugin.key == field.name && state && state.fromJSON &&\n                            Object.prototype.hasOwnProperty.call(json, prop)) {\n                            instance[field.name] = state.fromJSON.call(plugin, config, json[prop], instance);\n                            return;\n                        }\n                    }\n                instance[field.name] = field.init(config, instance);\n            }\n        });\n        return instance;\n    }\n}\n\nfunction bindProps(obj, self, target) {\n    for (let prop in obj) {\n        let val = obj[prop];\n        if (val instanceof Function)\n            val = val.bind(self);\n        else if (prop == \"handleDOMEvents\")\n            val = bindProps(val, self, {});\n        target[prop] = val;\n    }\n    return target;\n}\n/**\nPlugins bundle functionality that can be added to an editor.\nThey are part of the [editor state](https://prosemirror.net/docs/ref/#state.EditorState) and\nmay influence that state and the view that contains it.\n*/\nclass Plugin {\n    /**\n    Create a plugin.\n    */\n    constructor(\n    /**\n    The plugin's [spec object](https://prosemirror.net/docs/ref/#state.PluginSpec).\n    */\n    spec) {\n        this.spec = spec;\n        /**\n        The [props](https://prosemirror.net/docs/ref/#view.EditorProps) exported by this plugin.\n        */\n        this.props = {};\n        if (spec.props)\n            bindProps(spec.props, this, this.props);\n        this.key = spec.key ? spec.key.key : createKey(\"plugin\");\n    }\n    /**\n    Extract the plugin's state field from an editor state.\n    */\n    getState(state) { return state[this.key]; }\n}\nconst keys = Object.create(null);\nfunction createKey(name) {\n    if (name in keys)\n        return name + \"$\" + ++keys[name];\n    keys[name] = 0;\n    return name + \"$\";\n}\n/**\nA key is used to [tag](https://prosemirror.net/docs/ref/#state.PluginSpec.key) plugins in a way\nthat makes it possible to find them, given an editor state.\nAssigning a key does mean only one plugin of that type can be\nactive in a state.\n*/\nclass PluginKey {\n    /**\n    Create a plugin key.\n    */\n    constructor(name = \"key\") { this.key = createKey(name); }\n    /**\n    Get the active plugin with this key, if any, from an editor\n    state.\n    */\n    get(state) { return state.config.pluginsByKey[this.key]; }\n    /**\n    Get the plugin's state from an editor state.\n    */\n    getState(state) { return state[this.key]; }\n}\n\nexport { AllSelection, EditorState, NodeSelection, Plugin, PluginKey, Selection, SelectionRange, TextSelection, Transaction };\n","import RopeSequence from 'rope-sequence';\nimport { Mapping } from 'prosemirror-transform';\nimport { PluginKey, Plugin } from 'prosemirror-state';\n\n// ProseMirror's history isn't simply a way to roll back to a previous\n// state, because ProseMirror supports applying changes without adding\n// them to the history (for example during collaboration).\n//\n// To this end, each 'Branch' (one for the undo history and one for\n// the redo history) keeps an array of 'Items', which can optionally\n// hold a step (an actual undoable change), and always hold a position\n// map (which is needed to move changes below them to apply to the\n// current document).\n//\n// An item that has both a step and a selection bookmark is the start\n// of an 'event' — a group of changes that will be undone or redone at\n// once. (It stores only the bookmark, since that way we don't have to\n// provide a document until the selection is actually applied, which\n// is useful when compressing.)\n// Used to schedule history compression\nconst max_empty_items = 500;\nclass Branch {\n    constructor(items, eventCount) {\n        this.items = items;\n        this.eventCount = eventCount;\n    }\n    // Pop the latest event off the branch's history and apply it\n    // to a document transform.\n    popEvent(state, preserveItems) {\n        if (this.eventCount == 0)\n            return null;\n        let end = this.items.length;\n        for (;; end--) {\n            let next = this.items.get(end - 1);\n            if (next.selection) {\n                --end;\n                break;\n            }\n        }\n        let remap, mapFrom;\n        if (preserveItems) {\n            remap = this.remapping(end, this.items.length);\n            mapFrom = remap.maps.length;\n        }\n        let transform = state.tr;\n        let selection, remaining;\n        let addAfter = [], addBefore = [];\n        this.items.forEach((item, i) => {\n            if (!item.step) {\n                if (!remap) {\n                    remap = this.remapping(end, i + 1);\n                    mapFrom = remap.maps.length;\n                }\n                mapFrom--;\n                addBefore.push(item);\n                return;\n            }\n            if (remap) {\n                addBefore.push(new Item(item.map));\n                let step = item.step.map(remap.slice(mapFrom)), map;\n                if (step && transform.maybeStep(step).doc) {\n                    map = transform.mapping.maps[transform.mapping.maps.length - 1];\n                    addAfter.push(new Item(map, undefined, undefined, addAfter.length + addBefore.length));\n                }\n                mapFrom--;\n                if (map)\n                    remap.appendMap(map, mapFrom);\n            }\n            else {\n                transform.maybeStep(item.step);\n            }\n            if (item.selection) {\n                selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;\n                remaining = new Branch(this.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), this.eventCount - 1);\n                return false;\n            }\n        }, this.items.length, 0);\n        return { remaining: remaining, transform, selection: selection };\n    }\n    // Create a new branch with the given transform added.\n    addTransform(transform, selection, histOptions, preserveItems) {\n        let newItems = [], eventCount = this.eventCount;\n        let oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;\n        for (let i = 0; i < transform.steps.length; i++) {\n            let step = transform.steps[i].invert(transform.docs[i]);\n            let item = new Item(transform.mapping.maps[i], step, selection), merged;\n            if (merged = lastItem && lastItem.merge(item)) {\n                item = merged;\n                if (i)\n                    newItems.pop();\n                else\n                    oldItems = oldItems.slice(0, oldItems.length - 1);\n            }\n            newItems.push(item);\n            if (selection) {\n                eventCount++;\n                selection = undefined;\n            }\n            if (!preserveItems)\n                lastItem = item;\n        }\n        let overflow = eventCount - histOptions.depth;\n        if (overflow > DEPTH_OVERFLOW) {\n            oldItems = cutOffEvents(oldItems, overflow);\n            eventCount -= overflow;\n        }\n        return new Branch(oldItems.append(newItems), eventCount);\n    }\n    remapping(from, to) {\n        let maps = new Mapping;\n        this.items.forEach((item, i) => {\n            let mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from\n                ? maps.maps.length - item.mirrorOffset : undefined;\n            maps.appendMap(item.map, mirrorPos);\n        }, from, to);\n        return maps;\n    }\n    addMaps(array) {\n        if (this.eventCount == 0)\n            return this;\n        return new Branch(this.items.append(array.map(map => new Item(map))), this.eventCount);\n    }\n    // When the collab module receives remote changes, the history has\n    // to know about those, so that it can adjust the steps that were\n    // rebased on top of the remote changes, and include the position\n    // maps for the remote changes in its array of items.\n    rebased(rebasedTransform, rebasedCount) {\n        if (!this.eventCount)\n            return this;\n        let rebasedItems = [], start = Math.max(0, this.items.length - rebasedCount);\n        let mapping = rebasedTransform.mapping;\n        let newUntil = rebasedTransform.steps.length;\n        let eventCount = this.eventCount;\n        this.items.forEach(item => { if (item.selection)\n            eventCount--; }, start);\n        let iRebased = rebasedCount;\n        this.items.forEach(item => {\n            let pos = mapping.getMirror(--iRebased);\n            if (pos == null)\n                return;\n            newUntil = Math.min(newUntil, pos);\n            let map = mapping.maps[pos];\n            if (item.step) {\n                let step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);\n                let selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));\n                if (selection)\n                    eventCount++;\n                rebasedItems.push(new Item(map, step, selection));\n            }\n            else {\n                rebasedItems.push(new Item(map));\n            }\n        }, start);\n        let newMaps = [];\n        for (let i = rebasedCount; i < newUntil; i++)\n            newMaps.push(new Item(mapping.maps[i]));\n        let items = this.items.slice(0, start).append(newMaps).append(rebasedItems);\n        let branch = new Branch(items, eventCount);\n        if (branch.emptyItemCount() > max_empty_items)\n            branch = branch.compress(this.items.length - rebasedItems.length);\n        return branch;\n    }\n    emptyItemCount() {\n        let count = 0;\n        this.items.forEach(item => { if (!item.step)\n            count++; });\n        return count;\n    }\n    // Compressing a branch means rewriting it to push the air (map-only\n    // items) out. During collaboration, these naturally accumulate\n    // because each remote change adds one. The `upto` argument is used\n    // to ensure that only the items below a given level are compressed,\n    // because `rebased` relies on a clean, untouched set of items in\n    // order to associate old items with rebased steps.\n    compress(upto = this.items.length) {\n        let remap = this.remapping(0, upto), mapFrom = remap.maps.length;\n        let items = [], events = 0;\n        this.items.forEach((item, i) => {\n            if (i >= upto) {\n                items.push(item);\n                if (item.selection)\n                    events++;\n            }\n            else if (item.step) {\n                let step = item.step.map(remap.slice(mapFrom)), map = step && step.getMap();\n                mapFrom--;\n                if (map)\n                    remap.appendMap(map, mapFrom);\n                if (step) {\n                    let selection = item.selection && item.selection.map(remap.slice(mapFrom));\n                    if (selection)\n                        events++;\n                    let newItem = new Item(map.invert(), step, selection), merged, last = items.length - 1;\n                    if (merged = items.length && items[last].merge(newItem))\n                        items[last] = merged;\n                    else\n                        items.push(newItem);\n                }\n            }\n            else if (item.map) {\n                mapFrom--;\n            }\n        }, this.items.length, 0);\n        return new Branch(RopeSequence.from(items.reverse()), events);\n    }\n}\nBranch.empty = new Branch(RopeSequence.empty, 0);\nfunction cutOffEvents(items, n) {\n    let cutPoint;\n    items.forEach((item, i) => {\n        if (item.selection && (n-- == 0)) {\n            cutPoint = i;\n            return false;\n        }\n    });\n    return items.slice(cutPoint);\n}\nclass Item {\n    constructor(\n    // The (forward) step map for this item.\n    map, \n    // The inverted step\n    step, \n    // If this is non-null, this item is the start of a group, and\n    // this selection is the starting selection for the group (the one\n    // that was active before the first step was applied)\n    selection, \n    // If this item is the inverse of a previous mapping on the stack,\n    // this points at the inverse's offset\n    mirrorOffset) {\n        this.map = map;\n        this.step = step;\n        this.selection = selection;\n        this.mirrorOffset = mirrorOffset;\n    }\n    merge(other) {\n        if (this.step && other.step && !other.selection) {\n            let step = other.step.merge(this.step);\n            if (step)\n                return new Item(step.getMap().invert(), step, this.selection);\n        }\n    }\n}\n// The value of the state field that tracks undo/redo history for that\n// state. Will be stored in the plugin state when the history plugin\n// is active.\nclass HistoryState {\n    constructor(done, undone, prevRanges, prevTime) {\n        this.done = done;\n        this.undone = undone;\n        this.prevRanges = prevRanges;\n        this.prevTime = prevTime;\n    }\n}\nconst DEPTH_OVERFLOW = 20;\n// Record a transformation in undo history.\nfunction applyTransaction(history, state, tr, options) {\n    let historyTr = tr.getMeta(historyKey), rebased;\n    if (historyTr)\n        return historyTr.historyState;\n    if (tr.getMeta(closeHistoryKey))\n        history = new HistoryState(history.done, history.undone, null, 0);\n    let appended = tr.getMeta(\"appendedTransaction\");\n    if (tr.steps.length == 0) {\n        return history;\n    }\n    else if (appended && appended.getMeta(historyKey)) {\n        if (appended.getMeta(historyKey).redo)\n            return new HistoryState(history.done.addTransform(tr, undefined, options, mustPreserveItems(state)), history.undone, rangesFor(tr.mapping.maps[tr.steps.length - 1]), history.prevTime);\n        else\n            return new HistoryState(history.done, history.undone.addTransform(tr, undefined, options, mustPreserveItems(state)), null, history.prevTime);\n    }\n    else if (tr.getMeta(\"addToHistory\") !== false && !(appended && appended.getMeta(\"addToHistory\") === false)) {\n        // Group transforms that occur in quick succession into one event.\n        let newGroup = history.prevTime == 0 || !appended && (history.prevTime < (tr.time || 0) - options.newGroupDelay ||\n            !isAdjacentTo(tr, history.prevRanges));\n        let prevRanges = appended ? mapRanges(history.prevRanges, tr.mapping) : rangesFor(tr.mapping.maps[tr.steps.length - 1]);\n        return new HistoryState(history.done.addTransform(tr, newGroup ? state.selection.getBookmark() : undefined, options, mustPreserveItems(state)), Branch.empty, prevRanges, tr.time);\n    }\n    else if (rebased = tr.getMeta(\"rebased\")) {\n        // Used by the collab module to tell the history that some of its\n        // content has been rebased.\n        return new HistoryState(history.done.rebased(tr, rebased), history.undone.rebased(tr, rebased), mapRanges(history.prevRanges, tr.mapping), history.prevTime);\n    }\n    else {\n        return new HistoryState(history.done.addMaps(tr.mapping.maps), history.undone.addMaps(tr.mapping.maps), mapRanges(history.prevRanges, tr.mapping), history.prevTime);\n    }\n}\nfunction isAdjacentTo(transform, prevRanges) {\n    if (!prevRanges)\n        return false;\n    if (!transform.docChanged)\n        return true;\n    let adjacent = false;\n    transform.mapping.maps[0].forEach((start, end) => {\n        for (let i = 0; i < prevRanges.length; i += 2)\n            if (start <= prevRanges[i + 1] && end >= prevRanges[i])\n                adjacent = true;\n    });\n    return adjacent;\n}\nfunction rangesFor(map) {\n    let result = [];\n    map.forEach((_from, _to, from, to) => result.push(from, to));\n    return result;\n}\nfunction mapRanges(ranges, mapping) {\n    if (!ranges)\n        return null;\n    let result = [];\n    for (let i = 0; i < ranges.length; i += 2) {\n        let from = mapping.map(ranges[i], 1), to = mapping.map(ranges[i + 1], -1);\n        if (from <= to)\n            result.push(from, to);\n    }\n    return result;\n}\n// Apply the latest event from one branch to the document and shift the event\n// onto the other branch.\nfunction histTransaction(history, state, dispatch, redo) {\n    let preserveItems = mustPreserveItems(state);\n    let histOptions = historyKey.get(state).spec.config;\n    let pop = (redo ? history.undone : history.done).popEvent(state, preserveItems);\n    if (!pop)\n        return;\n    let selection = pop.selection.resolve(pop.transform.doc);\n    let added = (redo ? history.done : history.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);\n    let newHist = new HistoryState(redo ? added : pop.remaining, redo ? pop.remaining : added, null, 0);\n    dispatch(pop.transform.setSelection(selection).setMeta(historyKey, { redo, historyState: newHist }).scrollIntoView());\n}\nlet cachedPreserveItems = false, cachedPreserveItemsPlugins = null;\n// Check whether any plugin in the given state has a\n// `historyPreserveItems` property in its spec, in which case we must\n// preserve steps exactly as they came in, so that they can be\n// rebased.\nfunction mustPreserveItems(state) {\n    let plugins = state.plugins;\n    if (cachedPreserveItemsPlugins != plugins) {\n        cachedPreserveItems = false;\n        cachedPreserveItemsPlugins = plugins;\n        for (let i = 0; i < plugins.length; i++)\n            if (plugins[i].spec.historyPreserveItems) {\n                cachedPreserveItems = true;\n                break;\n            }\n    }\n    return cachedPreserveItems;\n}\n/**\nSet a flag on the given transaction that will prevent further steps\nfrom being appended to an existing history event (so that they\nrequire a separate undo command to undo).\n*/\nfunction closeHistory(tr) {\n    return tr.setMeta(closeHistoryKey, true);\n}\nconst historyKey = new PluginKey(\"history\");\nconst closeHistoryKey = new PluginKey(\"closeHistory\");\n/**\nReturns a plugin that enables the undo history for an editor. The\nplugin will track undo and redo stacks, which can be used with the\n[`undo`](https://prosemirror.net/docs/ref/#history.undo) and [`redo`](https://prosemirror.net/docs/ref/#history.redo) commands.\n\nYou can set an `\"addToHistory\"` [metadata\nproperty](https://prosemirror.net/docs/ref/#state.Transaction.setMeta) of `false` on a transaction\nto prevent it from being rolled back by undo.\n*/\nfunction history(config = {}) {\n    config = { depth: config.depth || 100,\n        newGroupDelay: config.newGroupDelay || 500 };\n    return new Plugin({\n        key: historyKey,\n        state: {\n            init() {\n                return new HistoryState(Branch.empty, Branch.empty, null, 0);\n            },\n            apply(tr, hist, state) {\n                return applyTransaction(hist, state, tr, config);\n            }\n        },\n        config,\n        props: {\n            handleDOMEvents: {\n                beforeinput(view, e) {\n                    let inputType = e.inputType;\n                    let command = inputType == \"historyUndo\" ? undo : inputType == \"historyRedo\" ? redo : null;\n                    if (!command)\n                        return false;\n                    e.preventDefault();\n                    return command(view.state, view.dispatch);\n                }\n            }\n        }\n    });\n}\n/**\nA command function that undoes the last change, if any.\n*/\nconst undo = (state, dispatch) => {\n    let hist = historyKey.getState(state);\n    if (!hist || hist.done.eventCount == 0)\n        return false;\n    if (dispatch)\n        histTransaction(hist, state, dispatch, false);\n    return true;\n};\n/**\nA command function that redoes the last undone change, if any.\n*/\nconst redo = (state, dispatch) => {\n    let hist = historyKey.getState(state);\n    if (!hist || hist.undone.eventCount == 0)\n        return false;\n    if (dispatch)\n        histTransaction(hist, state, dispatch, true);\n    return true;\n};\n/**\nThe amount of undoable events available in a given state.\n*/\nfunction undoDepth(state) {\n    let hist = historyKey.getState(state);\n    return hist ? hist.done.eventCount : 0;\n}\n/**\nThe amount of redoable events available in a given editor state.\n*/\nfunction redoDepth(state) {\n    let hist = historyKey.getState(state);\n    return hist ? hist.undone.eventCount : 0;\n}\n\nexport { closeHistory, history, redo, redoDepth, undo, undoDepth };\n","import { Extension } from '@tiptap/core';\nimport { undo, redo, history } from 'prosemirror-history';\n\nconst History = Extension.create({\r\n    name: 'history',\r\n    addOptions() {\r\n        return {\r\n            depth: 100,\r\n            newGroupDelay: 500,\r\n        };\r\n    },\r\n    addCommands() {\r\n        return {\r\n            undo: () => ({ state, dispatch }) => {\r\n                return undo(state, dispatch);\r\n            },\r\n            redo: () => ({ state, dispatch }) => {\r\n                return redo(state, dispatch);\r\n            },\r\n        };\r\n    },\r\n    addProseMirrorPlugins() {\r\n        return [\r\n            history(this.options),\r\n        ];\r\n    },\r\n    addKeyboardShortcuts() {\r\n        return {\r\n            'Mod-z': () => this.editor.commands.undo(),\r\n            'Mod-y': () => this.editor.commands.redo(),\r\n            'Shift-Mod-z': () => this.editor.commands.redo(),\r\n            // Russian keyboard layouts\r\n            'Mod-я': () => this.editor.commands.undo(),\r\n            'Shift-Mod-я': () => this.editor.commands.redo(),\r\n        };\r\n    },\r\n});\n\nexport { History, History as default };\n//# sourceMappingURL=tiptap-extension-history.esm.js.map\n"],"names":["GOOD_LEAF_SIZE","RopeSequence","prototype","append","other","length","from","this","leafAppend","leafPrepend","appendInner","prepend","Append","slice","to","empty","sliceInner","Math","max","min","get","i","getInner","forEach","f","forEachInner","forEachInvertedInner","map","result","elt","push","values","Leaf","call","__proto__","Object","create","constructor","prototypeAccessors","configurable","depth","flatten","start","concat","defineProperties","left","right","leftLen","inner","classesById","Selection","$anchor","$head","ranges","SelectionRange","anchor","pos","head","$from","$to","content","doc","replace","tr","lastNode","lastChild","lastParent","openEnd","mapFrom","steps","mapping","replaceRange","selectionToInsertionEnd","isInline","isTextblock","replaceWith","node","deleteRange","replaceRangeWith","static","$pos","dir","textOnly","parent","inlineContent","TextSelection","findSelectionIn","index","found","before","after","bias","findFrom","AllSelection","size","childCount","json","type","RangeError","cls","fromJSON","id","selectionClass","jsonID","getBookmark","between","visible","warnedAboutTextSelection","checkTextSelection","console","name","super","$cursor","resolve","near","marks","marksAcross","ensureMarks","eq","TextBookmark","toJSON","dPos","NodeSelection","nodeAfter","$end","nodeSize","deleted","mapResult","NodeBookmark","isText","spec","selectable","isSelectable","delete","sel","atStart","selection","setSelection","AllBookmark","text","child","isAtom","startLen","last","end","step","maps","_from","_to","_newFrom","newTo","bind","self","FieldDesc","desc","init","apply","config","schema","topNodeType","createAndFill","instance","storedMarks","_marks","_old","state","prev","scrolledIntoView","bindProps","obj","target","prop","val","Function","Plugin","props","key","createKey","getState","keys","PluginKey","pluginsByKey","Branch","items","eventCount","popEvent","preserveItems","remap","remapping","remaining","transform","addAfter","addBefore","item","Item","maybeStep","undefined","appendMap","reverse","addTransform","histOptions","newItems","oldItems","lastItem","merged","invert","docs","merge","pop","overflow","DEPTH_OVERFLOW","n","cutPoint","cutOffEvents","mirrorPos","mirrorOffset","addMaps","array","rebased","rebasedTransform","rebasedCount","rebasedItems","newUntil","iRebased","getMirror","newMaps","branch","emptyItemCount","compress","count","upto","events","getMap","newItem","HistoryState","done","undone","prevRanges","prevTime","rangesFor","mapRanges","histTransaction","history","dispatch","redo","mustPreserveItems","historyKey","added","newHist","setMeta","historyState","scrollIntoView","cachedPreserveItems","cachedPreserveItemsPlugins","plugins","historyPreserveItems","closeHistoryKey","newGroupDelay","hist","options","historyTr","getMeta","appended","newGroup","time","docChanged","adjacent","isAdjacentTo","applyTransaction","handleDOMEvents","beforeinput","view","e","inputType","command","undo","preventDefault","History","Extension","addOptions","addCommands","addProseMirrorPlugins","addKeyboardShortcuts","editor","commands"],"sourceRoot":""}