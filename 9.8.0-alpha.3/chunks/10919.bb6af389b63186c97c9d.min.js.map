{"version":3,"file":"chunks/10919.bb6af389b63186c97c9d.min.js","mappings":"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","sources":["webpack://@patternslib/patternslib/./node_modules/@patternslib/pat-tiptap/node_modules/@tiptap/extension-table/dist/tiptap-extension-table.esm.js"],"sourcesContent":["import { findParentNodeClosestToPos, Node, mergeAttributes, callOrReturn, getExtensionField } from '@tiptap/core';\nimport { PluginKey, Selection, TextSelection, Plugin, SelectionRange, NodeSelection } from 'prosemirror-state';\nimport { Slice, Fragment, Mark, MarkType, ReplaceError } from 'prosemirror-model';\nimport { Decoration, DecorationSet } from 'prosemirror-view';\n\nvar base = {\n  8: \"Backspace\",\n  9: \"Tab\",\n  10: \"Enter\",\n  12: \"NumLock\",\n  13: \"Enter\",\n  16: \"Shift\",\n  17: \"Control\",\n  18: \"Alt\",\n  20: \"CapsLock\",\n  27: \"Escape\",\n  32: \" \",\n  33: \"PageUp\",\n  34: \"PageDown\",\n  35: \"End\",\n  36: \"Home\",\n  37: \"ArrowLeft\",\n  38: \"ArrowUp\",\n  39: \"ArrowRight\",\n  40: \"ArrowDown\",\n  44: \"PrintScreen\",\n  45: \"Insert\",\n  46: \"Delete\",\n  59: \";\",\n  61: \"=\",\n  91: \"Meta\",\n  92: \"Meta\",\n  106: \"*\",\n  107: \"+\",\n  108: \",\",\n  109: \"-\",\n  110: \".\",\n  111: \"/\",\n  144: \"NumLock\",\n  145: \"ScrollLock\",\n  160: \"Shift\",\n  161: \"Shift\",\n  162: \"Control\",\n  163: \"Control\",\n  164: \"Alt\",\n  165: \"Alt\",\n  173: \"-\",\n  186: \";\",\n  187: \"=\",\n  188: \",\",\n  189: \"-\",\n  190: \".\",\n  191: \"/\",\n  192: \"`\",\n  219: \"[\",\n  220: \"\\\\\",\n  221: \"]\",\n  222: \"'\",\n  229: \"q\"\n};\n\nvar shift = {\n  48: \")\",\n  49: \"!\",\n  50: \"@\",\n  51: \"#\",\n  52: \"$\",\n  53: \"%\",\n  54: \"^\",\n  55: \"&\",\n  56: \"*\",\n  57: \"(\",\n  59: \":\",\n  61: \"+\",\n  173: \"_\",\n  186: \":\",\n  187: \"+\",\n  188: \"<\",\n  189: \"_\",\n  190: \">\",\n  191: \"?\",\n  192: \"~\",\n  219: \"{\",\n  220: \"|\",\n  221: \"}\",\n  222: \"\\\"\",\n  229: \"Q\"\n};\n\nvar chrome = typeof navigator != \"undefined\" && /Chrome\\/(\\d+)/.exec(navigator.userAgent);\nvar safari = typeof navigator != \"undefined\" && /Apple Computer/.test(navigator.vendor);\nvar gecko = typeof navigator != \"undefined\" && /Gecko\\/\\d+/.test(navigator.userAgent);\nvar mac$1 = typeof navigator != \"undefined\" && /Mac/.test(navigator.platform);\nvar ie = typeof navigator != \"undefined\" && /MSIE \\d|Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(navigator.userAgent);\nvar brokenModifierNames = chrome && (mac$1 || +chrome[1] < 57) || gecko && mac$1;\n\n// Fill in the digit keys\nfor (var i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i);\n\n// The function keys\nfor (var i = 1; i <= 24; i++) base[i + 111] = \"F\" + i;\n\n// And the alphabetic keys\nfor (var i = 65; i <= 90; i++) {\n  base[i] = String.fromCharCode(i + 32);\n  shift[i] = String.fromCharCode(i);\n}\n\n// For each code that doesn't have a shift-equivalent, copy the base name\nfor (var code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code];\n\nfunction keyName(event) {\n  // Don't trust event.key in Chrome when there are modifiers until\n  // they fix https://bugs.chromium.org/p/chromium/issues/detail?id=633838\n  var ignoreKey = brokenModifierNames && (event.ctrlKey || event.altKey || event.metaKey) ||\n    (safari || ie) && event.shiftKey && event.key && event.key.length == 1;\n  var name = (!ignoreKey && event.key) ||\n    (event.shiftKey ? shift : base)[event.keyCode] ||\n    event.key || \"Unidentified\";\n  // Edge sometimes produces wrong names (Issue #3)\n  if (name == \"Esc\") name = \"Escape\";\n  if (name == \"Del\") name = \"Delete\";\n  // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8860571/\n  if (name == \"Left\") name = \"ArrowLeft\";\n  if (name == \"Up\") name = \"ArrowUp\";\n  if (name == \"Right\") name = \"ArrowRight\";\n  if (name == \"Down\") name = \"ArrowDown\";\n  return name\n}\n\nconst mac = typeof navigator != \"undefined\" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : false;\nfunction normalizeKeyName(name) {\n    let parts = name.split(/-(?!$)/), result = parts[parts.length - 1];\n    if (result == \"Space\")\n        result = \" \";\n    let alt, ctrl, shift, meta;\n    for (let i = 0; i < parts.length - 1; i++) {\n        let mod = parts[i];\n        if (/^(cmd|meta|m)$/i.test(mod))\n            meta = true;\n        else if (/^a(lt)?$/i.test(mod))\n            alt = true;\n        else if (/^(c|ctrl|control)$/i.test(mod))\n            ctrl = true;\n        else if (/^s(hift)?$/i.test(mod))\n            shift = true;\n        else if (/^mod$/i.test(mod)) {\n            if (mac)\n                meta = true;\n            else\n                ctrl = true;\n        }\n        else\n            throw new Error(\"Unrecognized modifier name: \" + mod);\n    }\n    if (alt)\n        result = \"Alt-\" + result;\n    if (ctrl)\n        result = \"Ctrl-\" + result;\n    if (meta)\n        result = \"Meta-\" + result;\n    if (shift)\n        result = \"Shift-\" + result;\n    return result;\n}\nfunction normalize(map) {\n    let copy = Object.create(null);\n    for (let prop in map)\n        copy[normalizeKeyName(prop)] = map[prop];\n    return copy;\n}\nfunction modifiers(name, event, shift) {\n    if (event.altKey)\n        name = \"Alt-\" + name;\n    if (event.ctrlKey)\n        name = \"Ctrl-\" + name;\n    if (event.metaKey)\n        name = \"Meta-\" + name;\n    if (shift !== false && event.shiftKey)\n        name = \"Shift-\" + name;\n    return name;\n}\n/**\nGiven a set of bindings (using the same format as\n[`keymap`](https://prosemirror.net/docs/ref/#keymap.keymap)), return a [keydown\nhandler](https://prosemirror.net/docs/ref/#view.EditorProps.handleKeyDown) that handles them.\n*/\nfunction keydownHandler(bindings) {\n    let map = normalize(bindings);\n    return function (view, event) {\n        let name = keyName(event), isChar = name.length == 1 && name != \" \", baseName;\n        let direct = map[modifiers(name, event, !isChar)];\n        if (direct && direct(view.state, view.dispatch, view))\n            return true;\n        if (isChar && (event.shiftKey || event.altKey || event.metaKey || name.charCodeAt(0) > 127) &&\n            (baseName = base[event.keyCode]) && baseName != name) {\n            // Try falling back to the keyCode when there's a modifier\n            // active or the character produced isn't ASCII, and our table\n            // produces a different name from the the keyCode. See #668,\n            // #1060\n            let fromCode = map[modifiers(baseName, event, true)];\n            if (fromCode && fromCode(view.state, view.dispatch, view))\n                return true;\n        }\n        else if (isChar && event.shiftKey) {\n            // Otherwise, if shift is active, also try the binding with the\n            // Shift- prefix enabled. See #997\n            let withShift = map[modifiers(name, event, true)];\n            if (withShift && withShift(view.state, view.dispatch, view))\n                return true;\n        }\n        return false;\n    };\n}\n\n// Recovery values encode a range index and an offset. They are\n// represented as numbers, because tons of them will be created when\n// mapping, for example, a large number of decorations. The number's\n// lower 16 bits provide the index, the remaining bits the offset.\n//\n// Note: We intentionally don't use bit shift operators to en- and\n// decode these, since those clip to 32 bits, which we might in rare\n// cases want to overflow. A 64-bit float can represent 48-bit\n// integers precisely.\nconst lower16 = 0xffff;\nconst factor16 = Math.pow(2, 16);\nfunction makeRecover(index, offset) { return index + offset * factor16; }\nfunction recoverIndex(value) { return value & lower16; }\nfunction recoverOffset(value) { return (value - (value & lower16)) / factor16; }\nconst DEL_BEFORE = 1, DEL_AFTER = 2, DEL_ACROSS = 4, DEL_SIDE = 8;\n/**\nAn object representing a mapped position with extra\ninformation.\n*/\nclass MapResult {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The mapped version of the position.\n    */\n    pos, \n    /**\n    @internal\n    */\n    delInfo, \n    /**\n    @internal\n    */\n    recover) {\n        this.pos = pos;\n        this.delInfo = delInfo;\n        this.recover = recover;\n    }\n    /**\n    Tells you whether the position was deleted, that is, whether the\n    step removed the token on the side queried (via the `assoc`)\n    argument from the document.\n    */\n    get deleted() { return (this.delInfo & DEL_SIDE) > 0; }\n    /**\n    Tells you whether the token before the mapped position was deleted.\n    */\n    get deletedBefore() { return (this.delInfo & (DEL_BEFORE | DEL_ACROSS)) > 0; }\n    /**\n    True when the token after the mapped position was deleted.\n    */\n    get deletedAfter() { return (this.delInfo & (DEL_AFTER | DEL_ACROSS)) > 0; }\n    /**\n    Tells whether any of the steps mapped through deletes across the\n    position (including both the token before and after the\n    position).\n    */\n    get deletedAcross() { return (this.delInfo & DEL_ACROSS) > 0; }\n}\n/**\nA map describing the deletions and insertions made by a step, which\ncan be used to find the correspondence between positions in the\npre-step version of a document and the same position in the\npost-step version.\n*/\nclass StepMap {\n    /**\n    Create a position map. The modifications to the document are\n    represented as an array of numbers, in which each group of three\n    represents a modified chunk as `[start, oldSize, newSize]`.\n    */\n    constructor(\n    /**\n    @internal\n    */\n    ranges, \n    /**\n    @internal\n    */\n    inverted = false) {\n        this.ranges = ranges;\n        this.inverted = inverted;\n        if (!ranges.length && StepMap.empty)\n            return StepMap.empty;\n    }\n    /**\n    @internal\n    */\n    recover(value) {\n        let diff = 0, index = recoverIndex(value);\n        if (!this.inverted)\n            for (let i = 0; i < index; i++)\n                diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];\n        return this.ranges[index * 3] + diff + recoverOffset(value);\n    }\n    mapResult(pos, assoc = 1) { return this._map(pos, assoc, false); }\n    map(pos, assoc = 1) { return this._map(pos, assoc, true); }\n    /**\n    @internal\n    */\n    _map(pos, assoc, simple) {\n        let diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;\n        for (let i = 0; i < this.ranges.length; i += 3) {\n            let start = this.ranges[i] - (this.inverted ? diff : 0);\n            if (start > pos)\n                break;\n            let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex], end = start + oldSize;\n            if (pos <= end) {\n                let side = !oldSize ? assoc : pos == start ? -1 : pos == end ? 1 : assoc;\n                let result = start + diff + (side < 0 ? 0 : newSize);\n                if (simple)\n                    return result;\n                let recover = pos == (assoc < 0 ? start : end) ? null : makeRecover(i / 3, pos - start);\n                let del = pos == start ? DEL_AFTER : pos == end ? DEL_BEFORE : DEL_ACROSS;\n                if (assoc < 0 ? pos != start : pos != end)\n                    del |= DEL_SIDE;\n                return new MapResult(result, del, recover);\n            }\n            diff += newSize - oldSize;\n        }\n        return simple ? pos + diff : new MapResult(pos + diff, 0, null);\n    }\n    /**\n    @internal\n    */\n    touches(pos, recover) {\n        let diff = 0, index = recoverIndex(recover);\n        let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;\n        for (let i = 0; i < this.ranges.length; i += 3) {\n            let start = this.ranges[i] - (this.inverted ? diff : 0);\n            if (start > pos)\n                break;\n            let oldSize = this.ranges[i + oldIndex], end = start + oldSize;\n            if (pos <= end && i == index * 3)\n                return true;\n            diff += this.ranges[i + newIndex] - oldSize;\n        }\n        return false;\n    }\n    /**\n    Calls the given function on each of the changed ranges included in\n    this map.\n    */\n    forEach(f) {\n        let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;\n        for (let i = 0, diff = 0; i < this.ranges.length; i += 3) {\n            let start = this.ranges[i], oldStart = start - (this.inverted ? diff : 0), newStart = start + (this.inverted ? 0 : diff);\n            let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex];\n            f(oldStart, oldStart + oldSize, newStart, newStart + newSize);\n            diff += newSize - oldSize;\n        }\n    }\n    /**\n    Create an inverted version of this map. The result can be used to\n    map positions in the post-step document to the pre-step document.\n    */\n    invert() {\n        return new StepMap(this.ranges, !this.inverted);\n    }\n    /**\n    @internal\n    */\n    toString() {\n        return (this.inverted ? \"-\" : \"\") + JSON.stringify(this.ranges);\n    }\n    /**\n    Create a map that moves all positions by offset `n` (which may be\n    negative). This can be useful when applying steps meant for a\n    sub-document to a larger document, or vice-versa.\n    */\n    static offset(n) {\n        return n == 0 ? StepMap.empty : new StepMap(n < 0 ? [0, -n, 0] : [0, 0, n]);\n    }\n}\n/**\nA StepMap that contains no changed ranges.\n*/\nStepMap.empty = new StepMap([]);\n/**\nA mapping represents a pipeline of zero or more [step\nmaps](https://prosemirror.net/docs/ref/#transform.StepMap). It has special provisions for losslessly\nhandling mapping positions through a series of steps in which some\nsteps are inverted versions of earlier steps. (This comes up when\n‘[rebasing](/docs/guide/#transform.rebasing)’ steps for\ncollaboration or history management.)\n*/\nclass Mapping {\n    /**\n    Create a new mapping with the given position maps.\n    */\n    constructor(\n    /**\n    The step maps in this mapping.\n    */\n    maps = [], \n    /**\n    @internal\n    */\n    mirror, \n    /**\n    The starting position in the `maps` array, used when `map` or\n    `mapResult` is called.\n    */\n    from = 0, \n    /**\n    The end position in the `maps` array.\n    */\n    to = maps.length) {\n        this.maps = maps;\n        this.mirror = mirror;\n        this.from = from;\n        this.to = to;\n    }\n    /**\n    Create a mapping that maps only through a part of this one.\n    */\n    slice(from = 0, to = this.maps.length) {\n        return new Mapping(this.maps, this.mirror, from, to);\n    }\n    /**\n    @internal\n    */\n    copy() {\n        return new Mapping(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to);\n    }\n    /**\n    Add a step map to the end of this mapping. If `mirrors` is\n    given, it should be the index of the step map that is the mirror\n    image of this one.\n    */\n    appendMap(map, mirrors) {\n        this.to = this.maps.push(map);\n        if (mirrors != null)\n            this.setMirror(this.maps.length - 1, mirrors);\n    }\n    /**\n    Add all the step maps in a given mapping to this one (preserving\n    mirroring information).\n    */\n    appendMapping(mapping) {\n        for (let i = 0, startSize = this.maps.length; i < mapping.maps.length; i++) {\n            let mirr = mapping.getMirror(i);\n            this.appendMap(mapping.maps[i], mirr != null && mirr < i ? startSize + mirr : undefined);\n        }\n    }\n    /**\n    Finds the offset of the step map that mirrors the map at the\n    given offset, in this mapping (as per the second argument to\n    `appendMap`).\n    */\n    getMirror(n) {\n        if (this.mirror)\n            for (let i = 0; i < this.mirror.length; i++)\n                if (this.mirror[i] == n)\n                    return this.mirror[i + (i % 2 ? -1 : 1)];\n    }\n    /**\n    @internal\n    */\n    setMirror(n, m) {\n        if (!this.mirror)\n            this.mirror = [];\n        this.mirror.push(n, m);\n    }\n    /**\n    Append the inverse of the given mapping to this one.\n    */\n    appendMappingInverted(mapping) {\n        for (let i = mapping.maps.length - 1, totalSize = this.maps.length + mapping.maps.length; i >= 0; i--) {\n            let mirr = mapping.getMirror(i);\n            this.appendMap(mapping.maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : undefined);\n        }\n    }\n    /**\n    Create an inverted version of this mapping.\n    */\n    invert() {\n        let inverse = new Mapping;\n        inverse.appendMappingInverted(this);\n        return inverse;\n    }\n    /**\n    Map a position through this mapping.\n    */\n    map(pos, assoc = 1) {\n        if (this.mirror)\n            return this._map(pos, assoc, true);\n        for (let i = this.from; i < this.to; i++)\n            pos = this.maps[i].map(pos, assoc);\n        return pos;\n    }\n    /**\n    Map a position through this mapping, returning a mapping\n    result.\n    */\n    mapResult(pos, assoc = 1) { return this._map(pos, assoc, false); }\n    /**\n    @internal\n    */\n    _map(pos, assoc, simple) {\n        let delInfo = 0;\n        for (let i = this.from; i < this.to; i++) {\n            let map = this.maps[i], result = map.mapResult(pos, assoc);\n            if (result.recover != null) {\n                let corr = this.getMirror(i);\n                if (corr != null && corr > i && corr < this.to) {\n                    i = corr;\n                    pos = this.maps[corr].recover(result.recover);\n                    continue;\n                }\n            }\n            delInfo |= result.delInfo;\n            pos = result.pos;\n        }\n        return simple ? pos : new MapResult(pos, delInfo, null);\n    }\n}\n\nconst stepsByID = Object.create(null);\n/**\nA step object represents an atomic change. It generally applies\nonly to the document it was created for, since the positions\nstored in it will only make sense for that document.\n\nNew steps are defined by creating classes that extend `Step`,\noverriding the `apply`, `invert`, `map`, `getMap` and `fromJSON`\nmethods, and registering your class with a unique\nJSON-serialization identifier using\n[`Step.jsonID`](https://prosemirror.net/docs/ref/#transform.Step^jsonID).\n*/\nclass Step {\n    /**\n    Get the step map that represents the changes made by this step,\n    and which can be used to transform between positions in the old\n    and the new document.\n    */\n    getMap() { return StepMap.empty; }\n    /**\n    Try to merge this step with another one, to be applied directly\n    after it. Returns the merged step when possible, null if the\n    steps can't be merged.\n    */\n    merge(other) { return null; }\n    /**\n    Deserialize a step from its JSON representation. Will call\n    through to the step class' own implementation of this method.\n    */\n    static fromJSON(schema, json) {\n        if (!json || !json.stepType)\n            throw new RangeError(\"Invalid input for Step.fromJSON\");\n        let type = stepsByID[json.stepType];\n        if (!type)\n            throw new RangeError(`No step type ${json.stepType} defined`);\n        return type.fromJSON(schema, json);\n    }\n    /**\n    To be able to serialize steps to JSON, each step needs a string\n    ID to attach to its JSON representation. Use this method to\n    register an ID for your step classes. Try to pick something\n    that's unlikely to clash with steps from other modules.\n    */\n    static jsonID(id, stepClass) {\n        if (id in stepsByID)\n            throw new RangeError(\"Duplicate use of step JSON ID \" + id);\n        stepsByID[id] = stepClass;\n        stepClass.prototype.jsonID = id;\n        return stepClass;\n    }\n}\n/**\nThe result of [applying](https://prosemirror.net/docs/ref/#transform.Step.apply) a step. Contains either a\nnew document or a failure value.\n*/\nclass StepResult {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The transformed document, if successful.\n    */\n    doc, \n    /**\n    The failure message, if unsuccessful.\n    */\n    failed) {\n        this.doc = doc;\n        this.failed = failed;\n    }\n    /**\n    Create a successful step result.\n    */\n    static ok(doc) { return new StepResult(doc, null); }\n    /**\n    Create a failed step result.\n    */\n    static fail(message) { return new StepResult(null, message); }\n    /**\n    Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given\n    arguments. Create a successful result if it succeeds, and a\n    failed one if it throws a `ReplaceError`.\n    */\n    static fromReplace(doc, from, to, slice) {\n        try {\n            return StepResult.ok(doc.replace(from, to, slice));\n        }\n        catch (e) {\n            if (e instanceof ReplaceError)\n                return StepResult.fail(e.message);\n            throw e;\n        }\n    }\n}\n\nfunction mapFragment(fragment, f, parent) {\n    let mapped = [];\n    for (let i = 0; i < fragment.childCount; i++) {\n        let child = fragment.child(i);\n        if (child.content.size)\n            child = child.copy(mapFragment(child.content, f, child));\n        if (child.isInline)\n            child = f(child, parent, i);\n        mapped.push(child);\n    }\n    return Fragment.fromArray(mapped);\n}\n/**\nAdd a mark to all inline content between two positions.\n*/\nclass AddMarkStep extends Step {\n    /**\n    Create a mark step.\n    */\n    constructor(\n    /**\n    The start of the marked range.\n    */\n    from, \n    /**\n    The end of the marked range.\n    */\n    to, \n    /**\n    The mark to add.\n    */\n    mark) {\n        super();\n        this.from = from;\n        this.to = to;\n        this.mark = mark;\n    }\n    apply(doc) {\n        let oldSlice = doc.slice(this.from, this.to), $from = doc.resolve(this.from);\n        let parent = $from.node($from.sharedDepth(this.to));\n        let slice = new Slice(mapFragment(oldSlice.content, (node, parent) => {\n            if (!node.isAtom || !parent.type.allowsMarkType(this.mark.type))\n                return node;\n            return node.mark(this.mark.addToSet(node.marks));\n        }, parent), oldSlice.openStart, oldSlice.openEnd);\n        return StepResult.fromReplace(doc, this.from, this.to, slice);\n    }\n    invert() {\n        return new RemoveMarkStep(this.from, this.to, this.mark);\n    }\n    map(mapping) {\n        let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);\n        if (from.deleted && to.deleted || from.pos >= to.pos)\n            return null;\n        return new AddMarkStep(from.pos, to.pos, this.mark);\n    }\n    merge(other) {\n        if (other instanceof AddMarkStep &&\n            other.mark.eq(this.mark) &&\n            this.from <= other.to && this.to >= other.from)\n            return new AddMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);\n        return null;\n    }\n    toJSON() {\n        return { stepType: \"addMark\", mark: this.mark.toJSON(),\n            from: this.from, to: this.to };\n    }\n    /**\n    @internal\n    */\n    static fromJSON(schema, json) {\n        if (typeof json.from != \"number\" || typeof json.to != \"number\")\n            throw new RangeError(\"Invalid input for AddMarkStep.fromJSON\");\n        return new AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark));\n    }\n}\nStep.jsonID(\"addMark\", AddMarkStep);\n/**\nRemove a mark from all inline content between two positions.\n*/\nclass RemoveMarkStep extends Step {\n    /**\n    Create a mark-removing step.\n    */\n    constructor(\n    /**\n    The start of the unmarked range.\n    */\n    from, \n    /**\n    The end of the unmarked range.\n    */\n    to, \n    /**\n    The mark to remove.\n    */\n    mark) {\n        super();\n        this.from = from;\n        this.to = to;\n        this.mark = mark;\n    }\n    apply(doc) {\n        let oldSlice = doc.slice(this.from, this.to);\n        let slice = new Slice(mapFragment(oldSlice.content, node => {\n            return node.mark(this.mark.removeFromSet(node.marks));\n        }, doc), oldSlice.openStart, oldSlice.openEnd);\n        return StepResult.fromReplace(doc, this.from, this.to, slice);\n    }\n    invert() {\n        return new AddMarkStep(this.from, this.to, this.mark);\n    }\n    map(mapping) {\n        let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);\n        if (from.deleted && to.deleted || from.pos >= to.pos)\n            return null;\n        return new RemoveMarkStep(from.pos, to.pos, this.mark);\n    }\n    merge(other) {\n        if (other instanceof RemoveMarkStep &&\n            other.mark.eq(this.mark) &&\n            this.from <= other.to && this.to >= other.from)\n            return new RemoveMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);\n        return null;\n    }\n    toJSON() {\n        return { stepType: \"removeMark\", mark: this.mark.toJSON(),\n            from: this.from, to: this.to };\n    }\n    /**\n    @internal\n    */\n    static fromJSON(schema, json) {\n        if (typeof json.from != \"number\" || typeof json.to != \"number\")\n            throw new RangeError(\"Invalid input for RemoveMarkStep.fromJSON\");\n        return new RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark));\n    }\n}\nStep.jsonID(\"removeMark\", RemoveMarkStep);\n/**\nAdd a mark to a specific node.\n*/\nclass AddNodeMarkStep extends Step {\n    /**\n    Create a node mark step.\n    */\n    constructor(\n    /**\n    The position of the target node.\n    */\n    pos, \n    /**\n    The mark to add.\n    */\n    mark) {\n        super();\n        this.pos = pos;\n        this.mark = mark;\n    }\n    apply(doc) {\n        let node = doc.nodeAt(this.pos);\n        if (!node)\n            return StepResult.fail(\"No node at mark step's position\");\n        let updated = node.type.create(node.attrs, null, this.mark.addToSet(node.marks));\n        return StepResult.fromReplace(doc, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));\n    }\n    invert(doc) {\n        let node = doc.nodeAt(this.pos);\n        if (node) {\n            let newSet = this.mark.addToSet(node.marks);\n            if (newSet.length == node.marks.length) {\n                for (let i = 0; i < node.marks.length; i++)\n                    if (!node.marks[i].isInSet(newSet))\n                        return new AddNodeMarkStep(this.pos, node.marks[i]);\n                return new AddNodeMarkStep(this.pos, this.mark);\n            }\n        }\n        return new RemoveNodeMarkStep(this.pos, this.mark);\n    }\n    map(mapping) {\n        let pos = mapping.mapResult(this.pos, 1);\n        return pos.deletedAfter ? null : new AddNodeMarkStep(pos.pos, this.mark);\n    }\n    toJSON() {\n        return { stepType: \"addNodeMark\", pos: this.pos, mark: this.mark.toJSON() };\n    }\n    /**\n    @internal\n    */\n    static fromJSON(schema, json) {\n        if (typeof json.pos != \"number\")\n            throw new RangeError(\"Invalid input for AddNodeMarkStep.fromJSON\");\n        return new AddNodeMarkStep(json.pos, schema.markFromJSON(json.mark));\n    }\n}\nStep.jsonID(\"addNodeMark\", AddNodeMarkStep);\n/**\nRemove a mark from a specific node.\n*/\nclass RemoveNodeMarkStep extends Step {\n    /**\n    Create a mark-removing step.\n    */\n    constructor(\n    /**\n    The position of the target node.\n    */\n    pos, \n    /**\n    The mark to remove.\n    */\n    mark) {\n        super();\n        this.pos = pos;\n        this.mark = mark;\n    }\n    apply(doc) {\n        let node = doc.nodeAt(this.pos);\n        if (!node)\n            return StepResult.fail(\"No node at mark step's position\");\n        let updated = node.type.create(node.attrs, null, this.mark.removeFromSet(node.marks));\n        return StepResult.fromReplace(doc, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));\n    }\n    invert(doc) {\n        let node = doc.nodeAt(this.pos);\n        if (!node || !this.mark.isInSet(node.marks))\n            return this;\n        return new AddNodeMarkStep(this.pos, this.mark);\n    }\n    map(mapping) {\n        let pos = mapping.mapResult(this.pos, 1);\n        return pos.deletedAfter ? null : new RemoveNodeMarkStep(pos.pos, this.mark);\n    }\n    toJSON() {\n        return { stepType: \"removeNodeMark\", pos: this.pos, mark: this.mark.toJSON() };\n    }\n    /**\n    @internal\n    */\n    static fromJSON(schema, json) {\n        if (typeof json.pos != \"number\")\n            throw new RangeError(\"Invalid input for RemoveNodeMarkStep.fromJSON\");\n        return new RemoveNodeMarkStep(json.pos, schema.markFromJSON(json.mark));\n    }\n}\nStep.jsonID(\"removeNodeMark\", RemoveNodeMarkStep);\n\n/**\nReplace a part of the document with a slice of new content.\n*/\nclass ReplaceStep extends Step {\n    /**\n    The given `slice` should fit the 'gap' between `from` and\n    `to`—the depths must line up, and the surrounding nodes must be\n    able to be joined with the open sides of the slice. When\n    `structure` is true, the step will fail if the content between\n    from and to is not just a sequence of closing and then opening\n    tokens (this is to guard against rebased replace steps\n    overwriting something they weren't supposed to).\n    */\n    constructor(\n    /**\n    The start position of the replaced range.\n    */\n    from, \n    /**\n    The end position of the replaced range.\n    */\n    to, \n    /**\n    The slice to insert.\n    */\n    slice, \n    /**\n    @internal\n    */\n    structure = false) {\n        super();\n        this.from = from;\n        this.to = to;\n        this.slice = slice;\n        this.structure = structure;\n    }\n    apply(doc) {\n        if (this.structure && contentBetween(doc, this.from, this.to))\n            return StepResult.fail(\"Structure replace would overwrite content\");\n        return StepResult.fromReplace(doc, this.from, this.to, this.slice);\n    }\n    getMap() {\n        return new StepMap([this.from, this.to - this.from, this.slice.size]);\n    }\n    invert(doc) {\n        return new ReplaceStep(this.from, this.from + this.slice.size, doc.slice(this.from, this.to));\n    }\n    map(mapping) {\n        let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);\n        if (from.deletedAcross && to.deletedAcross)\n            return null;\n        return new ReplaceStep(from.pos, Math.max(from.pos, to.pos), this.slice);\n    }\n    merge(other) {\n        if (!(other instanceof ReplaceStep) || other.structure || this.structure)\n            return null;\n        if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {\n            let slice = this.slice.size + other.slice.size == 0 ? Slice.empty\n                : new Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);\n            return new ReplaceStep(this.from, this.to + (other.to - other.from), slice, this.structure);\n        }\n        else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {\n            let slice = this.slice.size + other.slice.size == 0 ? Slice.empty\n                : new Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);\n            return new ReplaceStep(other.from, this.to, slice, this.structure);\n        }\n        else {\n            return null;\n        }\n    }\n    toJSON() {\n        let json = { stepType: \"replace\", from: this.from, to: this.to };\n        if (this.slice.size)\n            json.slice = this.slice.toJSON();\n        if (this.structure)\n            json.structure = true;\n        return json;\n    }\n    /**\n    @internal\n    */\n    static fromJSON(schema, json) {\n        if (typeof json.from != \"number\" || typeof json.to != \"number\")\n            throw new RangeError(\"Invalid input for ReplaceStep.fromJSON\");\n        return new ReplaceStep(json.from, json.to, Slice.fromJSON(schema, json.slice), !!json.structure);\n    }\n}\nStep.jsonID(\"replace\", ReplaceStep);\n/**\nReplace a part of the document with a slice of content, but\npreserve a range of the replaced content by moving it into the\nslice.\n*/\nclass ReplaceAroundStep extends Step {\n    /**\n    Create a replace-around step with the given range and gap.\n    `insert` should be the point in the slice into which the content\n    of the gap should be moved. `structure` has the same meaning as\n    it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.\n    */\n    constructor(\n    /**\n    The start position of the replaced range.\n    */\n    from, \n    /**\n    The end position of the replaced range.\n    */\n    to, \n    /**\n    The start of preserved range.\n    */\n    gapFrom, \n    /**\n    The end of preserved range.\n    */\n    gapTo, \n    /**\n    The slice to insert.\n    */\n    slice, \n    /**\n    The position in the slice where the preserved range should be\n    inserted.\n    */\n    insert, \n    /**\n    @internal\n    */\n    structure = false) {\n        super();\n        this.from = from;\n        this.to = to;\n        this.gapFrom = gapFrom;\n        this.gapTo = gapTo;\n        this.slice = slice;\n        this.insert = insert;\n        this.structure = structure;\n    }\n    apply(doc) {\n        if (this.structure && (contentBetween(doc, this.from, this.gapFrom) ||\n            contentBetween(doc, this.gapTo, this.to)))\n            return StepResult.fail(\"Structure gap-replace would overwrite content\");\n        let gap = doc.slice(this.gapFrom, this.gapTo);\n        if (gap.openStart || gap.openEnd)\n            return StepResult.fail(\"Gap is not a flat range\");\n        let inserted = this.slice.insertAt(this.insert, gap.content);\n        if (!inserted)\n            return StepResult.fail(\"Content does not fit in gap\");\n        return StepResult.fromReplace(doc, this.from, this.to, inserted);\n    }\n    getMap() {\n        return new StepMap([this.from, this.gapFrom - this.from, this.insert,\n            this.gapTo, this.to - this.gapTo, this.slice.size - this.insert]);\n    }\n    invert(doc) {\n        let gap = this.gapTo - this.gapFrom;\n        return new ReplaceAroundStep(this.from, this.from + this.slice.size + gap, this.from + this.insert, this.from + this.insert + gap, doc.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);\n    }\n    map(mapping) {\n        let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);\n        let gapFrom = mapping.map(this.gapFrom, -1), gapTo = mapping.map(this.gapTo, 1);\n        if ((from.deletedAcross && to.deletedAcross) || gapFrom < from.pos || gapTo > to.pos)\n            return null;\n        return new ReplaceAroundStep(from.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);\n    }\n    toJSON() {\n        let json = { stepType: \"replaceAround\", from: this.from, to: this.to,\n            gapFrom: this.gapFrom, gapTo: this.gapTo, insert: this.insert };\n        if (this.slice.size)\n            json.slice = this.slice.toJSON();\n        if (this.structure)\n            json.structure = true;\n        return json;\n    }\n    /**\n    @internal\n    */\n    static fromJSON(schema, json) {\n        if (typeof json.from != \"number\" || typeof json.to != \"number\" ||\n            typeof json.gapFrom != \"number\" || typeof json.gapTo != \"number\" || typeof json.insert != \"number\")\n            throw new RangeError(\"Invalid input for ReplaceAroundStep.fromJSON\");\n        return new ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo, Slice.fromJSON(schema, json.slice), json.insert, !!json.structure);\n    }\n}\nStep.jsonID(\"replaceAround\", ReplaceAroundStep);\nfunction contentBetween(doc, from, to) {\n    let $from = doc.resolve(from), dist = to - from, depth = $from.depth;\n    while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {\n        depth--;\n        dist--;\n    }\n    if (dist > 0) {\n        let next = $from.node(depth).maybeChild($from.indexAfter(depth));\n        while (dist > 0) {\n            if (!next || next.isLeaf)\n                return true;\n            next = next.firstChild;\n            dist--;\n        }\n    }\n    return false;\n}\n\nfunction addMark(tr, from, to, mark) {\n    let removed = [], added = [];\n    let removing, adding;\n    tr.doc.nodesBetween(from, to, (node, pos, parent) => {\n        if (!node.isInline)\n            return;\n        let marks = node.marks;\n        if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {\n            let start = Math.max(pos, from), end = Math.min(pos + node.nodeSize, to);\n            let newSet = mark.addToSet(marks);\n            for (let i = 0; i < marks.length; i++) {\n                if (!marks[i].isInSet(newSet)) {\n                    if (removing && removing.to == start && removing.mark.eq(marks[i]))\n                        removing.to = end;\n                    else\n                        removed.push(removing = new RemoveMarkStep(start, end, marks[i]));\n                }\n            }\n            if (adding && adding.to == start)\n                adding.to = end;\n            else\n                added.push(adding = new AddMarkStep(start, end, mark));\n        }\n    });\n    removed.forEach(s => tr.step(s));\n    added.forEach(s => tr.step(s));\n}\nfunction removeMark(tr, from, to, mark) {\n    let matched = [], step = 0;\n    tr.doc.nodesBetween(from, to, (node, pos) => {\n        if (!node.isInline)\n            return;\n        step++;\n        let toRemove = null;\n        if (mark instanceof MarkType) {\n            let set = node.marks, found;\n            while (found = mark.isInSet(set)) {\n                (toRemove || (toRemove = [])).push(found);\n                set = found.removeFromSet(set);\n            }\n        }\n        else if (mark) {\n            if (mark.isInSet(node.marks))\n                toRemove = [mark];\n        }\n        else {\n            toRemove = node.marks;\n        }\n        if (toRemove && toRemove.length) {\n            let end = Math.min(pos + node.nodeSize, to);\n            for (let i = 0; i < toRemove.length; i++) {\n                let style = toRemove[i], found;\n                for (let j = 0; j < matched.length; j++) {\n                    let m = matched[j];\n                    if (m.step == step - 1 && style.eq(matched[j].style))\n                        found = m;\n                }\n                if (found) {\n                    found.to = end;\n                    found.step = step;\n                }\n                else {\n                    matched.push({ style, from: Math.max(pos, from), to: end, step });\n                }\n            }\n        }\n    });\n    matched.forEach(m => tr.step(new RemoveMarkStep(m.from, m.to, m.style)));\n}\nfunction clearIncompatible(tr, pos, parentType, match = parentType.contentMatch) {\n    let node = tr.doc.nodeAt(pos);\n    let delSteps = [], cur = pos + 1;\n    for (let i = 0; i < node.childCount; i++) {\n        let child = node.child(i), end = cur + child.nodeSize;\n        let allowed = match.matchType(child.type);\n        if (!allowed) {\n            delSteps.push(new ReplaceStep(cur, end, Slice.empty));\n        }\n        else {\n            match = allowed;\n            for (let j = 0; j < child.marks.length; j++)\n                if (!parentType.allowsMarkType(child.marks[j].type))\n                    tr.step(new RemoveMarkStep(cur, end, child.marks[j]));\n        }\n        cur = end;\n    }\n    if (!match.validEnd) {\n        let fill = match.fillBefore(Fragment.empty, true);\n        tr.replace(cur, cur, new Slice(fill, 0, 0));\n    }\n    for (let i = delSteps.length - 1; i >= 0; i--)\n        tr.step(delSteps[i]);\n}\nfunction lift(tr, range, target) {\n    let { $from, $to, depth } = range;\n    let gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1);\n    let start = gapStart, end = gapEnd;\n    let before = Fragment.empty, openStart = 0;\n    for (let d = depth, splitting = false; d > target; d--)\n        if (splitting || $from.index(d) > 0) {\n            splitting = true;\n            before = Fragment.from($from.node(d).copy(before));\n            openStart++;\n        }\n        else {\n            start--;\n        }\n    let after = Fragment.empty, openEnd = 0;\n    for (let d = depth, splitting = false; d > target; d--)\n        if (splitting || $to.after(d + 1) < $to.end(d)) {\n            splitting = true;\n            after = Fragment.from($to.node(d).copy(after));\n            openEnd++;\n        }\n        else {\n            end++;\n        }\n    tr.step(new ReplaceAroundStep(start, end, gapStart, gapEnd, new Slice(before.append(after), openStart, openEnd), before.size - openStart, true));\n}\nfunction wrap(tr, range, wrappers) {\n    let content = Fragment.empty;\n    for (let i = wrappers.length - 1; i >= 0; i--) {\n        if (content.size) {\n            let match = wrappers[i].type.contentMatch.matchFragment(content);\n            if (!match || !match.validEnd)\n                throw new RangeError(\"Wrapper type given to Transform.wrap does not form valid content of its parent wrapper\");\n        }\n        content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));\n    }\n    let start = range.start, end = range.end;\n    tr.step(new ReplaceAroundStep(start, end, start, end, new Slice(content, 0, 0), wrappers.length, true));\n}\nfunction setBlockType(tr, from, to, type, attrs) {\n    if (!type.isTextblock)\n        throw new RangeError(\"Type given to setBlockType should be a textblock\");\n    let mapFrom = tr.steps.length;\n    tr.doc.nodesBetween(from, to, (node, pos) => {\n        if (node.isTextblock && !node.hasMarkup(type, attrs) && canChangeType(tr.doc, tr.mapping.slice(mapFrom).map(pos), type)) {\n            // Ensure all markup that isn't allowed in the new node type is cleared\n            tr.clearIncompatible(tr.mapping.slice(mapFrom).map(pos, 1), type);\n            let mapping = tr.mapping.slice(mapFrom);\n            let startM = mapping.map(pos, 1), endM = mapping.map(pos + node.nodeSize, 1);\n            tr.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1, new Slice(Fragment.from(type.create(attrs, null, node.marks)), 0, 0), 1, true));\n            return false;\n        }\n    });\n}\nfunction canChangeType(doc, pos, type) {\n    let $pos = doc.resolve(pos), index = $pos.index();\n    return $pos.parent.canReplaceWith(index, index + 1, type);\n}\n/**\nChange the type, attributes, and/or marks of the node at `pos`.\nWhen `type` isn't given, the existing node type is preserved,\n*/\nfunction setNodeMarkup(tr, pos, type, attrs, marks) {\n    let node = tr.doc.nodeAt(pos);\n    if (!node)\n        throw new RangeError(\"No node at given position\");\n    if (!type)\n        type = node.type;\n    let newNode = type.create(attrs, null, marks || node.marks);\n    if (node.isLeaf)\n        return tr.replaceWith(pos, pos + node.nodeSize, newNode);\n    if (!type.validContent(node.content))\n        throw new RangeError(\"Invalid content for node type \" + type.name);\n    tr.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1, new Slice(Fragment.from(newNode), 0, 0), 1, true));\n}\nfunction split(tr, pos, depth = 1, typesAfter) {\n    let $pos = tr.doc.resolve(pos), before = Fragment.empty, after = Fragment.empty;\n    for (let d = $pos.depth, e = $pos.depth - depth, i = depth - 1; d > e; d--, i--) {\n        before = Fragment.from($pos.node(d).copy(before));\n        let typeAfter = typesAfter && typesAfter[i];\n        after = Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after));\n    }\n    tr.step(new ReplaceStep(pos, pos, new Slice(before.append(after), depth, depth), true));\n}\nfunction join(tr, pos, depth) {\n    let step = new ReplaceStep(pos - depth, pos + depth, Slice.empty, true);\n    tr.step(step);\n}\n/**\nTry to find a point where a node of the given type can be inserted\nnear `pos`, by searching up the node hierarchy when `pos` itself\nisn't a valid place but is at the start or end of a node. Return\nnull if no position was found.\n*/\nfunction insertPoint(doc, pos, nodeType) {\n    let $pos = doc.resolve(pos);\n    if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType))\n        return pos;\n    if ($pos.parentOffset == 0)\n        for (let d = $pos.depth - 1; d >= 0; d--) {\n            let index = $pos.index(d);\n            if ($pos.node(d).canReplaceWith(index, index, nodeType))\n                return $pos.before(d + 1);\n            if (index > 0)\n                return null;\n        }\n    if ($pos.parentOffset == $pos.parent.content.size)\n        for (let d = $pos.depth - 1; d >= 0; d--) {\n            let index = $pos.indexAfter(d);\n            if ($pos.node(d).canReplaceWith(index, index, nodeType))\n                return $pos.after(d + 1);\n            if (index < $pos.node(d).childCount)\n                return null;\n        }\n    return null;\n}\n\n/**\n‘Fit’ a slice into a given position in the document, producing a\n[step](https://prosemirror.net/docs/ref/#transform.Step) that inserts it. Will return null if\nthere's no meaningful way to insert the slice here, or inserting it\nwould be a no-op (an empty slice over an empty range).\n*/\nfunction replaceStep(doc, from, to = from, slice = Slice.empty) {\n    if (from == to && !slice.size)\n        return null;\n    let $from = doc.resolve(from), $to = doc.resolve(to);\n    // Optimization -- avoid work if it's obvious that it's not needed.\n    if (fitsTrivially($from, $to, slice))\n        return new ReplaceStep(from, to, slice);\n    return new Fitter($from, $to, slice).fit();\n}\nfunction fitsTrivially($from, $to, slice) {\n    return !slice.openStart && !slice.openEnd && $from.start() == $to.start() &&\n        $from.parent.canReplace($from.index(), $to.index(), slice.content);\n}\n// Algorithm for 'placing' the elements of a slice into a gap:\n//\n// We consider the content of each node that is open to the left to be\n// independently placeable. I.e. in <p(\"foo\"), p(\"bar\")>, when the\n// paragraph on the left is open, \"foo\" can be placed (somewhere on\n// the left side of the replacement gap) independently from p(\"bar\").\n//\n// This class tracks the state of the placement progress in the\n// following properties:\n//\n//  - `frontier` holds a stack of `{type, match}` objects that\n//    represent the open side of the replacement. It starts at\n//    `$from`, then moves forward as content is placed, and is finally\n//    reconciled with `$to`.\n//\n//  - `unplaced` is a slice that represents the content that hasn't\n//    been placed yet.\n//\n//  - `placed` is a fragment of placed content. Its open-start value\n//    is implicit in `$from`, and its open-end value in `frontier`.\nclass Fitter {\n    constructor($from, $to, unplaced) {\n        this.$from = $from;\n        this.$to = $to;\n        this.unplaced = unplaced;\n        this.frontier = [];\n        this.placed = Fragment.empty;\n        for (let i = 0; i <= $from.depth; i++) {\n            let node = $from.node(i);\n            this.frontier.push({\n                type: node.type,\n                match: node.contentMatchAt($from.indexAfter(i))\n            });\n        }\n        for (let i = $from.depth; i > 0; i--)\n            this.placed = Fragment.from($from.node(i).copy(this.placed));\n    }\n    get depth() { return this.frontier.length - 1; }\n    fit() {\n        // As long as there's unplaced content, try to place some of it.\n        // If that fails, either increase the open score of the unplaced\n        // slice, or drop nodes from it, and then try again.\n        while (this.unplaced.size) {\n            let fit = this.findFittable();\n            if (fit)\n                this.placeNodes(fit);\n            else\n                this.openMore() || this.dropNode();\n        }\n        // When there's inline content directly after the frontier _and_\n        // directly after `this.$to`, we must generate a `ReplaceAround`\n        // step that pulls that content into the node after the frontier.\n        // That means the fitting must be done to the end of the textblock\n        // node after `this.$to`, not `this.$to` itself.\n        let moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth;\n        let $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));\n        if (!$to)\n            return null;\n        // If closing to `$to` succeeded, create a step\n        let content = this.placed, openStart = $from.depth, openEnd = $to.depth;\n        while (openStart && openEnd && content.childCount == 1) { // Normalize by dropping open parent nodes\n            content = content.firstChild.content;\n            openStart--;\n            openEnd--;\n        }\n        let slice = new Slice(content, openStart, openEnd);\n        if (moveInline > -1)\n            return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice, placedSize);\n        if (slice.size || $from.pos != this.$to.pos) // Don't generate no-op steps\n            return new ReplaceStep($from.pos, $to.pos, slice);\n        return null;\n    }\n    // Find a position on the start spine of `this.unplaced` that has\n    // content that can be moved somewhere on the frontier. Returns two\n    // depths, one for the slice and one for the frontier.\n    findFittable() {\n        // Only try wrapping nodes (pass 2) after finding a place without\n        // wrapping failed.\n        for (let pass = 1; pass <= 2; pass++) {\n            for (let sliceDepth = this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {\n                let fragment, parent = null;\n                if (sliceDepth) {\n                    parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild;\n                    fragment = parent.content;\n                }\n                else {\n                    fragment = this.unplaced.content;\n                }\n                let first = fragment.firstChild;\n                for (let frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {\n                    let { type, match } = this.frontier[frontierDepth], wrap, inject = null;\n                    // In pass 1, if the next node matches, or there is no next\n                    // node but the parents look compatible, we've found a\n                    // place.\n                    if (pass == 1 && (first ? match.matchType(first.type) || (inject = match.fillBefore(Fragment.from(first), false))\n                        : parent && type.compatibleContent(parent.type)))\n                        return { sliceDepth, frontierDepth, parent, inject };\n                    // In pass 2, look for a set of wrapping nodes that make\n                    // `first` fit here.\n                    else if (pass == 2 && first && (wrap = match.findWrapping(first.type)))\n                        return { sliceDepth, frontierDepth, parent, wrap };\n                    // Don't continue looking further up if the parent node\n                    // would fit here.\n                    if (parent && match.matchType(parent.type))\n                        break;\n                }\n            }\n        }\n    }\n    openMore() {\n        let { content, openStart, openEnd } = this.unplaced;\n        let inner = contentAt(content, openStart);\n        if (!inner.childCount || inner.firstChild.isLeaf)\n            return false;\n        this.unplaced = new Slice(content, openStart + 1, Math.max(openEnd, inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0));\n        return true;\n    }\n    dropNode() {\n        let { content, openStart, openEnd } = this.unplaced;\n        let inner = contentAt(content, openStart);\n        if (inner.childCount <= 1 && openStart > 0) {\n            let openAtEnd = content.size - openStart <= openStart + inner.size;\n            this.unplaced = new Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1, openAtEnd ? openStart - 1 : openEnd);\n        }\n        else {\n            this.unplaced = new Slice(dropFromFragment(content, openStart, 1), openStart, openEnd);\n        }\n    }\n    // Move content from the unplaced slice at `sliceDepth` to the\n    // frontier node at `frontierDepth`. Close that frontier node when\n    // applicable.\n    placeNodes({ sliceDepth, frontierDepth, parent, inject, wrap }) {\n        while (this.depth > frontierDepth)\n            this.closeFrontierNode();\n        if (wrap)\n            for (let i = 0; i < wrap.length; i++)\n                this.openFrontierNode(wrap[i]);\n        let slice = this.unplaced, fragment = parent ? parent.content : slice.content;\n        let openStart = slice.openStart - sliceDepth;\n        let taken = 0, add = [];\n        let { match, type } = this.frontier[frontierDepth];\n        if (inject) {\n            for (let i = 0; i < inject.childCount; i++)\n                add.push(inject.child(i));\n            match = match.matchFragment(inject);\n        }\n        // Computes the amount of (end) open nodes at the end of the\n        // fragment. When 0, the parent is open, but no more. When\n        // negative, nothing is open.\n        let openEndCount = (fragment.size + sliceDepth) - (slice.content.size - slice.openEnd);\n        // Scan over the fragment, fitting as many child nodes as\n        // possible.\n        while (taken < fragment.childCount) {\n            let next = fragment.child(taken), matches = match.matchType(next.type);\n            if (!matches)\n                break;\n            taken++;\n            if (taken > 1 || openStart == 0 || next.content.size) { // Drop empty open nodes\n                match = matches;\n                add.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0, taken == fragment.childCount ? openEndCount : -1));\n            }\n        }\n        let toEnd = taken == fragment.childCount;\n        if (!toEnd)\n            openEndCount = -1;\n        this.placed = addToFragment(this.placed, frontierDepth, Fragment.from(add));\n        this.frontier[frontierDepth].match = match;\n        // If the parent types match, and the entire node was moved, and\n        // it's not open, close this frontier node right away.\n        if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1)\n            this.closeFrontierNode();\n        // Add new frontier nodes for any open nodes at the end.\n        for (let i = 0, cur = fragment; i < openEndCount; i++) {\n            let node = cur.lastChild;\n            this.frontier.push({ type: node.type, match: node.contentMatchAt(node.childCount) });\n            cur = node.content;\n        }\n        // Update `this.unplaced`. Drop the entire node from which we\n        // placed it we got to its end, otherwise just drop the placed\n        // nodes.\n        this.unplaced = !toEnd ? new Slice(dropFromFragment(slice.content, sliceDepth, taken), slice.openStart, slice.openEnd)\n            : sliceDepth == 0 ? Slice.empty\n                : new Slice(dropFromFragment(slice.content, sliceDepth - 1, 1), sliceDepth - 1, openEndCount < 0 ? slice.openEnd : sliceDepth - 1);\n    }\n    mustMoveInline() {\n        if (!this.$to.parent.isTextblock)\n            return -1;\n        let top = this.frontier[this.depth], level;\n        if (!top.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top.type, top.match, false) ||\n            (this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth))\n            return -1;\n        let { depth } = this.$to, after = this.$to.after(depth);\n        while (depth > 1 && after == this.$to.end(--depth))\n            ++after;\n        return after;\n    }\n    findCloseLevel($to) {\n        scan: for (let i = Math.min(this.depth, $to.depth); i >= 0; i--) {\n            let { match, type } = this.frontier[i];\n            let dropInner = i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1));\n            let fit = contentAfterFits($to, i, type, match, dropInner);\n            if (!fit)\n                continue;\n            for (let d = i - 1; d >= 0; d--) {\n                let { match, type } = this.frontier[d];\n                let matches = contentAfterFits($to, d, type, match, true);\n                if (!matches || matches.childCount)\n                    continue scan;\n            }\n            return { depth: i, fit, move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to };\n        }\n    }\n    close($to) {\n        let close = this.findCloseLevel($to);\n        if (!close)\n            return null;\n        while (this.depth > close.depth)\n            this.closeFrontierNode();\n        if (close.fit.childCount)\n            this.placed = addToFragment(this.placed, close.depth, close.fit);\n        $to = close.move;\n        for (let d = close.depth + 1; d <= $to.depth; d++) {\n            let node = $to.node(d), add = node.type.contentMatch.fillBefore(node.content, true, $to.index(d));\n            this.openFrontierNode(node.type, node.attrs, add);\n        }\n        return $to;\n    }\n    openFrontierNode(type, attrs = null, content) {\n        let top = this.frontier[this.depth];\n        top.match = top.match.matchType(type);\n        this.placed = addToFragment(this.placed, this.depth, Fragment.from(type.create(attrs, content)));\n        this.frontier.push({ type, match: type.contentMatch });\n    }\n    closeFrontierNode() {\n        let open = this.frontier.pop();\n        let add = open.match.fillBefore(Fragment.empty, true);\n        if (add.childCount)\n            this.placed = addToFragment(this.placed, this.frontier.length, add);\n    }\n}\nfunction dropFromFragment(fragment, depth, count) {\n    if (depth == 0)\n        return fragment.cutByIndex(count, fragment.childCount);\n    return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)));\n}\nfunction addToFragment(fragment, depth, content) {\n    if (depth == 0)\n        return fragment.append(content);\n    return fragment.replaceChild(fragment.childCount - 1, fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content)));\n}\nfunction contentAt(fragment, depth) {\n    for (let i = 0; i < depth; i++)\n        fragment = fragment.firstChild.content;\n    return fragment;\n}\nfunction closeNodeStart(node, openStart, openEnd) {\n    if (openStart <= 0)\n        return node;\n    let frag = node.content;\n    if (openStart > 1)\n        frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0));\n    if (openStart > 0) {\n        frag = node.type.contentMatch.fillBefore(frag).append(frag);\n        if (openEnd <= 0)\n            frag = frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(Fragment.empty, true));\n    }\n    return node.copy(frag);\n}\nfunction contentAfterFits($to, depth, type, match, open) {\n    let node = $to.node(depth), index = open ? $to.indexAfter(depth) : $to.index(depth);\n    if (index == node.childCount && !type.compatibleContent(node.type))\n        return null;\n    let fit = match.fillBefore(node.content, true, index);\n    return fit && !invalidMarks(type, node.content, index) ? fit : null;\n}\nfunction invalidMarks(type, fragment, start) {\n    for (let i = start; i < fragment.childCount; i++)\n        if (!type.allowsMarks(fragment.child(i).marks))\n            return true;\n    return false;\n}\nfunction definesContent(type) {\n    return type.spec.defining || type.spec.definingForContent;\n}\nfunction replaceRange(tr, from, to, slice) {\n    if (!slice.size)\n        return tr.deleteRange(from, to);\n    let $from = tr.doc.resolve(from), $to = tr.doc.resolve(to);\n    if (fitsTrivially($from, $to, slice))\n        return tr.step(new ReplaceStep(from, to, slice));\n    let targetDepths = coveredDepths($from, tr.doc.resolve(to));\n    // Can't replace the whole document, so remove 0 if it's present\n    if (targetDepths[targetDepths.length - 1] == 0)\n        targetDepths.pop();\n    // Negative numbers represent not expansion over the whole node at\n    // that depth, but replacing from $from.before(-D) to $to.pos.\n    let preferredTarget = -($from.depth + 1);\n    targetDepths.unshift(preferredTarget);\n    // This loop picks a preferred target depth, if one of the covering\n    // depths is not outside of a defining node, and adds negative\n    // depths for any depth that has $from at its start and does not\n    // cross a defining node.\n    for (let d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {\n        let spec = $from.node(d).type.spec;\n        if (spec.defining || spec.definingAsContext || spec.isolating)\n            break;\n        if (targetDepths.indexOf(d) > -1)\n            preferredTarget = d;\n        else if ($from.before(d) == pos)\n            targetDepths.splice(1, 0, -d);\n    }\n    // Try to fit each possible depth of the slice into each possible\n    // target depth, starting with the preferred depths.\n    let preferredTargetIndex = targetDepths.indexOf(preferredTarget);\n    let leftNodes = [], preferredDepth = slice.openStart;\n    for (let content = slice.content, i = 0;; i++) {\n        let node = content.firstChild;\n        leftNodes.push(node);\n        if (i == slice.openStart)\n            break;\n        content = node.content;\n    }\n    // Back up preferredDepth to cover defining textblocks directly\n    // above it, possibly skipping a non-defining textblock.\n    for (let d = preferredDepth - 1; d >= 0; d--) {\n        let type = leftNodes[d].type, def = definesContent(type);\n        if (def && $from.node(preferredTargetIndex).type != type)\n            preferredDepth = d;\n        else if (def || !type.isTextblock)\n            break;\n    }\n    for (let j = slice.openStart; j >= 0; j--) {\n        let openDepth = (j + preferredDepth + 1) % (slice.openStart + 1);\n        let insert = leftNodes[openDepth];\n        if (!insert)\n            continue;\n        for (let i = 0; i < targetDepths.length; i++) {\n            // Loop over possible expansion levels, starting with the\n            // preferred one\n            let targetDepth = targetDepths[(i + preferredTargetIndex) % targetDepths.length], expand = true;\n            if (targetDepth < 0) {\n                expand = false;\n                targetDepth = -targetDepth;\n            }\n            let parent = $from.node(targetDepth - 1), index = $from.index(targetDepth - 1);\n            if (parent.canReplaceWith(index, index, insert.type, insert.marks))\n                return tr.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to, new Slice(closeFragment(slice.content, 0, slice.openStart, openDepth), openDepth, slice.openEnd));\n        }\n    }\n    let startSteps = tr.steps.length;\n    for (let i = targetDepths.length - 1; i >= 0; i--) {\n        tr.replace(from, to, slice);\n        if (tr.steps.length > startSteps)\n            break;\n        let depth = targetDepths[i];\n        if (depth < 0)\n            continue;\n        from = $from.before(depth);\n        to = $to.after(depth);\n    }\n}\nfunction closeFragment(fragment, depth, oldOpen, newOpen, parent) {\n    if (depth < oldOpen) {\n        let first = fragment.firstChild;\n        fragment = fragment.replaceChild(0, first.copy(closeFragment(first.content, depth + 1, oldOpen, newOpen, first)));\n    }\n    if (depth > newOpen) {\n        let match = parent.contentMatchAt(0);\n        let start = match.fillBefore(fragment).append(fragment);\n        fragment = start.append(match.matchFragment(start).fillBefore(Fragment.empty, true));\n    }\n    return fragment;\n}\nfunction replaceRangeWith(tr, from, to, node) {\n    if (!node.isInline && from == to && tr.doc.resolve(from).parent.content.size) {\n        let point = insertPoint(tr.doc, from, node.type);\n        if (point != null)\n            from = to = point;\n    }\n    tr.replaceRange(from, to, new Slice(Fragment.from(node), 0, 0));\n}\nfunction deleteRange(tr, from, to) {\n    let $from = tr.doc.resolve(from), $to = tr.doc.resolve(to);\n    let covered = coveredDepths($from, $to);\n    for (let i = 0; i < covered.length; i++) {\n        let depth = covered[i], last = i == covered.length - 1;\n        if ((last && depth == 0) || $from.node(depth).type.contentMatch.validEnd)\n            return tr.delete($from.start(depth), $to.end(depth));\n        if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1))))\n            return tr.delete($from.before(depth), $to.after(depth));\n    }\n    for (let d = 1; d <= $from.depth && d <= $to.depth; d++) {\n        if (from - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d)\n            return tr.delete($from.before(d), to);\n    }\n    tr.delete(from, to);\n}\n// Returns an array of all depths for which $from - $to spans the\n// whole content of the nodes at that depth.\nfunction coveredDepths($from, $to) {\n    let result = [], minDepth = Math.min($from.depth, $to.depth);\n    for (let d = minDepth; d >= 0; d--) {\n        let start = $from.start(d);\n        if (start < $from.pos - ($from.depth - d) ||\n            $to.end(d) > $to.pos + ($to.depth - d) ||\n            $from.node(d).type.spec.isolating ||\n            $to.node(d).type.spec.isolating)\n            break;\n        if (start == $to.start(d) ||\n            (d == $from.depth && d == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent &&\n                d && $to.start(d - 1) == start - 1))\n            result.push(d);\n    }\n    return result;\n}\n\n/**\nUpdate an attribute in a specific node.\n*/\nclass AttrStep extends Step {\n    /**\n    Construct an attribute step.\n    */\n    constructor(\n    /**\n    The position of the target node.\n    */\n    pos, \n    /**\n    The attribute to set.\n    */\n    attr, \n    // The attribute's new value.\n    value) {\n        super();\n        this.pos = pos;\n        this.attr = attr;\n        this.value = value;\n    }\n    apply(doc) {\n        let node = doc.nodeAt(this.pos);\n        if (!node)\n            return StepResult.fail(\"No node at attribute step's position\");\n        let attrs = Object.create(null);\n        for (let name in node.attrs)\n            attrs[name] = node.attrs[name];\n        attrs[this.attr] = this.value;\n        let updated = node.type.create(attrs, null, node.marks);\n        return StepResult.fromReplace(doc, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));\n    }\n    getMap() {\n        return StepMap.empty;\n    }\n    invert(doc) {\n        return new AttrStep(this.pos, this.attr, doc.nodeAt(this.pos).attrs[this.attr]);\n    }\n    map(mapping) {\n        let pos = mapping.mapResult(this.pos, 1);\n        return pos.deletedAfter ? null : new AttrStep(pos.pos, this.attr, this.value);\n    }\n    toJSON() {\n        return { stepType: \"attr\", pos: this.pos, attr: this.attr, value: this.value };\n    }\n    static fromJSON(schema, json) {\n        if (typeof json.pos != \"number\" || typeof json.attr != \"string\")\n            throw new RangeError(\"Invalid input for AttrStep.fromJSON\");\n        return new AttrStep(json.pos, json.attr, json.value);\n    }\n}\nStep.jsonID(\"attr\", AttrStep);\n\n/**\n@internal\n*/\nlet TransformError = class extends Error {\n};\nTransformError = function TransformError(message) {\n    let err = Error.call(this, message);\n    err.__proto__ = TransformError.prototype;\n    return err;\n};\nTransformError.prototype = Object.create(Error.prototype);\nTransformError.prototype.constructor = TransformError;\nTransformError.prototype.name = \"TransformError\";\n/**\nAbstraction to build up and track an array of\n[steps](https://prosemirror.net/docs/ref/#transform.Step) representing a document transformation.\n\nMost transforming methods return the `Transform` object itself, so\nthat they can be chained.\n*/\nclass Transform {\n    /**\n    Create a transform that starts with the given document.\n    */\n    constructor(\n    /**\n    The current document (the result of applying the steps in the\n    transform).\n    */\n    doc) {\n        this.doc = doc;\n        /**\n        The steps in this transform.\n        */\n        this.steps = [];\n        /**\n        The documents before each of the steps.\n        */\n        this.docs = [];\n        /**\n        A mapping with the maps for each of the steps in this transform.\n        */\n        this.mapping = new Mapping;\n    }\n    /**\n    The starting document.\n    */\n    get before() { return this.docs.length ? this.docs[0] : this.doc; }\n    /**\n    Apply a new step in this transform, saving the result. Throws an\n    error when the step fails.\n    */\n    step(step) {\n        let result = this.maybeStep(step);\n        if (result.failed)\n            throw new TransformError(result.failed);\n        return this;\n    }\n    /**\n    Try to apply a step in this transformation, ignoring it if it\n    fails. Returns the step result.\n    */\n    maybeStep(step) {\n        let result = step.apply(this.doc);\n        if (!result.failed)\n            this.addStep(step, result.doc);\n        return result;\n    }\n    /**\n    True when the document has been changed (when there are any\n    steps).\n    */\n    get docChanged() {\n        return this.steps.length > 0;\n    }\n    /**\n    @internal\n    */\n    addStep(step, doc) {\n        this.docs.push(this.doc);\n        this.steps.push(step);\n        this.mapping.appendMap(step.getMap());\n        this.doc = doc;\n    }\n    /**\n    Replace the part of the document between `from` and `to` with the\n    given `slice`.\n    */\n    replace(from, to = from, slice = Slice.empty) {\n        let step = replaceStep(this.doc, from, to, slice);\n        if (step)\n            this.step(step);\n        return this;\n    }\n    /**\n    Replace the given range with the given content, which may be a\n    fragment, node, or array of nodes.\n    */\n    replaceWith(from, to, content) {\n        return this.replace(from, to, new Slice(Fragment.from(content), 0, 0));\n    }\n    /**\n    Delete the content between the given positions.\n    */\n    delete(from, to) {\n        return this.replace(from, to, Slice.empty);\n    }\n    /**\n    Insert the given content at the given position.\n    */\n    insert(pos, content) {\n        return this.replaceWith(pos, pos, content);\n    }\n    /**\n    Replace a range of the document with a given slice, using\n    `from`, `to`, and the slice's\n    [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather\n    than fixed start and end points. This method may grow the\n    replaced area or close open nodes in the slice in order to get a\n    fit that is more in line with WYSIWYG expectations, by dropping\n    fully covered parent nodes of the replaced region when they are\n    marked [non-defining as\n    context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an\n    open parent node from the slice that _is_ marked as [defining\n    its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).\n    \n    This is the method, for example, to handle paste. The similar\n    [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more\n    primitive tool which will _not_ move the start and end of its given\n    range, and is useful in situations where you need more precise\n    control over what happens.\n    */\n    replaceRange(from, to, slice) {\n        replaceRange(this, from, to, slice);\n        return this;\n    }\n    /**\n    Replace the given range with a node, but use `from` and `to` as\n    hints, rather than precise positions. When from and to are the same\n    and are at the start or end of a parent node in which the given\n    node doesn't fit, this method may _move_ them out towards a parent\n    that does allow the given node to be placed. When the given range\n    completely covers a parent node, this method may completely replace\n    that parent node.\n    */\n    replaceRangeWith(from, to, node) {\n        replaceRangeWith(this, from, to, node);\n        return this;\n    }\n    /**\n    Delete the given range, expanding it to cover fully covered\n    parent nodes until a valid replace is found.\n    */\n    deleteRange(from, to) {\n        deleteRange(this, from, to);\n        return this;\n    }\n    /**\n    Split the content in the given range off from its parent, if there\n    is sibling content before or after it, and move it up the tree to\n    the depth specified by `target`. You'll probably want to use\n    [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make\n    sure the lift is valid.\n    */\n    lift(range, target) {\n        lift(this, range, target);\n        return this;\n    }\n    /**\n    Join the blocks around the given position. If depth is 2, their\n    last and first siblings are also joined, and so on.\n    */\n    join(pos, depth = 1) {\n        join(this, pos, depth);\n        return this;\n    }\n    /**\n    Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.\n    The wrappers are assumed to be valid in this position, and should\n    probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).\n    */\n    wrap(range, wrappers) {\n        wrap(this, range, wrappers);\n        return this;\n    }\n    /**\n    Set the type of all textblocks (partly) between `from` and `to` to\n    the given node type with the given attributes.\n    */\n    setBlockType(from, to = from, type, attrs = null) {\n        setBlockType(this, from, to, type, attrs);\n        return this;\n    }\n    /**\n    Change the type, attributes, and/or marks of the node at `pos`.\n    When `type` isn't given, the existing node type is preserved,\n    */\n    setNodeMarkup(pos, type, attrs = null, marks = []) {\n        setNodeMarkup(this, pos, type, attrs, marks);\n        return this;\n    }\n    /**\n    Set a single attribute on a given node to a new value.\n    */\n    setNodeAttribute(pos, attr, value) {\n        this.step(new AttrStep(pos, attr, value));\n        return this;\n    }\n    /**\n    Add a mark to the node at position `pos`.\n    */\n    addNodeMark(pos, mark) {\n        this.step(new AddNodeMarkStep(pos, mark));\n        return this;\n    }\n    /**\n    Remove a mark (or a mark of the given type) from the node at\n    position `pos`.\n    */\n    removeNodeMark(pos, mark) {\n        if (!(mark instanceof Mark)) {\n            let node = this.doc.nodeAt(pos);\n            if (!node)\n                throw new RangeError(\"No node at position \" + pos);\n            mark = mark.isInSet(node.marks);\n            if (!mark)\n                return this;\n        }\n        this.step(new RemoveNodeMarkStep(pos, mark));\n        return this;\n    }\n    /**\n    Split the node at the given position, and optionally, if `depth` is\n    greater than one, any number of nodes above that. By default, the\n    parts split off will inherit the node type of the original node.\n    This can be changed by passing an array of types and attributes to\n    use after the split.\n    */\n    split(pos, depth = 1, typesAfter) {\n        split(this, pos, depth, typesAfter);\n        return this;\n    }\n    /**\n    Add the given mark to the inline content between `from` and `to`.\n    */\n    addMark(from, to, mark) {\n        addMark(this, from, to, mark);\n        return this;\n    }\n    /**\n    Remove marks from inline nodes between `from` and `to`. When\n    `mark` is a single mark, remove precisely that mark. When it is\n    a mark type, remove all marks of that type. When it is null,\n    remove all marks of any type.\n    */\n    removeMark(from, to, mark) {\n        removeMark(this, from, to, mark);\n        return this;\n    }\n    /**\n    Removes all marks and nodes from the content of the node at\n    `pos` that don't match the given new parent node type. Accepts\n    an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as\n    third argument.\n    */\n    clearIncompatible(pos, parentType, match) {\n        clearIncompatible(this, pos, parentType, match);\n        return this;\n    }\n}\n\n// Because working with row and column-spanning cells is not quite\n// trivial, this code builds up a descriptive structure for a given\n// table node. The structures are cached with the (persistent) table\n// nodes as key, so that they only have to be recomputed when the\n// content of the table changes.\n//\n// This does mean that they have to store table-relative, not\n// document-relative positions. So code that uses them will typically\n// compute the start position of the table and offset positions passed\n// to or gotten from this structure by that amount.\nlet readFromCache, addToCache; // Prefer using a weak map to cache table maps. Fall back on a\n// fixed-size cache if that's not supported.\n\nif (typeof WeakMap != 'undefined') {\n  // eslint-disable-next-line\n  let cache = new WeakMap();\n\n  readFromCache = key => cache.get(key);\n\n  addToCache = (key, value) => {\n    cache.set(key, value);\n    return value;\n  };\n} else {\n  let cache = [],\n      cacheSize = 10,\n      cachePos = 0;\n\n  readFromCache = key => {\n    for (let i = 0; i < cache.length; i += 2) if (cache[i] == key) return cache[i + 1];\n  };\n\n  addToCache = (key, value) => {\n    if (cachePos == cacheSize) cachePos = 0;\n    cache[cachePos++] = key;\n    return cache[cachePos++] = value;\n  };\n}\n\nclass Rect {\n  constructor(left, top, right, bottom) {\n    this.left = left;\n    this.top = top;\n    this.right = right;\n    this.bottom = bottom;\n  }\n\n} // ::- A table map describes the structore of a given table. To avoid\n// recomputing them all the time, they are cached per table node. To\n// be able to do that, positions saved in the map are relative to the\n// start of the table, rather than the start of the document.\n\nclass TableMap {\n  constructor(width, height, map, problems) {\n    // :: number The width of the table\n    this.width = width; // :: number The table's height\n\n    this.height = height; // :: [number] A width * height array with the start position of\n    // the cell covering that part of the table in each slot\n\n    this.map = map; // An optional array of problems (cell overlap or non-rectangular\n    // shape) for the table, used by the table normalizer.\n\n    this.problems = problems;\n  } // :: (number) → Rect\n  // Find the dimensions of the cell at the given position.\n\n\n  findCell(pos) {\n    for (let i = 0; i < this.map.length; i++) {\n      let curPos = this.map[i];\n      if (curPos != pos) continue;\n      let left = i % this.width,\n          top = i / this.width | 0;\n      let right = left + 1,\n          bottom = top + 1;\n\n      for (let j = 1; right < this.width && this.map[i + j] == curPos; j++) right++;\n\n      for (let j = 1; bottom < this.height && this.map[i + this.width * j] == curPos; j++) bottom++;\n\n      return new Rect(left, top, right, bottom);\n    }\n\n    throw new RangeError('No cell with offset ' + pos + ' found');\n  } // :: (number) → number\n  // Find the left side of the cell at the given position.\n\n\n  colCount(pos) {\n    for (let i = 0; i < this.map.length; i++) if (this.map[i] == pos) return i % this.width;\n\n    throw new RangeError('No cell with offset ' + pos + ' found');\n  } // :: (number, string, number) → ?number\n  // Find the next cell in the given direction, starting from the cell\n  // at `pos`, if any.\n\n\n  nextCell(pos, axis, dir) {\n    let {\n      left,\n      right,\n      top,\n      bottom\n    } = this.findCell(pos);\n\n    if (axis == 'horiz') {\n      if (dir < 0 ? left == 0 : right == this.width) return null;\n      return this.map[top * this.width + (dir < 0 ? left - 1 : right)];\n    } else {\n      if (dir < 0 ? top == 0 : bottom == this.height) return null;\n      return this.map[left + this.width * (dir < 0 ? top - 1 : bottom)];\n    }\n  } // :: (number, number) → Rect\n  // Get the rectangle spanning the two given cells.\n\n\n  rectBetween(a, b) {\n    let {\n      left: leftA,\n      right: rightA,\n      top: topA,\n      bottom: bottomA\n    } = this.findCell(a);\n    let {\n      left: leftB,\n      right: rightB,\n      top: topB,\n      bottom: bottomB\n    } = this.findCell(b);\n    return new Rect(Math.min(leftA, leftB), Math.min(topA, topB), Math.max(rightA, rightB), Math.max(bottomA, bottomB));\n  } // :: (Rect) → [number]\n  // Return the position of all cells that have the top left corner in\n  // the given rectangle.\n\n\n  cellsInRect(rect) {\n    let result = [],\n        seen = {};\n\n    for (let row = rect.top; row < rect.bottom; row++) {\n      for (let col = rect.left; col < rect.right; col++) {\n        let index = row * this.width + col,\n            pos = this.map[index];\n        if (seen[pos]) continue;\n        seen[pos] = true;\n        if ((col != rect.left || !col || this.map[index - 1] != pos) && (row != rect.top || !row || this.map[index - this.width] != pos)) result.push(pos);\n      }\n    }\n\n    return result;\n  } // :: (number, number, Node) → number\n  // Return the position at which the cell at the given row and column\n  // starts, or would start, if a cell started there.\n\n\n  positionAt(row, col, table) {\n    for (let i = 0, rowStart = 0;; i++) {\n      let rowEnd = rowStart + table.child(i).nodeSize;\n\n      if (i == row) {\n        let index = col + row * this.width,\n            rowEndIndex = (row + 1) * this.width; // Skip past cells from previous rows (via rowspan)\n\n        while (index < rowEndIndex && this.map[index] < rowStart) index++;\n\n        return index == rowEndIndex ? rowEnd - 1 : this.map[index];\n      }\n\n      rowStart = rowEnd;\n    }\n  } // :: (Node) → TableMap\n  // Find the table map for the given table node.\n\n\n  static get(table) {\n    return readFromCache(table) || addToCache(table, computeMap(table));\n  }\n\n} // Compute a table map.\n\nfunction computeMap(table) {\n  if (table.type.spec.tableRole != 'table') throw new RangeError('Not a table node: ' + table.type.name);\n  let width = findWidth(table),\n      height = table.childCount;\n  let map = [],\n      mapPos = 0,\n      problems = null,\n      colWidths = [];\n\n  for (let i = 0, e = width * height; i < e; i++) map[i] = 0;\n\n  for (let row = 0, pos = 0; row < height; row++) {\n    let rowNode = table.child(row);\n    pos++;\n\n    for (let i = 0;; i++) {\n      while (mapPos < map.length && map[mapPos] != 0) mapPos++;\n\n      if (i == rowNode.childCount) break;\n      let cellNode = rowNode.child(i),\n          {\n        colspan,\n        rowspan,\n        colwidth\n      } = cellNode.attrs;\n\n      for (let h = 0; h < rowspan; h++) {\n        if (h + row >= height) {\n          (problems || (problems = [])).push({\n            type: 'overlong_rowspan',\n            pos,\n            n: rowspan - h\n          });\n          break;\n        }\n\n        let start = mapPos + h * width;\n\n        for (let w = 0; w < colspan; w++) {\n          if (map[start + w] == 0) map[start + w] = pos;else (problems || (problems = [])).push({\n            type: 'collision',\n            row,\n            pos,\n            n: colspan - w\n          });\n          let colW = colwidth && colwidth[w];\n\n          if (colW) {\n            let widthIndex = (start + w) % width * 2,\n                prev = colWidths[widthIndex];\n\n            if (prev == null || prev != colW && colWidths[widthIndex + 1] == 1) {\n              colWidths[widthIndex] = colW;\n              colWidths[widthIndex + 1] = 1;\n            } else if (prev == colW) {\n              colWidths[widthIndex + 1]++;\n            }\n          }\n        }\n      }\n\n      mapPos += colspan;\n      pos += cellNode.nodeSize;\n    }\n\n    let expectedPos = (row + 1) * width,\n        missing = 0;\n\n    while (mapPos < expectedPos) if (map[mapPos++] == 0) missing++;\n\n    if (missing) (problems || (problems = [])).push({\n      type: 'missing',\n      row,\n      n: missing\n    });\n    pos++;\n  }\n\n  let tableMap = new TableMap(width, height, map, problems),\n      badWidths = false; // For columns that have defined widths, but whose widths disagree\n  // between rows, fix up the cells whose width doesn't match the\n  // computed one.\n\n  for (let i = 0; !badWidths && i < colWidths.length; i += 2) if (colWidths[i] != null && colWidths[i + 1] < height) badWidths = true;\n\n  if (badWidths) findBadColWidths(tableMap, colWidths, table);\n  return tableMap;\n}\n\nfunction findWidth(table) {\n  let width = -1,\n      hasRowSpan = false;\n\n  for (let row = 0; row < table.childCount; row++) {\n    let rowNode = table.child(row),\n        rowWidth = 0;\n    if (hasRowSpan) for (let j = 0; j < row; j++) {\n      let prevRow = table.child(j);\n\n      for (let i = 0; i < prevRow.childCount; i++) {\n        let cell = prevRow.child(i);\n        if (j + cell.attrs.rowspan > row) rowWidth += cell.attrs.colspan;\n      }\n    }\n\n    for (let i = 0; i < rowNode.childCount; i++) {\n      let cell = rowNode.child(i);\n      rowWidth += cell.attrs.colspan;\n      if (cell.attrs.rowspan > 1) hasRowSpan = true;\n    }\n\n    if (width == -1) width = rowWidth;else if (width != rowWidth) width = Math.max(width, rowWidth);\n  }\n\n  return width;\n}\n\nfunction findBadColWidths(map, colWidths, table) {\n  if (!map.problems) map.problems = [];\n\n  for (let i = 0, seen = {}; i < map.map.length; i++) {\n    let pos = map.map[i];\n    if (seen[pos]) continue;\n    seen[pos] = true;\n    let node = table.nodeAt(pos),\n        updated = null;\n\n    for (let j = 0; j < node.attrs.colspan; j++) {\n      let col = (i + j) % map.width,\n          colWidth = colWidths[col * 2];\n      if (colWidth != null && (!node.attrs.colwidth || node.attrs.colwidth[j] != colWidth)) (updated || (updated = freshColWidth(node.attrs)))[j] = colWidth;\n    }\n\n    if (updated) map.problems.unshift({\n      type: 'colwidth mismatch',\n      pos,\n      colwidth: updated\n    });\n  }\n}\n\nfunction freshColWidth(attrs) {\n  if (attrs.colwidth) return attrs.colwidth.slice();\n  let result = [];\n\n  for (let i = 0; i < attrs.colspan; i++) result.push(0);\n\n  return result;\n}\nfunction tableNodeTypes(schema) {\n  let result = schema.cached.tableNodeTypes;\n\n  if (!result) {\n    result = schema.cached.tableNodeTypes = {};\n\n    for (let name in schema.nodes) {\n      let type = schema.nodes[name],\n          role = type.spec.tableRole;\n      if (role) result[role] = type;\n    }\n  }\n\n  return result;\n}\n\n// Various helper function for working with tables\nconst key$1 = new PluginKey('selectingCells');\nfunction cellAround($pos) {\n  for (let d = $pos.depth - 1; d > 0; d--) if ($pos.node(d).type.spec.tableRole == 'row') return $pos.node(0).resolve($pos.before(d + 1));\n\n  return null;\n}\nfunction cellWrapping($pos) {\n  for (let d = $pos.depth; d > 0; d--) {\n    // Sometimes the cell can be in the same depth.\n    const role = $pos.node(d).type.spec.tableRole;\n    if (role === 'cell' || role === 'header_cell') return $pos.node(d);\n  }\n\n  return null;\n}\nfunction isInTable(state) {\n  let $head = state.selection.$head;\n\n  for (let d = $head.depth; d > 0; d--) if ($head.node(d).type.spec.tableRole == 'row') return true;\n\n  return false;\n}\nfunction selectionCell(state) {\n  let sel = state.selection;\n\n  if (sel.$anchorCell) {\n    return sel.$anchorCell.pos > sel.$headCell.pos ? sel.$anchorCell : sel.$headCell;\n  } else if (sel.node && sel.node.type.spec.tableRole == 'cell') {\n    return sel.$anchor;\n  }\n\n  return cellAround(sel.$head) || cellNear(sel.$head);\n}\n\nfunction cellNear($pos) {\n  for (let after = $pos.nodeAfter, pos = $pos.pos; after; after = after.firstChild, pos++) {\n    let role = after.type.spec.tableRole;\n    if (role == 'cell' || role == 'header_cell') return $pos.doc.resolve(pos);\n  }\n\n  for (let before = $pos.nodeBefore, pos = $pos.pos; before; before = before.lastChild, pos--) {\n    let role = before.type.spec.tableRole;\n    if (role == 'cell' || role == 'header_cell') return $pos.doc.resolve(pos - before.nodeSize);\n  }\n}\n\nfunction pointsAtCell($pos) {\n  return $pos.parent.type.spec.tableRole == 'row' && $pos.nodeAfter;\n}\nfunction moveCellForward($pos) {\n  return $pos.node(0).resolve($pos.pos + $pos.nodeAfter.nodeSize);\n}\nfunction inSameTable($a, $b) {\n  return $a.depth == $b.depth && $a.pos >= $b.start(-1) && $a.pos <= $b.end(-1);\n}\nfunction nextCell($pos, axis, dir) {\n  let start = $pos.start(-1),\n      map = TableMap.get($pos.node(-1));\n  let moved = map.nextCell($pos.pos - start, axis, dir);\n  return moved == null ? null : $pos.node(0).resolve(start + moved);\n}\nfunction setAttr(attrs, name, value) {\n  let result = {};\n\n  for (let prop in attrs) result[prop] = attrs[prop];\n\n  result[name] = value;\n  return result;\n}\nfunction removeColSpan(attrs, pos, n = 1) {\n  let result = setAttr(attrs, 'colspan', attrs.colspan - n);\n\n  if (result.colwidth) {\n    result.colwidth = result.colwidth.slice();\n    result.colwidth.splice(pos, n);\n    if (!result.colwidth.some(w => w > 0)) result.colwidth = null;\n  }\n\n  return result;\n}\nfunction addColSpan(attrs, pos, n = 1) {\n  let result = setAttr(attrs, 'colspan', attrs.colspan + n);\n\n  if (result.colwidth) {\n    result.colwidth = result.colwidth.slice();\n\n    for (let i = 0; i < n; i++) result.colwidth.splice(pos, 0, 0);\n  }\n\n  return result;\n}\nfunction columnIsHeader(map, table, col) {\n  let headerCell = tableNodeTypes(table.type.schema).header_cell;\n\n  for (let row = 0; row < map.height; row++) if (table.nodeAt(map.map[col + row * map.width]).type != headerCell) return false;\n\n  return true;\n}\n\n// This file defines a ProseMirror selection subclass that models\n// subclass that represents a cell selection spanning part of a table.\n// With the plugin enabled, these will be created when the user\n// selects across cells, and will be drawn by giving selected cells a\n// `selectedCell` CSS class.\n\nclass CellSelection extends Selection {\n  // :: (ResolvedPos, ?ResolvedPos)\n  // A table selection is identified by its anchor and head cells. The\n  // positions given to this constructor should point _before_ two\n  // cells in the same table. They may be the same, to select a single\n  // cell.\n  constructor($anchorCell, $headCell = $anchorCell) {\n    let table = $anchorCell.node(-1),\n        map = TableMap.get(table),\n        start = $anchorCell.start(-1);\n    let rect = map.rectBetween($anchorCell.pos - start, $headCell.pos - start);\n    let doc = $anchorCell.node(0);\n    let cells = map.cellsInRect(rect).filter(p => p != $headCell.pos - start); // Make the head cell the first range, so that it counts as the\n    // primary part of the selection\n\n    cells.unshift($headCell.pos - start);\n    let ranges = cells.map(pos => {\n      let cell = table.nodeAt(pos),\n          from = pos + start + 1;\n      return new SelectionRange(doc.resolve(from), doc.resolve(from + cell.content.size));\n    });\n    super(ranges[0].$from, ranges[0].$to, ranges); // :: ResolvedPos\n    // A resolved position pointing _in front of_ the anchor cell (the one\n    // that doesn't move when extending the selection).\n\n    this.$anchorCell = $anchorCell; // :: ResolvedPos\n    // A resolved position pointing in front of the head cell (the one\n    // moves when extending the selection).\n\n    this.$headCell = $headCell;\n  }\n\n  map(doc, mapping) {\n    let $anchorCell = doc.resolve(mapping.map(this.$anchorCell.pos));\n    let $headCell = doc.resolve(mapping.map(this.$headCell.pos));\n\n    if (pointsAtCell($anchorCell) && pointsAtCell($headCell) && inSameTable($anchorCell, $headCell)) {\n      let tableChanged = this.$anchorCell.node(-1) != $anchorCell.node(-1);\n      if (tableChanged && this.isRowSelection()) return CellSelection.rowSelection($anchorCell, $headCell);else if (tableChanged && this.isColSelection()) return CellSelection.colSelection($anchorCell, $headCell);else return new CellSelection($anchorCell, $headCell);\n    }\n\n    return TextSelection.between($anchorCell, $headCell);\n  } // :: () → Slice\n  // Returns a rectangular slice of table rows containing the selected\n  // cells.\n\n\n  content() {\n    let table = this.$anchorCell.node(-1),\n        map = TableMap.get(table),\n        start = this.$anchorCell.start(-1);\n    let rect = map.rectBetween(this.$anchorCell.pos - start, this.$headCell.pos - start);\n    let seen = {},\n        rows = [];\n\n    for (let row = rect.top; row < rect.bottom; row++) {\n      let rowContent = [];\n\n      for (let index = row * map.width + rect.left, col = rect.left; col < rect.right; col++, index++) {\n        let pos = map.map[index];\n\n        if (!seen[pos]) {\n          seen[pos] = true;\n          let cellRect = map.findCell(pos),\n              cell = table.nodeAt(pos);\n          let extraLeft = rect.left - cellRect.left,\n              extraRight = cellRect.right - rect.right;\n\n          if (extraLeft > 0 || extraRight > 0) {\n            let attrs = cell.attrs;\n            if (extraLeft > 0) attrs = removeColSpan(attrs, 0, extraLeft);\n            if (extraRight > 0) attrs = removeColSpan(attrs, attrs.colspan - extraRight, extraRight);\n            if (cellRect.left < rect.left) cell = cell.type.createAndFill(attrs);else cell = cell.type.create(attrs, cell.content);\n          }\n\n          if (cellRect.top < rect.top || cellRect.bottom > rect.bottom) {\n            let attrs = setAttr(cell.attrs, 'rowspan', Math.min(cellRect.bottom, rect.bottom) - Math.max(cellRect.top, rect.top));\n            if (cellRect.top < rect.top) cell = cell.type.createAndFill(attrs);else cell = cell.type.create(attrs, cell.content);\n          }\n\n          rowContent.push(cell);\n        }\n      }\n\n      rows.push(table.child(row).copy(Fragment.from(rowContent)));\n    }\n\n    const fragment = this.isColSelection() && this.isRowSelection() ? table : rows;\n    return new Slice(Fragment.from(fragment), 1, 1);\n  }\n\n  replace(tr, content = Slice.empty) {\n    let mapFrom = tr.steps.length,\n        ranges = this.ranges;\n\n    for (let i = 0; i < ranges.length; i++) {\n      let {\n        $from,\n        $to\n      } = ranges[i],\n          mapping = tr.mapping.slice(mapFrom);\n      tr.replace(mapping.map($from.pos), mapping.map($to.pos), i ? Slice.empty : content);\n    }\n\n    let sel = Selection.findFrom(tr.doc.resolve(tr.mapping.slice(mapFrom).map(this.to)), -1);\n    if (sel) tr.setSelection(sel);\n  }\n\n  replaceWith(tr, node) {\n    this.replace(tr, new Slice(Fragment.from(node), 0, 0));\n  }\n\n  forEachCell(f) {\n    let table = this.$anchorCell.node(-1),\n        map = TableMap.get(table),\n        start = this.$anchorCell.start(-1);\n    let cells = map.cellsInRect(map.rectBetween(this.$anchorCell.pos - start, this.$headCell.pos - start));\n\n    for (let i = 0; i < cells.length; i++) f(table.nodeAt(cells[i]), start + cells[i]);\n  } // :: () → bool\n  // True if this selection goes all the way from the top to the\n  // bottom of the table.\n\n\n  isColSelection() {\n    let anchorTop = this.$anchorCell.index(-1),\n        headTop = this.$headCell.index(-1);\n    if (Math.min(anchorTop, headTop) > 0) return false;\n    let anchorBot = anchorTop + this.$anchorCell.nodeAfter.attrs.rowspan,\n        headBot = headTop + this.$headCell.nodeAfter.attrs.rowspan;\n    return Math.max(anchorBot, headBot) == this.$headCell.node(-1).childCount;\n  } // :: (ResolvedPos, ?ResolvedPos) → CellSelection\n  // Returns the smallest column selection that covers the given anchor\n  // and head cell.\n\n\n  static colSelection($anchorCell, $headCell = $anchorCell) {\n    let map = TableMap.get($anchorCell.node(-1)),\n        start = $anchorCell.start(-1);\n    let anchorRect = map.findCell($anchorCell.pos - start),\n        headRect = map.findCell($headCell.pos - start);\n    let doc = $anchorCell.node(0);\n\n    if (anchorRect.top <= headRect.top) {\n      if (anchorRect.top > 0) $anchorCell = doc.resolve(start + map.map[anchorRect.left]);\n      if (headRect.bottom < map.height) $headCell = doc.resolve(start + map.map[map.width * (map.height - 1) + headRect.right - 1]);\n    } else {\n      if (headRect.top > 0) $headCell = doc.resolve(start + map.map[headRect.left]);\n      if (anchorRect.bottom < map.height) $anchorCell = doc.resolve(start + map.map[map.width * (map.height - 1) + anchorRect.right - 1]);\n    }\n\n    return new CellSelection($anchorCell, $headCell);\n  } // :: () → bool\n  // True if this selection goes all the way from the left to the\n  // right of the table.\n\n\n  isRowSelection() {\n    let map = TableMap.get(this.$anchorCell.node(-1)),\n        start = this.$anchorCell.start(-1);\n    let anchorLeft = map.colCount(this.$anchorCell.pos - start),\n        headLeft = map.colCount(this.$headCell.pos - start);\n    if (Math.min(anchorLeft, headLeft) > 0) return false;\n    let anchorRight = anchorLeft + this.$anchorCell.nodeAfter.attrs.colspan,\n        headRight = headLeft + this.$headCell.nodeAfter.attrs.colspan;\n    return Math.max(anchorRight, headRight) == map.width;\n  }\n\n  eq(other) {\n    return other instanceof CellSelection && other.$anchorCell.pos == this.$anchorCell.pos && other.$headCell.pos == this.$headCell.pos;\n  } // :: (ResolvedPos, ?ResolvedPos) → CellSelection\n  // Returns the smallest row selection that covers the given anchor\n  // and head cell.\n\n\n  static rowSelection($anchorCell, $headCell = $anchorCell) {\n    let map = TableMap.get($anchorCell.node(-1)),\n        start = $anchorCell.start(-1);\n    let anchorRect = map.findCell($anchorCell.pos - start),\n        headRect = map.findCell($headCell.pos - start);\n    let doc = $anchorCell.node(0);\n\n    if (anchorRect.left <= headRect.left) {\n      if (anchorRect.left > 0) $anchorCell = doc.resolve(start + map.map[anchorRect.top * map.width]);\n      if (headRect.right < map.width) $headCell = doc.resolve(start + map.map[map.width * (headRect.top + 1) - 1]);\n    } else {\n      if (headRect.left > 0) $headCell = doc.resolve(start + map.map[headRect.top * map.width]);\n      if (anchorRect.right < map.width) $anchorCell = doc.resolve(start + map.map[map.width * (anchorRect.top + 1) - 1]);\n    }\n\n    return new CellSelection($anchorCell, $headCell);\n  }\n\n  toJSON() {\n    return {\n      type: 'cell',\n      anchor: this.$anchorCell.pos,\n      head: this.$headCell.pos\n    };\n  }\n\n  static fromJSON(doc, json) {\n    return new CellSelection(doc.resolve(json.anchor), doc.resolve(json.head));\n  } // :: (Node, number, ?number) → CellSelection\n\n\n  static create(doc, anchorCell, headCell = anchorCell) {\n    return new CellSelection(doc.resolve(anchorCell), doc.resolve(headCell));\n  }\n\n  getBookmark() {\n    return new CellBookmark(this.$anchorCell.pos, this.$headCell.pos);\n  }\n\n}\nCellSelection.prototype.visible = false;\nSelection.jsonID('cell', CellSelection);\n\nclass CellBookmark {\n  constructor(anchor, head) {\n    this.anchor = anchor;\n    this.head = head;\n  }\n\n  map(mapping) {\n    return new CellBookmark(mapping.map(this.anchor), mapping.map(this.head));\n  }\n\n  resolve(doc) {\n    let $anchorCell = doc.resolve(this.anchor),\n        $headCell = doc.resolve(this.head);\n    if ($anchorCell.parent.type.spec.tableRole == 'row' && $headCell.parent.type.spec.tableRole == 'row' && $anchorCell.index() < $anchorCell.parent.childCount && $headCell.index() < $headCell.parent.childCount && inSameTable($anchorCell, $headCell)) return new CellSelection($anchorCell, $headCell);else return Selection.near($headCell, 1);\n  }\n\n}\n\nfunction drawCellSelection(state) {\n  if (!(state.selection instanceof CellSelection)) return null;\n  let cells = [];\n  state.selection.forEachCell((node, pos) => {\n    cells.push(Decoration.node(pos, pos + node.nodeSize, {\n      class: 'selectedCell'\n    }));\n  });\n  return DecorationSet.create(state.doc, cells);\n}\n\nfunction isCellBoundarySelection({\n  $from,\n  $to\n}) {\n  if ($from.pos == $to.pos || $from.pos < $from.pos - 6) return false; // Cheap elimination\n\n  let afterFrom = $from.pos,\n      beforeTo = $to.pos,\n      depth = $from.depth;\n\n  for (; depth >= 0; depth--, afterFrom++) if ($from.after(depth + 1) < $from.end(depth)) break;\n\n  for (let d = $to.depth; d >= 0; d--, beforeTo--) if ($to.before(d + 1) > $to.start(d)) break;\n\n  return afterFrom == beforeTo && /row|table/.test($from.node(depth).type.spec.tableRole);\n}\n\nfunction isTextSelectionAcrossCells({\n  $from,\n  $to\n}) {\n  let fromCellBoundaryNode;\n  let toCellBoundaryNode;\n\n  for (let i = $from.depth; i > 0; i--) {\n    let node = $from.node(i);\n\n    if (node.type.spec.tableRole === 'cell' || node.type.spec.tableRole === 'header_cell') {\n      fromCellBoundaryNode = node;\n      break;\n    }\n  }\n\n  for (let i = $to.depth; i > 0; i--) {\n    let node = $to.node(i);\n\n    if (node.type.spec.tableRole === 'cell' || node.type.spec.tableRole === 'header_cell') {\n      toCellBoundaryNode = node;\n      break;\n    }\n  }\n\n  return fromCellBoundaryNode !== toCellBoundaryNode && $to.parentOffset === 0;\n}\n\nfunction normalizeSelection(state, tr, allowTableNodeSelection) {\n  let sel = (tr || state).selection,\n      doc = (tr || state).doc,\n      normalize,\n      role;\n\n  if (sel instanceof NodeSelection && (role = sel.node.type.spec.tableRole)) {\n    if (role == 'cell' || role == 'header_cell') {\n      normalize = CellSelection.create(doc, sel.from);\n    } else if (role == 'row') {\n      let $cell = doc.resolve(sel.from + 1);\n      normalize = CellSelection.rowSelection($cell, $cell);\n    } else if (!allowTableNodeSelection) {\n      let map = TableMap.get(sel.node),\n          start = sel.from + 1;\n      let lastCell = start + map.map[map.width * map.height - 1];\n      normalize = CellSelection.create(doc, start + 1, lastCell);\n    }\n  } else if (sel instanceof TextSelection && isCellBoundarySelection(sel)) {\n    normalize = TextSelection.create(doc, sel.from);\n  } else if (sel instanceof TextSelection && isTextSelectionAcrossCells(sel)) {\n    normalize = TextSelection.create(doc, sel.$from.start(), sel.$from.end());\n  }\n\n  if (normalize) (tr || (tr = state.tr)).setSelection(normalize);\n  return tr;\n}\n\n// Utilities used for copy/paste handling.\n// : (Slice) → ?{width: number, height: number, rows: [Fragment]}\n// Get a rectangular area of cells from a slice, or null if the outer\n// nodes of the slice aren't table cells or rows.\n\nfunction pastedCells(slice) {\n  if (!slice.size) return null;\n  let {\n    content,\n    openStart,\n    openEnd\n  } = slice;\n\n  while (content.childCount == 1 && (openStart > 0 && openEnd > 0 || content.firstChild.type.spec.tableRole == 'table')) {\n    openStart--;\n    openEnd--;\n    content = content.firstChild.content;\n  }\n\n  let first = content.firstChild,\n      role = first.type.spec.tableRole;\n  let schema = first.type.schema,\n      rows = [];\n\n  if (role == 'row') {\n    for (let i = 0; i < content.childCount; i++) {\n      let cells = content.child(i).content;\n      let left = i ? 0 : Math.max(0, openStart - 1);\n      let right = i < content.childCount - 1 ? 0 : Math.max(0, openEnd - 1);\n      if (left || right) cells = fitSlice(tableNodeTypes(schema).row, new Slice(cells, left, right)).content;\n      rows.push(cells);\n    }\n  } else if (role == 'cell' || role == 'header_cell') {\n    rows.push(openStart || openEnd ? fitSlice(tableNodeTypes(schema).row, new Slice(content, openStart, openEnd)).content : content);\n  } else {\n    return null;\n  }\n\n  return ensureRectangular(schema, rows);\n} // : (Schema, [Fragment]) → {width: number, height: number, rows: [Fragment]}\n// Compute the width and height of a set of cells, and make sure each\n// row has the same number of cells.\n\nfunction ensureRectangular(schema, rows) {\n  let widths = [];\n\n  for (let i = 0; i < rows.length; i++) {\n    let row = rows[i];\n\n    for (let j = row.childCount - 1; j >= 0; j--) {\n      let {\n        rowspan,\n        colspan\n      } = row.child(j).attrs;\n\n      for (let r = i; r < i + rowspan; r++) widths[r] = (widths[r] || 0) + colspan;\n    }\n  }\n\n  let width = 0;\n\n  for (let r = 0; r < widths.length; r++) width = Math.max(width, widths[r]);\n\n  for (let r = 0; r < widths.length; r++) {\n    if (r >= rows.length) rows.push(Fragment.empty);\n\n    if (widths[r] < width) {\n      let empty = tableNodeTypes(schema).cell.createAndFill(),\n          cells = [];\n\n      for (let i = widths[r]; i < width; i++) cells.push(empty);\n\n      rows[r] = rows[r].append(Fragment.from(cells));\n    }\n  }\n\n  return {\n    height: rows.length,\n    width,\n    rows\n  };\n}\n\nfunction fitSlice(nodeType, slice) {\n  let node = nodeType.createAndFill();\n  let tr = new Transform(node).replace(0, node.content.size, slice);\n  return tr.doc;\n} // : ({width: number, height: number, rows: [Fragment]}, number, number) → {width: number, height: number, rows: [Fragment]}\n// Clip or extend (repeat) the given set of cells to cover the given\n// width and height. Will clip rowspan/colspan cells at the edges when\n// they stick out.\n\nfunction clipCells({\n  width,\n  height,\n  rows\n}, newWidth, newHeight) {\n  if (width != newWidth) {\n    let added = [],\n        newRows = [];\n\n    for (let row = 0; row < rows.length; row++) {\n      let frag = rows[row],\n          cells = [];\n\n      for (let col = added[row] || 0, i = 0; col < newWidth; i++) {\n        let cell = frag.child(i % frag.childCount);\n        if (col + cell.attrs.colspan > newWidth) cell = cell.type.create(removeColSpan(cell.attrs, cell.attrs.colspan, col + cell.attrs.colspan - newWidth), cell.content);\n        cells.push(cell);\n        col += cell.attrs.colspan;\n\n        for (let j = 1; j < cell.attrs.rowspan; j++) added[row + j] = (added[row + j] || 0) + cell.attrs.colspan;\n      }\n\n      newRows.push(Fragment.from(cells));\n    }\n\n    rows = newRows;\n    width = newWidth;\n  }\n\n  if (height != newHeight) {\n    let newRows = [];\n\n    for (let row = 0, i = 0; row < newHeight; row++, i++) {\n      let cells = [],\n          source = rows[i % height];\n\n      for (let j = 0; j < source.childCount; j++) {\n        let cell = source.child(j);\n        if (row + cell.attrs.rowspan > newHeight) cell = cell.type.create(setAttr(cell.attrs, 'rowspan', Math.max(1, newHeight - cell.attrs.rowspan)), cell.content);\n        cells.push(cell);\n      }\n\n      newRows.push(Fragment.from(cells));\n    }\n\n    rows = newRows;\n    height = newHeight;\n  }\n\n  return {\n    width,\n    height,\n    rows\n  };\n} // Make sure a table has at least the given width and height. Return\n// true if something was changed.\n\nfunction growTable(tr, map, table, start, width, height, mapFrom) {\n  let schema = tr.doc.type.schema,\n      types = tableNodeTypes(schema),\n      empty,\n      emptyHead;\n\n  if (width > map.width) {\n    for (let row = 0, rowEnd = 0; row < map.height; row++) {\n      let rowNode = table.child(row);\n      rowEnd += rowNode.nodeSize;\n      let cells = [],\n          add;\n      if (rowNode.lastChild == null || rowNode.lastChild.type == types.cell) add = empty || (empty = types.cell.createAndFill());else add = emptyHead || (emptyHead = types.header_cell.createAndFill());\n\n      for (let i = map.width; i < width; i++) cells.push(add);\n\n      tr.insert(tr.mapping.slice(mapFrom).map(rowEnd - 1 + start), cells);\n    }\n  }\n\n  if (height > map.height) {\n    let cells = [];\n\n    for (let i = 0, start = (map.height - 1) * map.width; i < Math.max(map.width, width); i++) {\n      let header = i >= map.width ? false : table.nodeAt(map.map[start + i]).type == types.header_cell;\n      cells.push(header ? emptyHead || (emptyHead = types.header_cell.createAndFill()) : empty || (empty = types.cell.createAndFill()));\n    }\n\n    let emptyRow = types.row.create(null, Fragment.from(cells)),\n        rows = [];\n\n    for (let i = map.height; i < height; i++) rows.push(emptyRow);\n\n    tr.insert(tr.mapping.slice(mapFrom).map(start + table.nodeSize - 2), rows);\n  }\n\n  return !!(empty || emptyHead);\n} // Make sure the given line (left, top) to (right, top) doesn't cross\n// any rowspan cells by splitting cells that cross it. Return true if\n// something changed.\n\n\nfunction isolateHorizontal(tr, map, table, start, left, right, top, mapFrom) {\n  if (top == 0 || top == map.height) return false;\n  let found = false;\n\n  for (let col = left; col < right; col++) {\n    let index = top * map.width + col,\n        pos = map.map[index];\n\n    if (map.map[index - map.width] == pos) {\n      found = true;\n      let cell = table.nodeAt(pos);\n      let {\n        top: cellTop,\n        left: cellLeft\n      } = map.findCell(pos);\n      tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + start), null, setAttr(cell.attrs, 'rowspan', top - cellTop));\n      tr.insert(tr.mapping.slice(mapFrom).map(map.positionAt(top, cellLeft, table)), cell.type.createAndFill(setAttr(cell.attrs, 'rowspan', cellTop + cell.attrs.rowspan - top)));\n      col += cell.attrs.colspan - 1;\n    }\n  }\n\n  return found;\n} // Make sure the given line (left, top) to (left, bottom) doesn't\n// cross any colspan cells by splitting cells that cross it. Return\n// true if something changed.\n\n\nfunction isolateVertical(tr, map, table, start, top, bottom, left, mapFrom) {\n  if (left == 0 || left == map.width) return false;\n  let found = false;\n\n  for (let row = top; row < bottom; row++) {\n    let index = row * map.width + left,\n        pos = map.map[index];\n\n    if (map.map[index - 1] == pos) {\n      found = true;\n      let cell = table.nodeAt(pos),\n          cellLeft = map.colCount(pos);\n      let updatePos = tr.mapping.slice(mapFrom).map(pos + start);\n      tr.setNodeMarkup(updatePos, null, removeColSpan(cell.attrs, left - cellLeft, cell.attrs.colspan - (left - cellLeft)));\n      tr.insert(updatePos + cell.nodeSize, cell.type.createAndFill(removeColSpan(cell.attrs, 0, left - cellLeft)));\n      row += cell.attrs.rowspan - 1;\n    }\n  }\n\n  return found;\n} // Insert the given set of cells (as returned by `pastedCells`) into a\n// table, at the position pointed at by rect.\n\n\nfunction insertCells(state, dispatch, tableStart, rect, cells) {\n  let table = tableStart ? state.doc.nodeAt(tableStart - 1) : state.doc,\n      map = TableMap.get(table);\n  let {\n    top,\n    left\n  } = rect;\n  let right = left + cells.width,\n      bottom = top + cells.height;\n  let tr = state.tr,\n      mapFrom = 0;\n\n  function recomp() {\n    table = tableStart ? tr.doc.nodeAt(tableStart - 1) : tr.doc;\n    map = TableMap.get(table);\n    mapFrom = tr.mapping.maps.length;\n  } // Prepare the table to be large enough and not have any cells\n  // crossing the boundaries of the rectangle that we want to\n  // insert into. If anything about it changes, recompute the table\n  // map so that subsequent operations can see the current shape.\n\n\n  if (growTable(tr, map, table, tableStart, right, bottom, mapFrom)) recomp();\n  if (isolateHorizontal(tr, map, table, tableStart, left, right, top, mapFrom)) recomp();\n  if (isolateHorizontal(tr, map, table, tableStart, left, right, bottom, mapFrom)) recomp();\n  if (isolateVertical(tr, map, table, tableStart, top, bottom, left, mapFrom)) recomp();\n  if (isolateVertical(tr, map, table, tableStart, top, bottom, right, mapFrom)) recomp();\n\n  for (let row = top; row < bottom; row++) {\n    let from = map.positionAt(row, left, table),\n        to = map.positionAt(row, right, table);\n    tr.replace(tr.mapping.slice(mapFrom).map(from + tableStart), tr.mapping.slice(mapFrom).map(to + tableStart), new Slice(cells.rows[row - top], 0, 0));\n  }\n\n  recomp();\n  tr.setSelection(new CellSelection(tr.doc.resolve(tableStart + map.positionAt(top, left, table)), tr.doc.resolve(tableStart + map.positionAt(bottom - 1, right - 1, table))));\n  dispatch(tr);\n}\n\n// This file defines a number of helpers for wiring up user input to\nconst handleKeyDown = keydownHandler({\n  ArrowLeft: arrow('horiz', -1),\n  ArrowRight: arrow('horiz', 1),\n  ArrowUp: arrow('vert', -1),\n  ArrowDown: arrow('vert', 1),\n  'Shift-ArrowLeft': shiftArrow('horiz', -1),\n  'Shift-ArrowRight': shiftArrow('horiz', 1),\n  'Shift-ArrowUp': shiftArrow('vert', -1),\n  'Shift-ArrowDown': shiftArrow('vert', 1),\n  Backspace: deleteCellSelection,\n  'Mod-Backspace': deleteCellSelection,\n  Delete: deleteCellSelection,\n  'Mod-Delete': deleteCellSelection\n});\n\nfunction maybeSetSelection(state, dispatch, selection) {\n  if (selection.eq(state.selection)) return false;\n  if (dispatch) dispatch(state.tr.setSelection(selection).scrollIntoView());\n  return true;\n}\n\nfunction arrow(axis, dir) {\n  return (state, dispatch, view) => {\n    let sel = state.selection;\n\n    if (sel instanceof CellSelection) {\n      return maybeSetSelection(state, dispatch, Selection.near(sel.$headCell, dir));\n    }\n\n    if (axis != 'horiz' && !sel.empty) return false;\n    let end = atEndOfCell(view, axis, dir);\n    if (end == null) return false;\n\n    if (axis == 'horiz') {\n      return maybeSetSelection(state, dispatch, Selection.near(state.doc.resolve(sel.head + dir), dir));\n    } else {\n      let $cell = state.doc.resolve(end),\n          $next = nextCell($cell, axis, dir),\n          newSel;\n      if ($next) newSel = Selection.near($next, 1);else if (dir < 0) newSel = Selection.near(state.doc.resolve($cell.before(-1)), -1);else newSel = Selection.near(state.doc.resolve($cell.after(-1)), 1);\n      return maybeSetSelection(state, dispatch, newSel);\n    }\n  };\n}\n\nfunction shiftArrow(axis, dir) {\n  return (state, dispatch, view) => {\n    let sel = state.selection;\n\n    if (!(sel instanceof CellSelection)) {\n      let end = atEndOfCell(view, axis, dir);\n      if (end == null) return false;\n      sel = new CellSelection(state.doc.resolve(end));\n    }\n\n    let $head = nextCell(sel.$headCell, axis, dir);\n    if (!$head) return false;\n    return maybeSetSelection(state, dispatch, new CellSelection(sel.$anchorCell, $head));\n  };\n}\n\nfunction deleteCellSelection(state, dispatch) {\n  let sel = state.selection;\n  if (!(sel instanceof CellSelection)) return false;\n\n  if (dispatch) {\n    let tr = state.tr,\n        baseContent = tableNodeTypes(state.schema).cell.createAndFill().content;\n    sel.forEachCell((cell, pos) => {\n      if (!cell.content.eq(baseContent)) tr.replace(tr.mapping.map(pos + 1), tr.mapping.map(pos + cell.nodeSize - 1), new Slice(baseContent, 0, 0));\n    });\n    if (tr.docChanged) dispatch(tr);\n  }\n\n  return true;\n}\n\nfunction handleTripleClick(view, pos) {\n  let doc = view.state.doc,\n      $cell = cellAround(doc.resolve(pos));\n  if (!$cell) return false;\n  view.dispatch(view.state.tr.setSelection(new CellSelection($cell)));\n  return true;\n}\nfunction handlePaste(view, _, slice) {\n  if (!isInTable(view.state)) return false;\n  let cells = pastedCells(slice),\n      sel = view.state.selection;\n\n  if (sel instanceof CellSelection) {\n    if (!cells) cells = {\n      width: 1,\n      height: 1,\n      rows: [Fragment.from(fitSlice(tableNodeTypes(view.state.schema).cell, slice))]\n    };\n    let table = sel.$anchorCell.node(-1),\n        start = sel.$anchorCell.start(-1);\n    let rect = TableMap.get(table).rectBetween(sel.$anchorCell.pos - start, sel.$headCell.pos - start);\n    cells = clipCells(cells, rect.right - rect.left, rect.bottom - rect.top);\n    insertCells(view.state, view.dispatch, start, rect, cells);\n    return true;\n  } else if (cells) {\n    let $cell = selectionCell(view.state),\n        start = $cell.start(-1);\n    insertCells(view.state, view.dispatch, start, TableMap.get($cell.node(-1)).findCell($cell.pos - start), cells);\n    return true;\n  } else {\n    return false;\n  }\n}\nfunction handleMouseDown$1(view, startEvent) {\n  if (startEvent.ctrlKey || startEvent.metaKey) return;\n  let startDOMCell = domInCell(view, startEvent.target),\n      $anchor;\n\n  if (startEvent.shiftKey && view.state.selection instanceof CellSelection) {\n    // Adding to an existing cell selection\n    setCellSelection(view.state.selection.$anchorCell, startEvent);\n    startEvent.preventDefault();\n  } else if (startEvent.shiftKey && startDOMCell && ($anchor = cellAround(view.state.selection.$anchor)) != null && cellUnderMouse(view, startEvent).pos != $anchor.pos) {\n    // Adding to a selection that starts in another cell (causing a\n    // cell selection to be created).\n    setCellSelection($anchor, startEvent);\n    startEvent.preventDefault();\n  } else if (!startDOMCell) {\n    // Not in a cell, let the default behavior happen.\n    return;\n  } // Create and dispatch a cell selection between the given anchor and\n  // the position under the mouse.\n\n\n  function setCellSelection($anchor, event) {\n    let $head = cellUnderMouse(view, event);\n    let starting = key$1.getState(view.state) == null;\n\n    if (!$head || !inSameTable($anchor, $head)) {\n      if (starting) $head = $anchor;else return;\n    }\n\n    let selection = new CellSelection($anchor, $head);\n\n    if (starting || !view.state.selection.eq(selection)) {\n      let tr = view.state.tr.setSelection(selection);\n      if (starting) tr.setMeta(key$1, $anchor.pos);\n      view.dispatch(tr);\n    }\n  } // Stop listening to mouse motion events.\n\n\n  function stop() {\n    view.root.removeEventListener('mouseup', stop);\n    view.root.removeEventListener('dragstart', stop);\n    view.root.removeEventListener('mousemove', move);\n    if (key$1.getState(view.state) != null) view.dispatch(view.state.tr.setMeta(key$1, -1));\n  }\n\n  function move(event) {\n    let anchor = key$1.getState(view.state),\n        $anchor;\n\n    if (anchor != null) {\n      // Continuing an existing cross-cell selection\n      $anchor = view.state.doc.resolve(anchor);\n    } else if (domInCell(view, event.target) != startDOMCell) {\n      // Moving out of the initial cell -- start a new cell selection\n      $anchor = cellUnderMouse(view, startEvent);\n      if (!$anchor) return stop();\n    }\n\n    if ($anchor) setCellSelection($anchor, event);\n  }\n\n  view.root.addEventListener('mouseup', stop);\n  view.root.addEventListener('dragstart', stop);\n  view.root.addEventListener('mousemove', move);\n} // Check whether the cursor is at the end of a cell (so that further\n// motion would move out of the cell)\n\nfunction atEndOfCell(view, axis, dir) {\n  if (!(view.state.selection instanceof TextSelection)) return null;\n  let {\n    $head\n  } = view.state.selection;\n\n  for (let d = $head.depth - 1; d >= 0; d--) {\n    let parent = $head.node(d),\n        index = dir < 0 ? $head.index(d) : $head.indexAfter(d);\n    if (index != (dir < 0 ? 0 : parent.childCount)) return null;\n\n    if (parent.type.spec.tableRole == 'cell' || parent.type.spec.tableRole == 'header_cell') {\n      let cellPos = $head.before(d);\n      let dirStr = axis == 'vert' ? dir > 0 ? 'down' : 'up' : dir > 0 ? 'right' : 'left';\n      return view.endOfTextblock(dirStr) ? cellPos : null;\n    }\n  }\n\n  return null;\n}\n\nfunction domInCell(view, dom) {\n  for (; dom && dom != view.dom; dom = dom.parentNode) if (dom.nodeName == 'TD' || dom.nodeName == 'TH') return dom;\n}\n\nfunction cellUnderMouse(view, event) {\n  let mousePos = view.posAtCoords({\n    left: event.clientX,\n    top: event.clientY\n  });\n  if (!mousePos) return null;\n  return mousePos ? cellAround(view.state.doc.resolve(mousePos.pos)) : null;\n}\n\n// This file defines helpers for normalizing tables, making sure no\nconst fixTablesKey = new PluginKey('fix-tables'); // Helper for iterating through the nodes in a document that changed\n// compared to the given previous document. Useful for avoiding\n// duplicate work on each transaction.\n\nfunction changedDescendants(old, cur, offset, f) {\n  let oldSize = old.childCount,\n      curSize = cur.childCount;\n\n  outer: for (let i = 0, j = 0; i < curSize; i++) {\n    let child = cur.child(i);\n\n    for (let scan = j, e = Math.min(oldSize, i + 3); scan < e; scan++) {\n      if (old.child(scan) == child) {\n        j = scan + 1;\n        offset += child.nodeSize;\n        continue outer;\n      }\n    }\n\n    f(child, offset);\n    if (j < oldSize && old.child(j).sameMarkup(child)) changedDescendants(old.child(j), child, offset + 1, f);else child.nodesBetween(0, child.content.size, f, offset + 1);\n    offset += child.nodeSize;\n  }\n} // :: (EditorState, ?EditorState) → ?Transaction\n// Inspect all tables in the given state's document and return a\n// transaction that fixes them, if necessary. If `oldState` was\n// provided, that is assumed to hold a previous, known-good state,\n// which will be used to avoid re-scanning unchanged parts of the\n// document.\n\n\nfunction fixTables(state, oldState) {\n  let tr,\n      check = (node, pos) => {\n    if (node.type.spec.tableRole == 'table') tr = fixTable(state, node, pos, tr);\n  };\n\n  if (!oldState) state.doc.descendants(check);else if (oldState.doc != state.doc) changedDescendants(oldState.doc, state.doc, 0, check);\n  return tr;\n} // : (EditorState, Node, number, ?Transaction) → ?Transaction\n// Fix the given table, if necessary. Will append to the transaction\n// it was given, if non-null, or create a new one if necessary.\n\nfunction fixTable(state, table, tablePos, tr) {\n  let map = TableMap.get(table);\n  if (!map.problems) return tr;\n  if (!tr) tr = state.tr; // Track which rows we must add cells to, so that we can adjust that\n  // when fixing collisions.\n\n  let mustAdd = [];\n\n  for (let i = 0; i < map.height; i++) mustAdd.push(0);\n\n  for (let i = 0; i < map.problems.length; i++) {\n    let prob = map.problems[i];\n\n    if (prob.type == 'collision') {\n      let cell = table.nodeAt(prob.pos);\n\n      for (let j = 0; j < cell.attrs.rowspan; j++) mustAdd[prob.row + j] += prob.n;\n\n      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, removeColSpan(cell.attrs, cell.attrs.colspan - prob.n, prob.n));\n    } else if (prob.type == 'missing') {\n      mustAdd[prob.row] += prob.n;\n    } else if (prob.type == 'overlong_rowspan') {\n      let cell = table.nodeAt(prob.pos);\n      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, setAttr(cell.attrs, 'rowspan', cell.attrs.rowspan - prob.n));\n    } else if (prob.type == 'colwidth mismatch') {\n      let cell = table.nodeAt(prob.pos);\n      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, setAttr(cell.attrs, 'colwidth', prob.colwidth));\n    }\n  }\n\n  let first, last;\n\n  for (let i = 0; i < mustAdd.length; i++) if (mustAdd[i]) {\n    if (first == null) first = i;\n    last = i;\n  } // Add the necessary cells, using a heuristic for whether to add the\n  // cells at the start or end of the rows (if it looks like a 'bite'\n  // was taken out of the table, add cells at the start of the row\n  // after the bite. Otherwise add them at the end).\n\n\n  for (let i = 0, pos = tablePos + 1; i < map.height; i++) {\n    let row = table.child(i);\n    let end = pos + row.nodeSize;\n    let add = mustAdd[i];\n\n    if (add > 0) {\n      let tableNodeType = 'cell';\n\n      if (row.firstChild) {\n        tableNodeType = row.firstChild.type.spec.tableRole;\n      }\n\n      let nodes = [];\n\n      for (let j = 0; j < add; j++) nodes.push(tableNodeTypes(state.schema)[tableNodeType].createAndFill());\n\n      let side = (i == 0 || first == i - 1) && last == i ? pos + 1 : end - 1;\n      tr.insert(tr.mapping.map(side), nodes);\n    }\n\n    pos = end;\n  }\n\n  return tr.setMeta(fixTablesKey, {\n    fixTables: true\n  });\n}\n\n// This file defines a number of table-related commands.\n// map, table node, and table start offset to the object for\n// convenience.\n\nfunction selectedRect(state) {\n  let sel = state.selection,\n      $pos = selectionCell(state);\n  let table = $pos.node(-1),\n      tableStart = $pos.start(-1),\n      map = TableMap.get(table);\n  let rect;\n  if (sel instanceof CellSelection) rect = map.rectBetween(sel.$anchorCell.pos - tableStart, sel.$headCell.pos - tableStart);else rect = map.findCell($pos.pos - tableStart);\n  rect.tableStart = tableStart;\n  rect.map = map;\n  rect.table = table;\n  return rect;\n} // Add a column at the given position in a table.\n\nfunction addColumn(tr, {\n  map,\n  tableStart,\n  table\n}, col) {\n  let refColumn = col > 0 ? -1 : 0;\n  if (columnIsHeader(map, table, col + refColumn)) refColumn = col == 0 || col == map.width ? null : 0;\n\n  for (let row = 0; row < map.height; row++) {\n    let index = row * map.width + col; // If this position falls inside a col-spanning cell\n\n    if (col > 0 && col < map.width && map.map[index - 1] == map.map[index]) {\n      let pos = map.map[index],\n          cell = table.nodeAt(pos);\n      tr.setNodeMarkup(tr.mapping.map(tableStart + pos), null, addColSpan(cell.attrs, col - map.colCount(pos))); // Skip ahead if rowspan > 1\n\n      row += cell.attrs.rowspan - 1;\n    } else {\n      let type = refColumn == null ? tableNodeTypes(table.type.schema).cell : table.nodeAt(map.map[index + refColumn]).type;\n      let pos = map.positionAt(row, col, table);\n      tr.insert(tr.mapping.map(tableStart + pos), type.createAndFill());\n    }\n  }\n\n  return tr;\n} // :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Command to add a column before the column with the selection.\n\nfunction addColumnBefore(state, dispatch) {\n  if (!isInTable(state)) return false;\n\n  if (dispatch) {\n    let rect = selectedRect(state);\n    dispatch(addColumn(state.tr, rect, rect.left));\n  }\n\n  return true;\n} // :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Command to add a column after the column with the selection.\n\nfunction addColumnAfter(state, dispatch) {\n  if (!isInTable(state)) return false;\n\n  if (dispatch) {\n    let rect = selectedRect(state);\n    dispatch(addColumn(state.tr, rect, rect.right));\n  }\n\n  return true;\n}\nfunction removeColumn(tr, {\n  map,\n  table,\n  tableStart\n}, col) {\n  let mapStart = tr.mapping.maps.length;\n\n  for (let row = 0; row < map.height;) {\n    let index = row * map.width + col,\n        pos = map.map[index],\n        cell = table.nodeAt(pos); // If this is part of a col-spanning cell\n\n    if (col > 0 && map.map[index - 1] == pos || col < map.width - 1 && map.map[index + 1] == pos) {\n      tr.setNodeMarkup(tr.mapping.slice(mapStart).map(tableStart + pos), null, removeColSpan(cell.attrs, col - map.colCount(pos)));\n    } else {\n      let start = tr.mapping.slice(mapStart).map(tableStart + pos);\n      tr.delete(start, start + cell.nodeSize);\n    }\n\n    row += cell.attrs.rowspan;\n  }\n} // :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Command function that removes the selected columns from a table.\n\nfunction deleteColumn(state, dispatch) {\n  if (!isInTable(state)) return false;\n\n  if (dispatch) {\n    let rect = selectedRect(state),\n        tr = state.tr;\n    if (rect.left == 0 && rect.right == rect.map.width) return false;\n\n    for (let i = rect.right - 1;; i--) {\n      removeColumn(tr, rect, i);\n      if (i == rect.left) break;\n      rect.table = rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc;\n      rect.map = TableMap.get(rect.table);\n    }\n\n    dispatch(tr);\n  }\n\n  return true;\n}\nfunction rowIsHeader(map, table, row) {\n  let headerCell = tableNodeTypes(table.type.schema).header_cell;\n\n  for (let col = 0; col < map.width; col++) if (table.nodeAt(map.map[col + row * map.width]).type != headerCell) return false;\n\n  return true;\n}\nfunction addRow(tr, {\n  map,\n  tableStart,\n  table\n}, row) {\n  let rowPos = tableStart;\n\n  for (let i = 0; i < row; i++) rowPos += table.child(i).nodeSize;\n\n  let cells = [],\n      refRow = row > 0 ? -1 : 0;\n  if (rowIsHeader(map, table, row + refRow)) refRow = row == 0 || row == map.height ? null : 0;\n\n  for (let col = 0, index = map.width * row; col < map.width; col++, index++) {\n    // Covered by a rowspan cell\n    if (row > 0 && row < map.height && map.map[index] == map.map[index - map.width]) {\n      let pos = map.map[index],\n          attrs = table.nodeAt(pos).attrs;\n      tr.setNodeMarkup(tableStart + pos, null, setAttr(attrs, 'rowspan', attrs.rowspan + 1));\n      col += attrs.colspan - 1;\n    } else {\n      let type = refRow == null ? tableNodeTypes(table.type.schema).cell : table.nodeAt(map.map[index + refRow * map.width]).type;\n      cells.push(type.createAndFill());\n    }\n  }\n\n  tr.insert(rowPos, tableNodeTypes(table.type.schema).row.create(null, cells));\n  return tr;\n} // :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Add a table row before the selection.\n\nfunction addRowBefore(state, dispatch) {\n  if (!isInTable(state)) return false;\n\n  if (dispatch) {\n    let rect = selectedRect(state);\n    dispatch(addRow(state.tr, rect, rect.top));\n  }\n\n  return true;\n} // :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Add a table row after the selection.\n\nfunction addRowAfter(state, dispatch) {\n  if (!isInTable(state)) return false;\n\n  if (dispatch) {\n    let rect = selectedRect(state);\n    dispatch(addRow(state.tr, rect, rect.bottom));\n  }\n\n  return true;\n}\nfunction removeRow(tr, {\n  map,\n  table,\n  tableStart\n}, row) {\n  let rowPos = 0;\n\n  for (let i = 0; i < row; i++) rowPos += table.child(i).nodeSize;\n\n  let nextRow = rowPos + table.child(row).nodeSize;\n  let mapFrom = tr.mapping.maps.length;\n  tr.delete(rowPos + tableStart, nextRow + tableStart);\n\n  for (let col = 0, index = row * map.width; col < map.width; col++, index++) {\n    let pos = map.map[index];\n\n    if (row > 0 && pos == map.map[index - map.width]) {\n      // If this cell starts in the row above, simply reduce its rowspan\n      let attrs = table.nodeAt(pos).attrs;\n      tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + tableStart), null, setAttr(attrs, 'rowspan', attrs.rowspan - 1));\n      col += attrs.colspan - 1;\n    } else if (row < map.width && pos == map.map[index + map.width]) {\n      // Else, if it continues in the row below, it has to be moved down\n      let cell = table.nodeAt(pos);\n      let copy = cell.type.create(setAttr(cell.attrs, 'rowspan', cell.attrs.rowspan - 1), cell.content);\n      let newPos = map.positionAt(row + 1, col, table);\n      tr.insert(tr.mapping.slice(mapFrom).map(tableStart + newPos), copy);\n      col += cell.attrs.colspan - 1;\n    }\n  }\n} // :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Remove the selected rows from a table.\n\nfunction deleteRow(state, dispatch) {\n  if (!isInTable(state)) return false;\n\n  if (dispatch) {\n    let rect = selectedRect(state),\n        tr = state.tr;\n    if (rect.top == 0 && rect.bottom == rect.map.height) return false;\n\n    for (let i = rect.bottom - 1;; i--) {\n      removeRow(tr, rect, i);\n      if (i == rect.top) break;\n      rect.table = rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc;\n      rect.map = TableMap.get(rect.table);\n    }\n\n    dispatch(tr);\n  }\n\n  return true;\n}\n\nfunction isEmpty(cell) {\n  let c = cell.content;\n  return c.childCount == 1 && c.firstChild.isTextblock && c.firstChild.childCount == 0;\n}\n\nfunction cellsOverlapRectangle({\n  width,\n  height,\n  map\n}, rect) {\n  let indexTop = rect.top * width + rect.left,\n      indexLeft = indexTop;\n  let indexBottom = (rect.bottom - 1) * width + rect.left,\n      indexRight = indexTop + (rect.right - rect.left - 1);\n\n  for (let i = rect.top; i < rect.bottom; i++) {\n    if (rect.left > 0 && map[indexLeft] == map[indexLeft - 1] || rect.right < width && map[indexRight] == map[indexRight + 1]) return true;\n    indexLeft += width;\n    indexRight += width;\n  }\n\n  for (let i = rect.left; i < rect.right; i++) {\n    if (rect.top > 0 && map[indexTop] == map[indexTop - width] || rect.bottom < height && map[indexBottom] == map[indexBottom + width]) return true;\n    indexTop++;\n    indexBottom++;\n  }\n\n  return false;\n} // :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Merge the selected cells into a single cell. Only available when\n// the selected cells' outline forms a rectangle.\n\n\nfunction mergeCells(state, dispatch) {\n  let sel = state.selection;\n  if (!(sel instanceof CellSelection) || sel.$anchorCell.pos == sel.$headCell.pos) return false;\n  let rect = selectedRect(state),\n      {\n    map\n  } = rect;\n  if (cellsOverlapRectangle(map, rect)) return false;\n\n  if (dispatch) {\n    let tr = state.tr,\n        seen = {},\n        content = Fragment.empty,\n        mergedPos,\n        mergedCell;\n\n    for (let row = rect.top; row < rect.bottom; row++) {\n      for (let col = rect.left; col < rect.right; col++) {\n        let cellPos = map.map[row * map.width + col],\n            cell = rect.table.nodeAt(cellPos);\n        if (seen[cellPos]) continue;\n        seen[cellPos] = true;\n\n        if (mergedPos == null) {\n          mergedPos = cellPos;\n          mergedCell = cell;\n        } else {\n          if (!isEmpty(cell)) content = content.append(cell.content);\n          let mapped = tr.mapping.map(cellPos + rect.tableStart);\n          tr.delete(mapped, mapped + cell.nodeSize);\n        }\n      }\n    }\n\n    tr.setNodeMarkup(mergedPos + rect.tableStart, null, setAttr(addColSpan(mergedCell.attrs, mergedCell.attrs.colspan, rect.right - rect.left - mergedCell.attrs.colspan), 'rowspan', rect.bottom - rect.top));\n\n    if (content.size) {\n      let end = mergedPos + 1 + mergedCell.content.size;\n      let start = isEmpty(mergedCell) ? mergedPos + 1 : end;\n      tr.replaceWith(start + rect.tableStart, end + rect.tableStart, content);\n    }\n\n    tr.setSelection(new CellSelection(tr.doc.resolve(mergedPos + rect.tableStart)));\n    dispatch(tr);\n  }\n\n  return true;\n} // :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Split a selected cell, whose rowpan or colspan is greater than one,\n// into smaller cells. Use the first cell type for the new cells.\n\nfunction splitCell(state, dispatch) {\n  const nodeTypes = tableNodeTypes(state.schema);\n  return splitCellWithType(({\n    node\n  }) => {\n    return nodeTypes[node.type.spec.tableRole];\n  })(state, dispatch);\n} // :: (getCellType: ({ row: number, col: number, node: Node}) → NodeType) → (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Split a selected cell, whose rowpan or colspan is greater than one,\n// into smaller cells with the cell type (th, td) returned by getType function.\n\nfunction splitCellWithType(getCellType) {\n  return (state, dispatch) => {\n    let sel = state.selection;\n    let cellNode, cellPos;\n\n    if (!(sel instanceof CellSelection)) {\n      cellNode = cellWrapping(sel.$from);\n      if (!cellNode) return false;\n      cellPos = cellAround(sel.$from).pos;\n    } else {\n      if (sel.$anchorCell.pos != sel.$headCell.pos) return false;\n      cellNode = sel.$anchorCell.nodeAfter;\n      cellPos = sel.$anchorCell.pos;\n    }\n\n    if (cellNode.attrs.colspan == 1 && cellNode.attrs.rowspan == 1) {\n      return false;\n    }\n\n    if (dispatch) {\n      let baseAttrs = cellNode.attrs,\n          attrs = [],\n          colwidth = baseAttrs.colwidth;\n      if (baseAttrs.rowspan > 1) baseAttrs = setAttr(baseAttrs, 'rowspan', 1);\n      if (baseAttrs.colspan > 1) baseAttrs = setAttr(baseAttrs, 'colspan', 1);\n      let rect = selectedRect(state),\n          tr = state.tr;\n\n      for (let i = 0; i < rect.right - rect.left; i++) attrs.push(colwidth ? setAttr(baseAttrs, 'colwidth', colwidth && colwidth[i] ? [colwidth[i]] : null) : baseAttrs);\n\n      let lastCell;\n\n      for (let row = rect.top; row < rect.bottom; row++) {\n        let pos = rect.map.positionAt(row, rect.left, rect.table);\n        if (row == rect.top) pos += cellNode.nodeSize;\n\n        for (let col = rect.left, i = 0; col < rect.right; col++, i++) {\n          if (col == rect.left && row == rect.top) continue;\n          tr.insert(lastCell = tr.mapping.map(pos + rect.tableStart, 1), getCellType({\n            node: cellNode,\n            row,\n            col\n          }).createAndFill(attrs[i]));\n        }\n      }\n\n      tr.setNodeMarkup(cellPos, getCellType({\n        node: cellNode,\n        row: rect.top,\n        col: rect.left\n      }), attrs[0]);\n      if (sel instanceof CellSelection) tr.setSelection(new CellSelection(tr.doc.resolve(sel.$anchorCell.pos), lastCell && tr.doc.resolve(lastCell)));\n      dispatch(tr);\n    }\n\n    return true;\n  };\n} // :: (string, any) → (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Returns a command that sets the given attribute to the given value,\n// and is only available when the currently selected cell doesn't\n// already have that attribute set to that value.\n\nfunction setCellAttr(name, value) {\n  return function (state, dispatch) {\n    if (!isInTable(state)) return false;\n    let $cell = selectionCell(state);\n    if ($cell.nodeAfter.attrs[name] === value) return false;\n\n    if (dispatch) {\n      let tr = state.tr;\n      if (state.selection instanceof CellSelection) state.selection.forEachCell((node, pos) => {\n        if (node.attrs[name] !== value) tr.setNodeMarkup(pos, null, setAttr(node.attrs, name, value));\n      });else tr.setNodeMarkup($cell.pos, null, setAttr($cell.nodeAfter.attrs, name, value));\n      dispatch(tr);\n    }\n\n    return true;\n  };\n}\n\nfunction deprecated_toggleHeader(type) {\n  return function (state, dispatch) {\n    if (!isInTable(state)) return false;\n\n    if (dispatch) {\n      let types = tableNodeTypes(state.schema);\n      let rect = selectedRect(state),\n          tr = state.tr;\n      let cells = rect.map.cellsInRect(type == 'column' ? new Rect(rect.left, 0, rect.right, rect.map.height) : type == 'row' ? new Rect(0, rect.top, rect.map.width, rect.bottom) : rect);\n      let nodes = cells.map(pos => rect.table.nodeAt(pos));\n\n      for (let i = 0; i < cells.length; i++ // Remove headers, if any\n      ) if (nodes[i].type == types.header_cell) tr.setNodeMarkup(rect.tableStart + cells[i], types.cell, nodes[i].attrs);\n\n      if (tr.steps.length == 0) for (let i = 0; i < cells.length; i++ // No headers removed, add instead\n      ) tr.setNodeMarkup(rect.tableStart + cells[i], types.header_cell, nodes[i].attrs);\n      dispatch(tr);\n    }\n\n    return true;\n  };\n}\n\nfunction isHeaderEnabledByType(type, rect, types) {\n  // Get cell positions for first row or first column\n  const cellPositions = rect.map.cellsInRect({\n    left: 0,\n    top: 0,\n    right: type == 'row' ? rect.map.width : 1,\n    bottom: type == 'column' ? rect.map.height : 1\n  });\n\n  for (let i = 0; i < cellPositions.length; i++) {\n    const cell = rect.table.nodeAt(cellPositions[i]);\n\n    if (cell && cell.type !== types.header_cell) {\n      return false;\n    }\n  }\n\n  return true;\n} // :: (string, ?{ useDeprecatedLogic: bool }) → (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Toggles between row/column header and normal cells (Only applies to first row/column).\n// For deprecated behavior pass `useDeprecatedLogic` in options with true.\n\n\nfunction toggleHeader(type, options) {\n  options = options || {\n    useDeprecatedLogic: false\n  };\n  if (options.useDeprecatedLogic) return deprecated_toggleHeader(type);\n  return function (state, dispatch) {\n    if (!isInTable(state)) return false;\n\n    if (dispatch) {\n      let types = tableNodeTypes(state.schema);\n      let rect = selectedRect(state),\n          tr = state.tr;\n      let isHeaderRowEnabled = isHeaderEnabledByType('row', rect, types);\n      let isHeaderColumnEnabled = isHeaderEnabledByType('column', rect, types);\n      let isHeaderEnabled = type === 'column' ? isHeaderRowEnabled : type === 'row' ? isHeaderColumnEnabled : false;\n      let selectionStartsAt = isHeaderEnabled ? 1 : 0;\n      let cellsRect = type == 'column' ? new Rect(0, selectionStartsAt, 1, rect.map.height) : type == 'row' ? new Rect(selectionStartsAt, 0, rect.map.width, 1) : rect;\n      let newType = type == 'column' ? isHeaderColumnEnabled ? types.cell : types.header_cell : type == 'row' ? isHeaderRowEnabled ? types.cell : types.header_cell : types.cell;\n      rect.map.cellsInRect(cellsRect).forEach(relativeCellPos => {\n        const cellPos = relativeCellPos + rect.tableStart;\n        const cell = tr.doc.nodeAt(cellPos);\n\n        if (cell) {\n          tr.setNodeMarkup(cellPos, newType, cell.attrs);\n        }\n      });\n      dispatch(tr);\n    }\n\n    return true;\n  };\n} // :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Toggles whether the selected row contains header cells.\n\ntoggleHeader('row', {\n  useDeprecatedLogic: true\n}); // :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Toggles whether the selected column contains header cells.\n\ntoggleHeader('column', {\n  useDeprecatedLogic: true\n}); // :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Toggles whether the selected cells are header cells.\n\nlet toggleHeaderCell = toggleHeader('cell', {\n  useDeprecatedLogic: true\n});\n\nfunction findNextCell($cell, dir) {\n  if (dir < 0) {\n    let before = $cell.nodeBefore;\n    if (before) return $cell.pos - before.nodeSize;\n\n    for (let row = $cell.index(-1) - 1, rowEnd = $cell.before(); row >= 0; row--) {\n      let rowNode = $cell.node(-1).child(row);\n      if (rowNode.childCount) return rowEnd - 1 - rowNode.lastChild.nodeSize;\n      rowEnd -= rowNode.nodeSize;\n    }\n  } else {\n    if ($cell.index() < $cell.parent.childCount - 1) return $cell.pos + $cell.nodeAfter.nodeSize;\n    let table = $cell.node(-1);\n\n    for (let row = $cell.indexAfter(-1), rowStart = $cell.after(); row < table.childCount; row++) {\n      let rowNode = table.child(row);\n      if (rowNode.childCount) return rowStart + 1;\n      rowStart += rowNode.nodeSize;\n    }\n  }\n} // :: (number) → (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Returns a command for selecting the next (direction=1) or previous\n// (direction=-1) cell in a table.\n\n\nfunction goToNextCell(direction) {\n  return function (state, dispatch) {\n    if (!isInTable(state)) return false;\n    let cell = findNextCell(selectionCell(state), direction);\n    if (cell == null) return;\n\n    if (dispatch) {\n      let $cell = state.doc.resolve(cell);\n      dispatch(state.tr.setSelection(TextSelection.between($cell, moveCellForward($cell))).scrollIntoView());\n    }\n\n    return true;\n  };\n} // :: (EditorState, ?(tr: Transaction)) → bool\n// Deletes the table around the selection, if any.\n\nfunction deleteTable(state, dispatch) {\n  let $pos = state.selection.$anchor;\n\n  for (let d = $pos.depth; d > 0; d--) {\n    let node = $pos.node(d);\n\n    if (node.type.spec.tableRole == 'table') {\n      if (dispatch) dispatch(state.tr.delete($pos.before(d), $pos.after(d)).scrollIntoView());\n      return true;\n    }\n  }\n\n  return false;\n}\n\nclass TableView$1 {\n  constructor(node, cellMinWidth) {\n    this.node = node;\n    this.cellMinWidth = cellMinWidth;\n    this.dom = document.createElement('div');\n    this.dom.className = 'tableWrapper';\n    this.table = this.dom.appendChild(document.createElement('table'));\n    this.colgroup = this.table.appendChild(document.createElement('colgroup'));\n    updateColumns$1(node, this.colgroup, this.table, cellMinWidth);\n    this.contentDOM = this.table.appendChild(document.createElement('tbody'));\n  }\n\n  update(node) {\n    if (node.type != this.node.type) return false;\n    this.node = node;\n    updateColumns$1(node, this.colgroup, this.table, this.cellMinWidth);\n    return true;\n  }\n\n  ignoreMutation(record) {\n    return record.type == 'attributes' && (record.target == this.table || this.colgroup.contains(record.target));\n  }\n\n}\nfunction updateColumns$1(node, colgroup, table, cellMinWidth, overrideCol, overrideValue) {\n  let totalWidth = 0,\n      fixedWidth = true;\n  let nextDOM = colgroup.firstChild,\n      row = node.firstChild;\n\n  for (let i = 0, col = 0; i < row.childCount; i++) {\n    let {\n      colspan,\n      colwidth\n    } = row.child(i).attrs;\n\n    for (let j = 0; j < colspan; j++, col++) {\n      let hasWidth = overrideCol == col ? overrideValue : colwidth && colwidth[j];\n      let cssWidth = hasWidth ? hasWidth + 'px' : '';\n      totalWidth += hasWidth || cellMinWidth;\n      if (!hasWidth) fixedWidth = false;\n\n      if (!nextDOM) {\n        colgroup.appendChild(document.createElement('col')).style.width = cssWidth;\n      } else {\n        if (nextDOM.style.width != cssWidth) nextDOM.style.width = cssWidth;\n        nextDOM = nextDOM.nextSibling;\n      }\n    }\n  }\n\n  while (nextDOM) {\n    let after = nextDOM.nextSibling;\n    nextDOM.parentNode.removeChild(nextDOM);\n    nextDOM = after;\n  }\n\n  if (fixedWidth) {\n    table.style.width = totalWidth + 'px';\n    table.style.minWidth = '';\n  } else {\n    table.style.width = '';\n    table.style.minWidth = totalWidth + 'px';\n  }\n}\n\nconst key = new PluginKey('tableColumnResizing');\nfunction columnResizing({\n  handleWidth = 5,\n  cellMinWidth = 25,\n  View = TableView$1,\n  lastColumnResizable = true\n} = {}) {\n  let plugin = new Plugin({\n    key,\n    state: {\n      init(_, state) {\n        this.spec.props.nodeViews[tableNodeTypes(state.schema).table.name] = (node, view) => new View(node, cellMinWidth, view);\n\n        return new ResizeState(-1, false);\n      },\n\n      apply(tr, prev) {\n        return prev.apply(tr);\n      }\n\n    },\n    props: {\n      attributes(state) {\n        let pluginState = key.getState(state);\n        return pluginState.activeHandle > -1 ? {\n          class: 'resize-cursor'\n        } : null;\n      },\n\n      handleDOMEvents: {\n        mousemove(view, event) {\n          handleMouseMove(view, event, handleWidth, cellMinWidth, lastColumnResizable);\n        },\n\n        mouseleave(view) {\n          handleMouseLeave(view);\n        },\n\n        mousedown(view, event) {\n          handleMouseDown(view, event, cellMinWidth);\n        }\n\n      },\n\n      decorations(state) {\n        let pluginState = key.getState(state);\n        if (pluginState.activeHandle > -1) return handleDecorations(state, pluginState.activeHandle);\n      },\n\n      nodeViews: {}\n    }\n  });\n  return plugin;\n}\n\nclass ResizeState {\n  constructor(activeHandle, dragging) {\n    this.activeHandle = activeHandle;\n    this.dragging = dragging;\n  }\n\n  apply(tr) {\n    let state = this,\n        action = tr.getMeta(key);\n    if (action && action.setHandle != null) return new ResizeState(action.setHandle, null);\n    if (action && action.setDragging !== undefined) return new ResizeState(state.activeHandle, action.setDragging);\n\n    if (state.activeHandle > -1 && tr.docChanged) {\n      let handle = tr.mapping.map(state.activeHandle, -1);\n      if (!pointsAtCell(tr.doc.resolve(handle))) handle = null;\n      state = new ResizeState(handle, state.dragging);\n    }\n\n    return state;\n  }\n\n}\n\nfunction handleMouseMove(view, event, handleWidth, cellMinWidth, lastColumnResizable) {\n  let pluginState = key.getState(view.state);\n\n  if (!pluginState.dragging) {\n    let target = domCellAround(event.target),\n        cell = -1;\n\n    if (target) {\n      let {\n        left,\n        right\n      } = target.getBoundingClientRect();\n      if (event.clientX - left <= handleWidth) cell = edgeCell(view, event, 'left');else if (right - event.clientX <= handleWidth) cell = edgeCell(view, event, 'right');\n    }\n\n    if (cell != pluginState.activeHandle) {\n      if (!lastColumnResizable && cell !== -1) {\n        let $cell = view.state.doc.resolve(cell);\n        let table = $cell.node(-1),\n            map = TableMap.get(table),\n            start = $cell.start(-1);\n        let col = map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;\n\n        if (col == map.width - 1) {\n          return;\n        }\n      }\n\n      updateHandle(view, cell);\n    }\n  }\n}\n\nfunction handleMouseLeave(view) {\n  let pluginState = key.getState(view.state);\n  if (pluginState.activeHandle > -1 && !pluginState.dragging) updateHandle(view, -1);\n}\n\nfunction handleMouseDown(view, event, cellMinWidth) {\n  let pluginState = key.getState(view.state);\n  if (pluginState.activeHandle == -1 || pluginState.dragging) return false;\n  let cell = view.state.doc.nodeAt(pluginState.activeHandle);\n  let width = currentColWidth(view, pluginState.activeHandle, cell.attrs);\n  view.dispatch(view.state.tr.setMeta(key, {\n    setDragging: {\n      startX: event.clientX,\n      startWidth: width\n    }\n  }));\n\n  function finish(event) {\n    window.removeEventListener('mouseup', finish);\n    window.removeEventListener('mousemove', move);\n    let pluginState = key.getState(view.state);\n\n    if (pluginState.dragging) {\n      updateColumnWidth(view, pluginState.activeHandle, draggedWidth(pluginState.dragging, event, cellMinWidth));\n      view.dispatch(view.state.tr.setMeta(key, {\n        setDragging: null\n      }));\n    }\n  }\n\n  function move(event) {\n    if (!event.which) return finish(event);\n    let pluginState = key.getState(view.state);\n    let dragged = draggedWidth(pluginState.dragging, event, cellMinWidth);\n    displayColumnWidth(view, pluginState.activeHandle, dragged, cellMinWidth);\n  }\n\n  window.addEventListener('mouseup', finish);\n  window.addEventListener('mousemove', move);\n  event.preventDefault();\n  return true;\n}\n\nfunction currentColWidth(view, cellPos, {\n  colspan,\n  colwidth\n}) {\n  let width = colwidth && colwidth[colwidth.length - 1];\n  if (width) return width;\n  let dom = view.domAtPos(cellPos);\n  let node = dom.node.childNodes[dom.offset];\n  let domWidth = node.offsetWidth,\n      parts = colspan;\n  if (colwidth) for (let i = 0; i < colspan; i++) if (colwidth[i]) {\n    domWidth -= colwidth[i];\n    parts--;\n  }\n  return domWidth / parts;\n}\n\nfunction domCellAround(target) {\n  while (target && target.nodeName != 'TD' && target.nodeName != 'TH') target = target.classList.contains('ProseMirror') ? null : target.parentNode;\n\n  return target;\n}\n\nfunction edgeCell(view, event, side) {\n  let found = view.posAtCoords({\n    left: event.clientX,\n    top: event.clientY\n  });\n  if (!found) return -1;\n  let {\n    pos\n  } = found;\n  let $cell = cellAround(view.state.doc.resolve(pos));\n  if (!$cell) return -1;\n  if (side == 'right') return $cell.pos;\n  let map = TableMap.get($cell.node(-1)),\n      start = $cell.start(-1);\n  let index = map.map.indexOf($cell.pos - start);\n  return index % map.width == 0 ? -1 : start + map.map[index - 1];\n}\n\nfunction draggedWidth(dragging, event, cellMinWidth) {\n  let offset = event.clientX - dragging.startX;\n  return Math.max(cellMinWidth, dragging.startWidth + offset);\n}\n\nfunction updateHandle(view, value) {\n  view.dispatch(view.state.tr.setMeta(key, {\n    setHandle: value\n  }));\n}\n\nfunction updateColumnWidth(view, cell, width) {\n  let $cell = view.state.doc.resolve(cell);\n  let table = $cell.node(-1),\n      map = TableMap.get(table),\n      start = $cell.start(-1);\n  let col = map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;\n  let tr = view.state.tr;\n\n  for (let row = 0; row < map.height; row++) {\n    let mapIndex = row * map.width + col; // Rowspanning cell that has already been handled\n\n    if (row && map.map[mapIndex] == map.map[mapIndex - map.width]) continue;\n    let pos = map.map[mapIndex],\n        {\n      attrs\n    } = table.nodeAt(pos);\n    let index = attrs.colspan == 1 ? 0 : col - map.colCount(pos);\n    if (attrs.colwidth && attrs.colwidth[index] == width) continue;\n    let colwidth = attrs.colwidth ? attrs.colwidth.slice() : zeroes(attrs.colspan);\n    colwidth[index] = width;\n    tr.setNodeMarkup(start + pos, null, setAttr(attrs, 'colwidth', colwidth));\n  }\n\n  if (tr.docChanged) view.dispatch(tr);\n}\n\nfunction displayColumnWidth(view, cell, width, cellMinWidth) {\n  let $cell = view.state.doc.resolve(cell);\n  let table = $cell.node(-1),\n      start = $cell.start(-1);\n  let col = TableMap.get(table).colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;\n  let dom = view.domAtPos($cell.start(-1)).node;\n\n  while (dom.nodeName != 'TABLE') dom = dom.parentNode;\n\n  updateColumns$1(table, dom.firstChild, dom, cellMinWidth, col, width);\n}\n\nfunction zeroes(n) {\n  let result = [];\n\n  for (let i = 0; i < n; i++) result.push(0);\n\n  return result;\n}\n\nfunction handleDecorations(state, cell) {\n  let decorations = [];\n  let $cell = state.doc.resolve(cell);\n  let table = $cell.node(-1),\n      map = TableMap.get(table),\n      start = $cell.start(-1);\n  let col = map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan;\n\n  for (let row = 0; row < map.height; row++) {\n    let index = col + row * map.width - 1; // For positions that are have either a different cell or the end\n    // of the table to their right, and either the top of the table or\n    // a different cell above them, add a decoration\n\n    if ((col == map.width || map.map[index] != map.map[index + 1]) && (row == 0 || map.map[index - 1] != map.map[index - 1 - map.width])) {\n      let cellPos = map.map[index];\n      let pos = start + cellPos + table.nodeAt(cellPos).nodeSize - 1;\n      let dom = document.createElement('div');\n      dom.className = 'column-resize-handle';\n      decorations.push(Decoration.widget(pos, dom));\n    }\n  }\n\n  return DecorationSet.create(state.doc, decorations);\n}\n\n// This file defines a plugin that handles the drawing of cell\n//\n// Creates a [plugin](http://prosemirror.net/docs/ref/#state.Plugin)\n// that, when added to an editor, enables cell-selection, handles\n// cell-based copy/paste, and makes sure tables stay well-formed (each\n// row has the same width, and cells don't overlap).\n//\n// You should probably put this plugin near the end of your array of\n// plugins, since it handles mouse and arrow key events in tables\n// rather broadly, and other plugins, like the gap cursor or the\n// column-width dragging plugin, might want to get a turn first to\n// perform more specific behavior.\n\nfunction tableEditing({\n  allowTableNodeSelection = false\n} = {}) {\n  return new Plugin({\n    key: key$1,\n    // This piece of state is used to remember when a mouse-drag\n    // cell-selection is happening, so that it can continue even as\n    // transactions (which might move its anchor cell) come in.\n    state: {\n      init() {\n        return null;\n      },\n\n      apply(tr, cur) {\n        let set = tr.getMeta(key$1);\n        if (set != null) return set == -1 ? null : set;\n        if (cur == null || !tr.docChanged) return cur;\n        let {\n          deleted,\n          pos\n        } = tr.mapping.mapResult(cur);\n        return deleted ? null : pos;\n      }\n\n    },\n    props: {\n      decorations: drawCellSelection,\n      handleDOMEvents: {\n        mousedown: handleMouseDown$1\n      },\n\n      createSelectionBetween(view) {\n        if (key$1.getState(view.state) != null) return view.state.selection;\n      },\n\n      handleTripleClick,\n      handleKeyDown,\n      handlePaste\n    },\n\n    appendTransaction(_, oldState, state) {\n      return normalizeSelection(state, fixTables(state, oldState), allowTableNodeSelection);\n    }\n\n  });\n}\n\nfunction updateColumns(node, colgroup, table, cellMinWidth, overrideCol, overrideValue) {\r\n    let totalWidth = 0;\r\n    let fixedWidth = true;\r\n    let nextDOM = colgroup.firstChild;\r\n    const row = node.firstChild;\r\n    for (let i = 0, col = 0; i < row.childCount; i += 1) {\r\n        const { colspan, colwidth } = row.child(i).attrs;\r\n        for (let j = 0; j < colspan; j += 1, col += 1) {\r\n            const hasWidth = overrideCol === col ? overrideValue : colwidth && colwidth[j];\r\n            const cssWidth = hasWidth ? `${hasWidth}px` : '';\r\n            totalWidth += hasWidth || cellMinWidth;\r\n            if (!hasWidth) {\r\n                fixedWidth = false;\r\n            }\r\n            if (!nextDOM) {\r\n                colgroup.appendChild(document.createElement('col')).style.width = cssWidth;\r\n            }\r\n            else {\r\n                if (nextDOM.style.width !== cssWidth) {\r\n                    nextDOM.style.width = cssWidth;\r\n                }\r\n                nextDOM = nextDOM.nextSibling;\r\n            }\r\n        }\r\n    }\r\n    while (nextDOM) {\r\n        const after = nextDOM.nextSibling;\r\n        nextDOM.parentNode.removeChild(nextDOM);\r\n        nextDOM = after;\r\n    }\r\n    if (fixedWidth) {\r\n        table.style.width = `${totalWidth}px`;\r\n        table.style.minWidth = '';\r\n    }\r\n    else {\r\n        table.style.width = '';\r\n        table.style.minWidth = `${totalWidth}px`;\r\n    }\r\n}\r\nclass TableView {\r\n    constructor(node, cellMinWidth) {\r\n        this.node = node;\r\n        this.cellMinWidth = cellMinWidth;\r\n        this.dom = document.createElement('div');\r\n        this.dom.className = 'tableWrapper';\r\n        this.table = this.dom.appendChild(document.createElement('table'));\r\n        this.colgroup = this.table.appendChild(document.createElement('colgroup'));\r\n        updateColumns(node, this.colgroup, this.table, cellMinWidth);\r\n        this.contentDOM = this.table.appendChild(document.createElement('tbody'));\r\n    }\r\n    update(node) {\r\n        if (node.type !== this.node.type) {\r\n            return false;\r\n        }\r\n        this.node = node;\r\n        updateColumns(node, this.colgroup, this.table, this.cellMinWidth);\r\n        return true;\r\n    }\r\n    ignoreMutation(mutation) {\r\n        return mutation.type === 'attributes' && (mutation.target === this.table || this.colgroup.contains(mutation.target));\r\n    }\r\n}\n\nfunction createCell(cellType, cellContent) {\r\n    if (cellContent) {\r\n        return cellType.createChecked(null, cellContent);\r\n    }\r\n    return cellType.createAndFill();\r\n}\n\nfunction getTableNodeTypes(schema) {\r\n    if (schema.cached.tableNodeTypes) {\r\n        return schema.cached.tableNodeTypes;\r\n    }\r\n    const roles = {};\r\n    Object.keys(schema.nodes).forEach(type => {\r\n        const nodeType = schema.nodes[type];\r\n        if (nodeType.spec.tableRole) {\r\n            roles[nodeType.spec.tableRole] = nodeType;\r\n        }\r\n    });\r\n    schema.cached.tableNodeTypes = roles;\r\n    return roles;\r\n}\n\nfunction createTable(schema, rowsCount, colsCount, withHeaderRow, cellContent) {\r\n    const types = getTableNodeTypes(schema);\r\n    const headerCells = [];\r\n    const cells = [];\r\n    for (let index = 0; index < colsCount; index += 1) {\r\n        const cell = createCell(types.cell, cellContent);\r\n        if (cell) {\r\n            cells.push(cell);\r\n        }\r\n        if (withHeaderRow) {\r\n            const headerCell = createCell(types.header_cell, cellContent);\r\n            if (headerCell) {\r\n                headerCells.push(headerCell);\r\n            }\r\n        }\r\n    }\r\n    const rows = [];\r\n    for (let index = 0; index < rowsCount; index += 1) {\r\n        rows.push(types.row.createChecked(null, withHeaderRow && index === 0 ? headerCells : cells));\r\n    }\r\n    return types.table.createChecked(null, rows);\r\n}\n\nfunction isCellSelection(value) {\r\n    return value instanceof CellSelection;\r\n}\n\nconst deleteTableWhenAllCellsSelected = ({ editor }) => {\r\n    const { selection } = editor.state;\r\n    if (!isCellSelection(selection)) {\r\n        return false;\r\n    }\r\n    let cellCount = 0;\r\n    const table = findParentNodeClosestToPos(selection.ranges[0].$from, node => {\r\n        return node.type.name === 'table';\r\n    });\r\n    table === null || table === void 0 ? void 0 : table.node.descendants(node => {\r\n        if (node.type.name === 'table') {\r\n            return false;\r\n        }\r\n        if (['tableCell', 'tableHeader'].includes(node.type.name)) {\r\n            cellCount += 1;\r\n        }\r\n    });\r\n    const allCellsSelected = cellCount === selection.ranges.length;\r\n    if (!allCellsSelected) {\r\n        return false;\r\n    }\r\n    editor.commands.deleteTable();\r\n    return true;\r\n};\n\nconst Table = Node.create({\r\n    name: 'table',\r\n    // @ts-ignore\r\n    addOptions() {\r\n        return {\r\n            HTMLAttributes: {},\r\n            resizable: false,\r\n            handleWidth: 5,\r\n            cellMinWidth: 25,\r\n            // TODO: fix\r\n            View: TableView,\r\n            lastColumnResizable: true,\r\n            allowTableNodeSelection: false,\r\n        };\r\n    },\r\n    content: 'tableRow+',\r\n    tableRole: 'table',\r\n    isolating: true,\r\n    group: 'block',\r\n    parseHTML() {\r\n        return [\r\n            { tag: 'table' },\r\n        ];\r\n    },\r\n    renderHTML({ HTMLAttributes }) {\r\n        return ['table', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), ['tbody', 0]];\r\n    },\r\n    addCommands() {\r\n        return {\r\n            insertTable: ({ rows = 3, cols = 3, withHeaderRow = true } = {}) => ({ tr, dispatch, editor }) => {\r\n                const node = createTable(editor.schema, rows, cols, withHeaderRow);\r\n                if (dispatch) {\r\n                    const offset = tr.selection.anchor + 1;\r\n                    tr.replaceSelectionWith(node)\r\n                        .scrollIntoView()\r\n                        .setSelection(TextSelection.near(tr.doc.resolve(offset)));\r\n                }\r\n                return true;\r\n            },\r\n            addColumnBefore: () => ({ state, dispatch }) => {\r\n                return addColumnBefore(state, dispatch);\r\n            },\r\n            addColumnAfter: () => ({ state, dispatch }) => {\r\n                return addColumnAfter(state, dispatch);\r\n            },\r\n            deleteColumn: () => ({ state, dispatch }) => {\r\n                return deleteColumn(state, dispatch);\r\n            },\r\n            addRowBefore: () => ({ state, dispatch }) => {\r\n                return addRowBefore(state, dispatch);\r\n            },\r\n            addRowAfter: () => ({ state, dispatch }) => {\r\n                return addRowAfter(state, dispatch);\r\n            },\r\n            deleteRow: () => ({ state, dispatch }) => {\r\n                return deleteRow(state, dispatch);\r\n            },\r\n            deleteTable: () => ({ state, dispatch }) => {\r\n                return deleteTable(state, dispatch);\r\n            },\r\n            mergeCells: () => ({ state, dispatch }) => {\r\n                return mergeCells(state, dispatch);\r\n            },\r\n            splitCell: () => ({ state, dispatch }) => {\r\n                return splitCell(state, dispatch);\r\n            },\r\n            toggleHeaderColumn: () => ({ state, dispatch }) => {\r\n                return toggleHeader('column')(state, dispatch);\r\n            },\r\n            toggleHeaderRow: () => ({ state, dispatch }) => {\r\n                return toggleHeader('row')(state, dispatch);\r\n            },\r\n            toggleHeaderCell: () => ({ state, dispatch }) => {\r\n                return toggleHeaderCell(state, dispatch);\r\n            },\r\n            mergeOrSplit: () => ({ state, dispatch }) => {\r\n                if (mergeCells(state, dispatch)) {\r\n                    return true;\r\n                }\r\n                return splitCell(state, dispatch);\r\n            },\r\n            setCellAttribute: (name, value) => ({ state, dispatch }) => {\r\n                return setCellAttr(name, value)(state, dispatch);\r\n            },\r\n            goToNextCell: () => ({ state, dispatch }) => {\r\n                return goToNextCell(1)(state, dispatch);\r\n            },\r\n            goToPreviousCell: () => ({ state, dispatch }) => {\r\n                return goToNextCell(-1)(state, dispatch);\r\n            },\r\n            fixTables: () => ({ state, dispatch }) => {\r\n                if (dispatch) {\r\n                    fixTables(state);\r\n                }\r\n                return true;\r\n            },\r\n            setCellSelection: position => ({ tr, dispatch }) => {\r\n                if (dispatch) {\r\n                    const selection = CellSelection.create(tr.doc, position.anchorCell, position.headCell);\r\n                    // @ts-ignore\r\n                    tr.setSelection(selection);\r\n                }\r\n                return true;\r\n            },\r\n        };\r\n    },\r\n    addKeyboardShortcuts() {\r\n        return {\r\n            Tab: () => {\r\n                if (this.editor.commands.goToNextCell()) {\r\n                    return true;\r\n                }\r\n                if (!this.editor.can().addRowAfter()) {\r\n                    return false;\r\n                }\r\n                return this.editor\r\n                    .chain()\r\n                    .addRowAfter()\r\n                    .goToNextCell()\r\n                    .run();\r\n            },\r\n            'Shift-Tab': () => this.editor.commands.goToPreviousCell(),\r\n            Backspace: deleteTableWhenAllCellsSelected,\r\n            'Mod-Backspace': deleteTableWhenAllCellsSelected,\r\n            Delete: deleteTableWhenAllCellsSelected,\r\n            'Mod-Delete': deleteTableWhenAllCellsSelected,\r\n        };\r\n    },\r\n    addProseMirrorPlugins() {\r\n        const isResizable = this.options.resizable && this.editor.isEditable;\r\n        return [\r\n            ...(isResizable ? [columnResizing({\r\n                    handleWidth: this.options.handleWidth,\r\n                    cellMinWidth: this.options.cellMinWidth,\r\n                    View: this.options.View,\r\n                    // TODO: PR for @types/prosemirror-tables\r\n                    // @ts-ignore (incorrect type)\r\n                    lastColumnResizable: this.options.lastColumnResizable,\r\n                })] : []),\r\n            tableEditing({\r\n                allowTableNodeSelection: this.options.allowTableNodeSelection,\r\n            }),\r\n        ];\r\n    },\r\n    extendNodeSchema(extension) {\r\n        const context = {\r\n            name: extension.name,\r\n            options: extension.options,\r\n            storage: extension.storage,\r\n        };\r\n        return {\r\n            tableRole: callOrReturn(getExtensionField(extension, 'tableRole', context)),\r\n        };\r\n    },\r\n});\n\nexport { Table, createTable, Table as default };\n//# sourceMappingURL=tiptap-extension-table.esm.js.map\n"],"names":["base","shift","chrome","navigator","exec","userAgent","safari","test","vendor","gecko","mac$1","platform","ie","brokenModifierNames","i","String","fromCharCode","code","hasOwnProperty","mac","normalizeKeyName","name","alt","ctrl","meta","parts","split","result","length","mod","Error","modifiers","event","altKey","ctrlKey","metaKey","shiftKey","factor16","Math","pow","recoverIndex","value","MapResult","constructor","pos","delInfo","recover","this","deleted","deletedBefore","deletedAfter","deletedAcross","StepMap","ranges","inverted","empty","diff","index","recoverOffset","mapResult","assoc","_map","map","simple","oldIndex","newIndex","start","oldSize","newSize","end","del","touches","forEach","f","oldStart","newStart","invert","toString","JSON","stringify","static","n","Mapping","maps","mirror","from","to","slice","copy","appendMap","mirrors","push","setMirror","appendMapping","mapping","startSize","mirr","getMirror","undefined","m","appendMappingInverted","totalSize","inverse","corr","stepsByID","Object","create","Step","getMap","merge","other","schema","json","stepType","RangeError","type","fromJSON","id","stepClass","prototype","jsonID","StepResult","doc","failed","message","ok","replace","e","fail","mapFragment","fragment","parent","mapped","childCount","child","content","size","isInline","AddMarkStep","mark","super","apply","oldSlice","$from","resolve","node","sharedDepth","isAtom","allowsMarkType","addToSet","marks","openStart","openEnd","fromReplace","RemoveMarkStep","eq","min","max","toJSON","markFromJSON","removeFromSet","AddNodeMarkStep","nodeAt","updated","attrs","isLeaf","newSet","isInSet","RemoveNodeMarkStep","ReplaceStep","structure","contentBetween","append","ReplaceAroundStep","gapFrom","gapTo","insert","gap","inserted","insertAt","removeBetween","dist","depth","indexAfter","next","maybeChild","firstChild","fitsTrivially","$to","canReplace","Fitter","unplaced","frontier","placed","match","contentMatchAt","fit","findFittable","placeNodes","openMore","dropNode","moveInline","mustMoveInline","placedSize","close","pass","sliceDepth","contentAt","first","frontierDepth","wrap","inject","matchType","fillBefore","compatibleContent","findWrapping","inner","openAtEnd","dropFromFragment","closeFrontierNode","openFrontierNode","taken","add","matchFragment","openEndCount","matches","closeNodeStart","allowedMarks","toEnd","addToFragment","cur","lastChild","isTextblock","level","top","contentAfterFits","findCloseLevel","after","scan","dropInner","d","move","contentMatch","pop","count","cutByIndex","replaceChild","frag","open","allowsMarks","invalidMarks","definesContent","spec","defining","definingForContent","closeFragment","oldOpen","newOpen","coveredDepths","isolating","inlineContent","AttrStep","attr","readFromCache","addToCache","TransformError","err","call","__proto__","Transform","steps","docs","before","step","maybeStep","addStep","docChanged","replaceStep","replaceWith","delete","replaceRange","tr","deleteRange","targetDepths","preferredTarget","unshift","definingAsContext","indexOf","splice","preferredTargetIndex","leftNodes","preferredDepth","def","j","openDepth","targetDepth","expand","canReplaceWith","startSteps","replaceRangeWith","point","nodeType","$pos","parentOffset","insertPoint","covered","last","validEnd","lift","range","target","gapStart","gapEnd","splitting","join","wrappers","setBlockType","mapFrom","nodesBetween","hasMarkup","canChangeType","clearIncompatible","startM","endM","nodeSize","setNodeMarkup","newNode","validContent","setNodeAttribute","addNodeMark","removeNodeMark","typesAfter","typeAfter","addMark","removing","adding","removed","added","s","removeMark","matched","toRemove","found","set","style","parentType","delSteps","allowed","fill","WeakMap","cache","key","get","cacheSize","cachePos","Rect","left","right","bottom","TableMap","width","height","problems","findCell","curPos","colCount","nextCell","axis","dir","rectBetween","a","b","leftA","rightA","topA","bottomA","leftB","rightB","topB","bottomB","cellsInRect","rect","seen","row","col","positionAt","table","rowStart","rowEnd","rowEndIndex","tableRole","hasRowSpan","rowNode","rowWidth","prevRow","cell","rowspan","colspan","findWidth","mapPos","colWidths","cellNode","colwidth","h","w","colW","widthIndex","prev","expectedPos","missing","tableMap","badWidths","colWidth","freshColWidth","findBadColWidths","computeMap","tableNodeTypes","cached","nodes","role","key$1","cellAround","isInTable","state","$head","selection","selectionCell","sel","$anchorCell","$headCell","$anchor","nodeAfter","nodeBefore","cellNear","pointsAtCell","inSameTable","$a","$b","moved","setAttr","prop","removeColSpan","some","addColSpan","CellSelection","cells","filter","p","tableChanged","isRowSelection","rowSelection","isColSelection","colSelection","rows","rowContent","cellRect","extraLeft","extraRight","createAndFill","setSelection","forEachCell","anchorTop","headTop","anchorBot","headBot","anchorRect","headRect","anchorLeft","headLeft","anchorRight","headRight","anchor","head","anchorCell","headCell","getBookmark","CellBookmark","visible","drawCellSelection","class","pastedCells","fitSlice","widths","r","ensureRectangular","isolateHorizontal","cellTop","cellLeft","isolateVertical","updatePos","insertCells","dispatch","tableStart","recomp","emptyHead","types","header_cell","header","emptyRow","growTable","handleKeyDown","bindings","normalize","view","baseName","keyCode","keyName","isChar","direct","charCodeAt","fromCode","withShift","keydownHandler","ArrowLeft","arrow","ArrowRight","ArrowUp","ArrowDown","shiftArrow","Backspace","deleteCellSelection","Delete","maybeSetSelection","scrollIntoView","atEndOfCell","newSel","$cell","$next","baseContent","handleTripleClick","handlePaste","_","newWidth","newHeight","newRows","source","clipCells","handleMouseDown$1","startEvent","startDOMCell","domInCell","setCellSelection","preventDefault","cellUnderMouse","starting","getState","setMeta","stop","root","removeEventListener","addEventListener","cellPos","dirStr","endOfTextblock","dom","parentNode","nodeName","mousePos","posAtCoords","clientX","clientY","fixTablesKey","changedDescendants","old","offset","curSize","outer","sameMarkup","fixTables","oldState","check","tablePos","mustAdd","prob","tableNodeType","side","fixTable","descendants","selectedRect","addColumn","refColumn","headerCell","columnIsHeader","removeColumn","mapStart","addRow","rowPos","refRow","rowIsHeader","removeRow","nextRow","newPos","isEmpty","c","mergeCells","indexTop","indexLeft","indexBottom","indexRight","cellsOverlapRectangle","mergedPos","mergedCell","splitCell","nodeTypes","getCellType","cellWrapping","baseAttrs","lastCell","isHeaderEnabledByType","cellPositions","toggleHeader","options","useDeprecatedLogic","deprecated_toggleHeader","isHeaderRowEnabled","isHeaderColumnEnabled","selectionStartsAt","cellsRect","newType","relativeCellPos","toggleHeaderCell","goToNextCell","direction","findNextCell","TableView$1","cellMinWidth","document","createElement","className","appendChild","colgroup","updateColumns$1","contentDOM","update","ignoreMutation","record","contains","overrideCol","overrideValue","totalWidth","fixedWidth","nextDOM","hasWidth","cssWidth","nextSibling","removeChild","minWidth","columnResizing","handleWidth","View","lastColumnResizable","plugin","init","props","nodeViews","ResizeState","attributes","activeHandle","handleDOMEvents","mousemove","pluginState","dragging","classList","domCellAround","getBoundingClientRect","edgeCell","updateHandle","handleMouseMove","mouseleave","handleMouseLeave","mousedown","domAtPos","domWidth","childNodes","offsetWidth","currentColWidth","finish","window","mapIndex","zeroes","updateColumnWidth","draggedWidth","setDragging","which","dragged","displayColumnWidth","startX","startWidth","handleMouseDown","decorations","handleDecorations","action","getMeta","setHandle","handle","tableEditing","allowTableNodeSelection","createSelectionBetween","appendTransaction","afterFrom","beforeTo","isCellBoundarySelection","fromCellBoundaryNode","toCellBoundaryNode","isTextSelectionAcrossCells","normalizeSelection","updateColumns","TableView","mutation","createCell","cellType","cellContent","createChecked","createTable","rowsCount","colsCount","withHeaderRow","roles","keys","getTableNodeTypes","headerCells","deleteTableWhenAllCellsSelected","editor","cellCount","findParentNodeClosestToPos","includes","commands","deleteTable","Table","Node","addOptions","HTMLAttributes","resizable","group","parseHTML","tag","renderHTML","mergeAttributes","addCommands","insertTable","cols","replaceSelectionWith","addColumnBefore","addColumnAfter","deleteColumn","addRowBefore","addRowAfter","deleteRow","toggleHeaderColumn","toggleHeaderRow","mergeOrSplit","setCellAttribute","setCellAttr","goToPreviousCell","position","addKeyboardShortcuts","Tab","can","chain","run","addProseMirrorPlugins","isEditable","extendNodeSchema","extension","context","storage","callOrReturn","getExtensionField"],"sourceRoot":""}