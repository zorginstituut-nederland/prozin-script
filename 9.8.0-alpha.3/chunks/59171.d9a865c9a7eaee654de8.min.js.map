{"version":3,"file":"chunks/59171.d9a865c9a7eaee654de8.min.js","mappings":"uNASIA,E,8dARJ,8lGAAAC,GAAA,wBAAAA,EAAA,sBAAAA,GAAA,iBAAAA,GAAA,ssDAAAA,EAAA,yBAAAA,GAAA,IAAAA,EAAA,uBAAAA,GAAA,4bAAAA,EAAA,yBAAAA,GAAA,IAAAA,EAAA,uBAAAA,GAAA,yhBAAAA,EAAA,yBAAAA,GAAA,IAAAA,EAAA,uBAAAA,GAAA,qGAAAA,EAAA,yBAAAA,GAAA,IAAAA,EAAA,uBAAAA,GAAA,szBAAAA,EAAA,EAAAA,EAAA,iBAAAA,IAAA,uBAAAA,GAAA,UAAAA,GAAA,GAAAA,EAAA,8aAAAA,EAAA,gDAAAA,GAAA,oCAAAA,KAAA,+jCAAAA,EAAA,iBAAAA,EAAA,EAAAA,IAAA,EAAAA,GAAA,EAAAA,GAAA,+HAAAA,EAAA,EAAAA,EAAA,SAAAA,IAAA,SAAAA,GAAA,sgDAUA,SAASC,EAA2B,GAAc,IAAPC,EAAG,EAARA,IAC5BC,EAAO,aAXjB,qRAWiB,UAXjB,MAWiB,6DAqBR,OAhCT,EAWiB,GAXjB,EAWiB,mBAIT,YACIC,EAAAA,EAAAA,eAAcC,KAAKC,IAEnB,IAAMC,EAAWF,KAAKC,GAAGE,cAAc,sBACjCC,EAAaJ,KAAKC,GAAGE,cAAc,wBAEzCD,GACIA,EAASG,iBAAiB,SAAS,WAC/BR,EAAIS,QAAQC,MAAMC,OACtB,IAEJJ,GACIA,EAAWC,iBAAiB,SAAS,WACjCR,EAAIY,OAAOC,SAASC,mBACpBd,EAAIY,OAAOC,SAASE,kBACpBf,EAAIY,OAAOC,SAASG,OACxB,GACR,MAhCR,8EAgCS,EArBQ,CAASC,EAAAA,GAwBtB,OAxBiC,EAA3BhB,EAAO,OACK,6BAA2B,EADvCA,EAAO,UAEQ,8BAsBdA,CACX,CAwLO,SAASiB,EAAK,GAAiB,IAAflB,EAAG,EAAHA,IAAKmB,EAAM,EAANA,OACxBA,EAAOX,iBAAiB,SAAS,WAC7B,GAAIY,EAAAA,EAAAA,SAAapB,EAAIqB,WAAY,kBAAmB,QAAUrB,EAA9D,CAYA,IAAMsB,EApMd,SAAqB,GAAS,MAAPtB,EAAG,EAAHA,IAInB,MAAO,CACHuB,KAAM,qBACNC,QAA0B,QAAnB,EAAExB,EAAIyB,QAAQf,aAAK,aAAjB,EAAmBgB,MAE5BR,KAAI,SAACS,GAAa,MACRC,EAAaD,EAAYE,iBAAiB,qBAC1CC,EAAYH,EAAYrB,cAAc,qBACtCyB,EAAcJ,EAAYrB,cAAc,uBACxC0B,EAAgBL,EAAYrB,cAAc,yBAC1C2B,EAAgBN,EAAYrB,cAAc,2CAChDJ,EAAAA,EAAAA,eAAcyB,GAEd,IAAMO,EAAa/B,KAAK+B,WAGxB,GAAIA,EAAY,OAmB2B,EAGJ,EArB7BC,EAA8B,QAAnB,EAAGD,EAAWE,aAAK,aAAhB,EAAkBC,IAElCC,EAAcH,EACZ,EAAIP,GAAYW,QAAO,SAACC,GAAE,OAAKA,EAAGC,QAAUN,CAAW,IACvD,GACN,GAAIG,EAAYI,OAAS,EAAG,KACW,EADX,IACAJ,GAAW,IAAnC,IAAK,EAAL,qBAAqC,KAA1BK,EAAS,QAChBA,EAAUC,SAAU,EACpBD,EAAUE,cAAcC,EAAAA,EAAAA,eAC5B,CAAC,+BACL,KAAO,CACH,IAAIR,EAAc,EAAIV,GAAYW,QAC9B,SAACC,GAAE,MAAiB,SAAZA,EAAGO,MAA+B,QAAZP,EAAGO,IAAc,IAE/CT,EAAYI,OAAS,IAAMJ,EAAY,GAAGG,QAC1CH,EAAY,GAAGG,MAAQN,GAAe,GAE9C,CACIJ,IAAgBA,EAAYU,QAC5BV,EAAYU,OAAwB,QAAhB,EAAAP,EAAWE,aAAK,aAAhB,EAAkBY,QAAS,IAE/ClB,IAAcA,EAAUW,QACxBX,EAAUW,OAAwB,QAAhB,EAAAP,EAAWE,aAAK,aAAhB,EAAkBa,MAAO,GAEnD,CAGA,IAAMC,EAAkB/C,KAAKgD,gBACzBD,GAAmBlB,IAAkBA,EAAcS,QACnDT,EAAcS,MAAQS,EAAgBE,aAAe,IAGzD,IAAMC,EAAkB,SAACC,GAErB,IAAMC,EAAqB5B,EAAYrB,cAAc,wVASrDN,EAAIY,OAAOC,SAAS2C,cAAc,CAC9BT,KAAM,SACNU,QAAS,CACL,CACIV,KAAM,eACNX,MAAO,EAAF,GACDC,IAAKkB,EAAmBd,QACpBX,aAAS,EAATA,EAAWW,QAAS,CAAEQ,IAAKnB,EAAUW,SACrCV,aAAW,EAAXA,EAAaU,QAAS,CACtBO,MAAOjB,EAAYU,UAG9B,SAEGT,SAAAA,EAAeS,MACb,CACI,CACIM,KAAM,aACNU,QAAS,CACL,CACIV,KAAM,OACNW,KAAM1B,EAAcS,UAKpC,QAGI,IAAda,IAGAtD,EAAIY,OAAOC,SAASC,mBACpBd,EAAIY,OAAOC,SAASG,MAAMhB,EAAIY,OAAO+C,MAAMC,UAAUC,IAG7D,EAGMC,EAAqD,QAAjD,EAAG1C,EAAAA,EAAAA,sBAA0BO,EAAa,eAAO,aAA9C,EAAiD,GAQ9D,GAPImC,GACAhB,EAAAA,EAAAA,mBAA0BgB,EAAM,SAAU,uBAAuB,SAACC,GAG9DA,EAAEC,gBACN,IAEA/B,EAEAa,EAAAA,EAAAA,mBACIb,EACA,QACA,wBACA,kBAAMoB,GAAgB,EAAK,QAE5B,CACH,IACkC,EADlC,IACwBzB,GAAU,IAAlC,IAAK,EAAL,qBAAoC,KAAzBe,EAAS,QAChBG,EAAAA,EAAAA,mBACIH,EACA,SACA,mBACAU,EAER,CAAC,+BACDP,EAAAA,EAAAA,mBACIhB,EACA,SACA,mBACAuB,GAEJP,EAAAA,EAAAA,mBACIf,EACA,SACA,qBACAsB,GAEJP,EAAAA,EAAAA,mBACId,EACA,SACA,uBACAqB,EAER,CACJ,EAEAY,YAAa,KACT/B,iBAEA,OAAI/B,KAAK8D,kBAAoCC,IAArB/D,KAAK8D,cAG7B9D,KAAK8D,YAAcjE,EAAIY,OAAO+C,MAAMQ,IAAIC,OACpCpE,EAAIY,OAAO+C,MAAMC,UAAUS,OAHpBlE,KAAK8D,WAMpB,EAEAK,YAAa,KACTnB,sBAAkB,MAGlB,GAAIhD,KAAKmE,kBAAoCJ,IAArB/D,KAAKmE,YACzB,OAAOnE,KAAKmE,YAGhBtE,EAAIY,OAAOC,SAASC,mBACpB,IAAMyD,EAAcvE,EAAIY,OAAO+C,MAAMQ,IAAIC,OACrCpE,EAAIY,OAAO+C,MAAMC,UAAUS,MAEzBnB,EAAkBqB,SAEvB,QAFkC,EAAXA,EAAad,QAAQA,QAAQlB,QACjD,SAACC,GAAE,MAAsB,eAAjBA,EAAGO,KAAKxB,IAAqB,WACxC,WAFkC,EAAX,EAEpB,GAEJ,OADApB,KAAKmE,YAAcpB,EACZA,CACX,EAER,CAgBoCvB,CAAY,CAAE3B,IAAKA,IAC/CwE,SAAShE,iBACL,6BACA,SAACuD,GACGzC,EAAoBJ,KAAK6C,EAAEU,OAAOC,UAGlC1E,EAAI2E,cAAcnE,iBAAiB,6BAA6B,WAE5Dc,EAAoBJ,KAAKlB,EAAI2E,cACjC,GACJ,GACA,CAAEC,MAAM,GAnBZ,CAqBJ,IAEA5E,EAAIY,OAAOiE,GAAG,kBAAiB,YAAE,8EAC7B7E,EAAIY,OAAOkE,SAAS,gBACd3D,EAAO4D,UAAUC,IAAI,UACrB7D,EAAO4D,UAAUE,OAAO,UAC9BjF,EAAIY,OAAOsE,MAAMC,WACXhE,EAAO4D,UAAUE,OAAO,YACxB9D,EAAO4D,UAAUC,IAAI,YAEvBhF,EAAIyB,QAAQf,MAAM0E,MAElBC,EAAAA,EAAAA,SAAc,YAAC,iFACNrF,EAAIY,OAAOkE,SAAS,gBAAiB,CAAF,eASnC,OAPGjF,KAEAyF,EAAAA,EAAAA,GAAmB,CACfC,SAAU1F,EACV2F,aAAc,8BAElB3F,EAAwB,MAC3B,2CAKyB4F,EAAAA,EAAAA,GAAa,CACvCC,IAAK1F,EAAIyB,QAAQf,MAAM0E,KACvBxE,OAAQZ,EAAIY,OACZ2E,SAAU1F,EACV8F,QAAS5F,EAA2B,CAAEC,IAAKA,IAC3C4F,YAAa,sBACf,OANF/F,EAAwB,EAAH,gDAOtB,GAtBHwF,GAuBH,2CAET,CAEO,IAAMQ,EAAU,WACnB,OAAOC,EAAAA,KAAAA,OAAY,CACfvE,KAAM,eAENwE,WAAU,WACN,MAAO,CACHC,eAAgB,CAAC,EAEzB,EAEAC,cAAa,WACT,MAAO,CACH5D,IAAK,CACD6D,QAAS,MAEbjD,IAAK,CACDiD,QAAS,MAEblD,MAAO,CACHkD,QAAS,MAGrB,EAEAC,MAAO,QACPC,QAAQ,EAERC,gBAAgB,EAChBC,MAAM,EACNC,WAAW,EACXC,WAAW,EACXC,YAAY,EAEZC,UAAS,WACL,MAAO,CACH,CACIC,IAAK,MACLC,SAAU,SAACC,GAAI,OAAgC,OAA3BA,EAAKC,QAAQ,WAAsB,IAAI,GAGvE,EAEAC,WAAU,YAAqB,IAAlBf,EAAc,EAAdA,eACT,MAAO,CAAC,OAAOgB,EAAAA,EAAAA,iBAAgB7G,KAAKsB,QAAQuE,eAAgBA,GAChE,EAEAiB,sBAAqB,WACjB,MAAO,CACH,IAAIC,EAAAA,GAAO,CACPC,MAAO,CACHC,gBAAiB,CACbC,UAAW,SAACC,EAAMC,GAGd,OADAA,EAAMvD,kBACC,CACX,MAKpB,GAER,C","sources":["webpack://@patternslib/patternslib/./node_modules/@patternslib/pat-tiptap/src/extensions/image-figure.js"],"sourcesContent":["import { context_menu, context_menu_close } from \"../context_menu\";\nimport { focus_handler } from \"../focus-handler\";\nimport { Node, mergeAttributes } from \"@tiptap/core\";\nimport { Plugin } from \"prosemirror-state\";\nimport { BasePattern } from \"@patternslib/patternslib/src/core/basepattern\";\nimport dom from \"@patternslib/patternslib/src/core/dom\";\nimport events from \"@patternslib/patternslib/src/core/events\";\nimport utils from \"@patternslib/patternslib/src/core/utils\";\n\nlet context_menu_instance;\n\nfunction pattern_image_context_menu({ app: app }) {\n    class Pattern extends BasePattern {\n        static name = \"tiptap-image-context-menu\";\n        static trigger = \".tiptap-image-context-menu\";\n\n        init() {\n            focus_handler(this.el);\n\n            const btn_edit = this.el.querySelector(\".tiptap-edit-image\");\n            const btn_remove = this.el.querySelector(\".tiptap-remove-image\");\n\n            btn_edit &&\n                btn_edit.addEventListener(\"click\", () => {\n                    app.toolbar.image.click();\n                });\n\n            btn_remove &&\n                btn_remove.addEventListener(\"click\", () => {\n                    app.editor.commands.selectParentNode(); // Also select the surrounding <figure>\n                    app.editor.commands.deleteSelection();\n                    app.editor.commands.focus();\n                });\n        }\n    }\n\n    return Pattern;\n}\n\nfunction image_panel({ app }) {\n    // Not Base-pattern based due to two reasons:\n    // - We need to reinitialize the pattern on already initialized nodes on possible tab-changes within the modal.\n    // - We need to keep the _node_image and _figcaption references among re-initializations.\n    return {\n        name: \"tiptap-image-panel\",\n        trigger: app.options.image?.panel,\n\n        init(image_panel) {\n            const image_srcs = image_panel.querySelectorAll(\"[name=tiptap-src]\");\n            const image_alt = image_panel.querySelector(\"[name=tiptap-alt]\");\n            const image_title = image_panel.querySelector(\"[name=tiptap-title]\");\n            const image_caption = image_panel.querySelector(\"[name=tiptap-caption]\");\n            const image_confirm = image_panel.querySelector(\".tiptap-confirm, [name=tiptap-confirm]\"); // prettier-ignore\n            focus_handler(image_panel);\n\n            const node_image = this.node_image;\n\n            // Populate form fields\n            if (node_image) {\n                const current_src = node_image.attrs?.src;\n                // Filter for all inputs with the same src value but not an empty src.\n                let image_srcs_ = current_src\n                    ? [...image_srcs].filter((it) => it.value === current_src)\n                    : [];\n                if (image_srcs_.length > 0) {\n                    for (const image_src of image_srcs_) {\n                        image_src.checked = true;\n                        image_src.dispatchEvent(events.change_event());\n                    }\n                } else {\n                    let image_srcs_ = [...image_srcs].filter(\n                        (it) => it.type === \"text\" || it.type === \"url\"\n                    );\n                    if (image_srcs_.length > 0 && !image_srcs_[0].value) {\n                        image_srcs_[0].value = current_src || \"\";\n                    }\n                }\n                if (image_title && !image_title.value) {\n                    image_title.value = node_image.attrs?.title || \"\";\n                }\n                if (image_alt && !image_alt.value) {\n                    image_alt.value = node_image.attrs?.alt || \"\";\n                }\n            }\n\n            // Get / set figcaption node, if it exists\n            const node_figcaption = this.figcaption_node;\n            if (node_figcaption && image_caption && !image_caption.value) {\n                image_caption.value = node_figcaption.textContent || \"\";\n            }\n\n            const update_callback = (set_focus) => {\n                // Get the selected image on time of submitting\n                const selected_image_src = image_panel.querySelector(\n                    `[name=tiptap-src][type=radio]:checked,\n                         [name=tiptap-src][type=checkbox]:checked,\n                         [name=tiptap-src][type=option]:checked,\n                         [name=tiptap-src][type=hidden],\n                         [name=tiptap-src][type=text],\n                         [name=tiptap-src][type=url]`\n                );\n\n                app.editor.commands.insertContent({\n                    type: \"figure\",\n                    content: [\n                        {\n                            type: \"image-figure\",\n                            attrs: {\n                                src: selected_image_src.value,\n                                ...(image_alt?.value && { alt: image_alt.value }),\n                                ...(image_title?.value && {\n                                    title: image_title.value,\n                                }),\n                            },\n                        },\n                        // Conditionally add a figcaption\n                        ...(image_caption?.value\n                            ? [\n                                  {\n                                      type: \"figcaption\",\n                                      content: [\n                                          {\n                                              type: \"text\",\n                                              text: image_caption.value,\n                                          },\n                                      ],\n                                  },\n                              ]\n                            : []),\n                    ],\n                });\n                if (set_focus === true) {\n                    // set cursor after the image, otherwise image is\n                    // selected and right away deleted when starting typing.\n                    app.editor.commands.selectParentNode();\n                    app.editor.commands.focus(app.editor.state.selection.to);\n                    //app.editor.commands.blur();\n                }\n            };\n\n            // FORM UPDATE\n            const form = dom.querySelectorAllAndMe(image_panel, \"form\")?.[0];\n            if (form) {\n                events.add_event_listener(form, \"submit\", \"tiptap_image_submit\", (e) => {\n                    // Prevent form submission when hitting \"enter\" within the form.\n                    // The form is handled by JS only.\n                    e.preventDefault();\n                });\n            }\n            if (image_confirm) {\n                // update on click on confirm\n                events.add_event_listener(\n                    image_confirm,\n                    \"click\",\n                    \"tiptap_image_confirm\",\n                    () => update_callback(true)\n                );\n            } else {\n                // update on input/change\n                for (const image_src of image_srcs) {\n                    events.add_event_listener(\n                        image_src,\n                        \"change\",\n                        \"tiptap_image_src\",\n                        update_callback\n                    );\n                }\n                events.add_event_listener(\n                    image_alt,\n                    \"change\",\n                    \"tiptap_image_alt\",\n                    update_callback\n                );\n                events.add_event_listener(\n                    image_title,\n                    \"change\",\n                    \"tiptap_image_title\",\n                    update_callback\n                );\n                events.add_event_listener(\n                    image_caption,\n                    \"change\",\n                    \"tiptap_image_caption\",\n                    update_callback\n                );\n            }\n        },\n\n        _node_image: null,\n        get node_image() {\n            // Get image node\n            if (this._node_image || this._node_image === undefined) {\n                return this._node_image;\n            }\n            this._node_image = app.editor.state.doc.nodeAt(\n                app.editor.state.selection.from\n            );\n            return this._node_image;\n        },\n\n        _figcaption: null, // initialized as null. If not found this will be set to undefined.\n        get figcaption_node() {\n            // Return cached figcaption and avoid calling this method multiple times.\n            // Calling it again would select again a parent node which would lead to incorrect results.\n            if (this._figcaption || this._figcaption === undefined) {\n                return this._figcaption;\n            }\n\n            app.editor.commands.selectParentNode(); // Also select the surrounding <figure>\n            const node_figure = app.editor.state.doc.nodeAt(\n                app.editor.state.selection.from\n            );\n            const node_figcaption = node_figure?.content.content.filter(\n                (it) => it.type.name === \"figcaption\"\n            )?.[0];\n            this._figcaption = node_figcaption; // if not found, this is undefined.\n            return node_figcaption;\n        },\n    };\n}\n\nexport function init({ app, button }) {\n    button.addEventListener(\"click\", () => {\n        if (dom.get_data(app.toolbar_el, \"tiptap-instance\", null) !== app) {\n            // If this pat-tiptap instance is not the one which was last\n            // focused, just return and do nothing.\n            // This might be due to one toolbar shared by multiple editors.\n            return;\n        }\n\n        // Register the image-panel pattern.\n        // Multiple registrations from different tiptap instances are possible\n        // since we're registering it only after the toolbar's image button has\n        // been clicked and clicking in another tiptap instance would override\n        // previous registrations.\n        const image_panel_pattern = image_panel({ app: app });\n        document.addEventListener(\n            \"patterns-injected-delayed\",\n            (e) => {\n                image_panel_pattern.init(e.detail.injected);\n\n                // Register listener on modal for any DOM changes done by pat-inject.\n                app.current_modal.addEventListener(\"patterns-injected-delayed\", () => {\n                    // Re-init panel after injection.\n                    image_panel_pattern.init(app.current_modal);\n                });\n            },\n            { once: true }\n        );\n    });\n\n    app.editor.on(\"selectionUpdate\", async () => {\n        app.editor.isActive(\"image-figure\")\n            ? button.classList.add(\"active\")\n            : button.classList.remove(\"active\");\n        app.editor.can().setImage()\n            ? button.classList.remove(\"disabled\")\n            : button.classList.add(\"disabled\");\n\n        if (app.options.image.menu) {\n            // Open the context menu with a small delay.\n            utils.debounce(async () => {\n                if (!app.editor.isActive(\"image-figure\")) {\n                    // Image not active anymore. Return.\n                    if (context_menu_instance) {\n                        // If open, close.\n                        context_menu_close({\n                            instance: context_menu_instance,\n                            pattern_name: \"tiptap-image-context-menu\",\n                        });\n                        context_menu_instance = null;\n                    }\n                    return;\n                }\n\n                // Initialize the context menu\n                context_menu_instance = await context_menu({\n                    url: app.options.image.menu,\n                    editor: app.editor,\n                    instance: context_menu_instance,\n                    pattern: pattern_image_context_menu({ app: app }),\n                    extra_class: \"tiptap-image-menu\",\n                });\n            }, 50)();\n        }\n    });\n}\n\nexport const factory = () => {\n    return Node.create({\n        name: \"image-figure\",\n\n        addOptions() {\n            return {\n                HTMLAttributes: {},\n            };\n        },\n\n        addAttributes() {\n            return {\n                src: {\n                    default: null,\n                },\n                alt: {\n                    default: null,\n                },\n                title: {\n                    default: null,\n                },\n            };\n        },\n\n        group: \"block\",\n        inline: false,\n\n        allowGapCursor: false,\n        atom: true,\n        draggable: false,\n        isolating: true,\n        selectable: true,\n\n        parseHTML() {\n            return [\n                {\n                    tag: \"img\",\n                    getAttrs: (node) => node.closest(\"figure\") !== null && null, // prosemirror expects null for a successful check.\n                },\n            ];\n        },\n\n        renderHTML({ HTMLAttributes }) {\n            return [\"img\", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];\n        },\n\n        addProseMirrorPlugins() {\n            return [\n                new Plugin({\n                    props: {\n                        handleDOMEvents: {\n                            dragstart: (view, event) => {\n                                // prevent drag/drop at all.\n                                event.preventDefault();\n                                return false;\n                            },\n                        },\n                    },\n                }),\n            ];\n        },\n    });\n};\n"],"names":["context_menu_instance","i","pattern_image_context_menu","app","Pattern","focus_handler","this","el","btn_edit","querySelector","btn_remove","addEventListener","toolbar","image","click","editor","commands","selectParentNode","deleteSelection","focus","BasePattern","init","button","dom","toolbar_el","image_panel_pattern","name","trigger","options","panel","image_panel","image_srcs","querySelectorAll","image_alt","image_title","image_caption","image_confirm","node_image","current_src","attrs","src","image_srcs_","filter","it","value","length","image_src","checked","dispatchEvent","events","type","title","alt","node_figcaption","figcaption_node","textContent","update_callback","set_focus","selected_image_src","insertContent","content","text","state","selection","to","form","e","preventDefault","_node_image","undefined","doc","nodeAt","from","_figcaption","node_figure","document","detail","injected","current_modal","once","on","isActive","classList","add","remove","can","setImage","menu","utils","context_menu_close","instance","pattern_name","context_menu","url","pattern","extra_class","factory","Node","addOptions","HTMLAttributes","addAttributes","default","group","inline","allowGapCursor","atom","draggable","isolating","selectable","parseHTML","tag","getAttrs","node","closest","renderHTML","mergeAttributes","addProseMirrorPlugins","Plugin","props","handleDOMEvents","dragstart","view","event"],"sourceRoot":""}