{"version":3,"file":"chunks/58462.bd25759a4a27297bb754.min.js","mappings":"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","sources":["webpack://ploneintranet-patterns/./node_modules/@patternslib/patternslib/src/pat/scroll/scroll.js"],"sourcesContent":["import \"../../core/jquery-ext\";\nimport $ from \"jquery\";\nimport Base from \"../../core/base\";\nimport dom from \"../../core/dom\";\nimport logging from \"../../core/logging\";\nimport Parser from \"../../core/parser\";\nimport utils from \"../../core/utils\";\n\nconst log = logging.getLogger(\"pat.scroll\");\n\nexport const parser = new Parser(\"scroll\");\nparser.addArgument(\"trigger\", \"click\", [\"click\", \"auto\", \"manual\"]);\nparser.addArgument(\"direction\", \"top\", [\"top\", \"left\"]);\nparser.addArgument(\"selector\");\nparser.addArgument(\"offset\", 0);\nparser.addArgument(\"delay\");\n\nexport default Base.extend({\n    name: \"scroll\",\n    trigger: \".pat-scroll\",\n    jquery_plugin: true,\n\n    async init($el, opts) {\n        this.options = parser.parse(this.$el, opts);\n        if (this.options.delay) {\n            this.options.delay = utils.parseTime(this.options.delay);\n        }\n        if (this.options.trigger === \"auto\") {\n            const ImagesLoaded = (await import(\"imagesloaded\")).default;\n            // Only calculate the offset when all images are loaded\n            ImagesLoaded(document.body, () => this.smoothScroll());\n        }\n        if (this.options.trigger === \"auto\" || this.options.trigger === \"click\") {\n            this.el.addEventListener(\"click\", this.onClick.bind(this));\n        }\n        this.$el.on(\"pat-update\", this.onPatternsUpdate.bind(this));\n        this.markBasedOnFragment();\n        this.on(\"hashchange\", this.clearIfHidden.bind(this));\n        $(window).scroll(utils.debounce(this.markIfVisible.bind(this), 50));\n    },\n\n    onClick() {\n        //ev.preventDefault();\n        history.pushState({}, null, this.$el.attr(\"href\"));\n        this.smoothScroll();\n        this.markBasedOnFragment();\n        // manually trigger the hashchange event on all instances of pat-scroll\n        $(\"a.pat-scroll\").trigger(\"hashchange\");\n    },\n\n    markBasedOnFragment() {\n        // Get the fragment from the URL and set the corresponding this.$el as current\n        const fragment = window.location.hash.substr(1);\n        if (fragment) {\n            const $target = $(\"#\" + fragment);\n            this.$el.addClass(\"current\"); // the element that was clicked on\n            $target.addClass(\"current\");\n        }\n    },\n\n    clearIfHidden() {\n        const active_target = \"#\" + window.location.hash.substr(1);\n        const $active_target = $(active_target);\n        const target = \"#\" + this.$el[0].href.split(\"#\").pop();\n        if ($active_target.length > 0) {\n            if (active_target != target) {\n                // if the element does not match the one listed in the url #,\n                // clear the current class from it.\n                const $target = $(\"#\" + this.$el[0].href.split(\"#\").pop());\n                $target.removeClass(\"current\");\n                this.$el.removeClass(\"current\");\n            }\n        }\n    },\n\n    markIfVisible() {\n        if (this.$el.hasClass(\"pat-scroll-animated\")) {\n            // this section is triggered when the scrolling is a result of the animate function\n            // ie. automatic scrolling as opposed to the user manually scrolling\n            this.$el.removeClass(\"pat-scroll-animated\");\n        } else if (this.$el[0].nodeName === \"A\") {\n            const href = this.$el[0].href;\n            const fragment =\n                (href.indexOf(\"#\") !== -1 && href.split(\"#\").pop()) || undefined;\n            if (fragment) {\n                const $target = $(\"#\" + fragment);\n                if ($target.length) {\n                    if (\n                        utils.isElementInViewport($target[0], true, this.options.offset)\n                    ) {\n                        // check that the anchor's target is visible\n                        // if so, mark both the anchor and the target element\n                        $target.addClass(\"current\");\n                        this.$el.addClass(\"current\");\n                    }\n                    $(this.$el).trigger(\"pat-update\", { pattern: \"scroll\" });\n                }\n            }\n        }\n    },\n\n    onPatternsUpdate(ev, data) {\n        if (data?.pattern === \"stacks\") {\n            if (data.originalEvent && data.originalEvent.type === \"click\") {\n                this.smoothScroll();\n            }\n        } else if (data?.pattern === \"scroll\") {\n            const href = this.$el[0].href;\n            const fragment =\n                (href.indexOf(\"#\") !== -1 && href.split(\"#\").pop()) || undefined;\n            if (fragment) {\n                const $target = $(\"#\" + fragment);\n                if ($target.length) {\n                    if (\n                        !utils.isElementInViewport($target[0], true, this.options.offset)\n                    ) {\n                        // if the anchor's target is invisible, remove current class from anchor and target.\n                        $target.removeClass(\"current\");\n                        $(this.$el).removeClass(\"current\");\n                    }\n                }\n            }\n        }\n    },\n\n    _get_selector_target() {\n        const selector = this.options.selector;\n        if (!selector && this.el.href?.includes(\"#\")) {\n            return document.querySelector(`#${this.el.href.split(\"#\").pop()}`);\n        } else if (!selector || selector === \"self\") {\n            return this.el;\n        }\n        return document.querySelector(selector);\n    },\n\n    async smoothScroll() {\n        if (this.options.delay) {\n            await utils.timeout(this.options.delay);\n        }\n        const scroll = this.options.direction == \"top\" ? \"scrollTop\" : \"scrollLeft\";\n        const options = {};\n        let scrollable;\n        if (this.options.selector === \"top\") {\n            // Just scroll up or left, period.\n            scrollable = $(\n                dom.find_scroll_container(\n                    this.el.parentElement,\n                    this.options.direction === \"top\" ? \"y\" : \"x\"\n                )\n            );\n            options[scroll] = 0;\n        } else if (this.options.selector === \"bottom\") {\n            // Just scroll down or right, period.\n            scrollable = $(\n                dom.find_scroll_container(\n                    this.el.parentElement,\n                    this.options.direction === \"top\" ? \"y\" : \"x\"\n                )\n            );\n            if (scroll === \"scrollTop\") {\n                options.scrollTop = scrollable[0].scrollHeight;\n            } else {\n                options.scrollLeft = scrollable[0].scrollWidth;\n            }\n        } else {\n            // Get the first element with overflow (the scroll container)\n            // starting from the *target*\n            // The intent is to move target into view within scrollable\n            // if the scrollable has no scrollbar, do not scroll body\n\n            const target = $(this._get_selector_target());\n\n            if (!target.length) {\n                return;\n            }\n\n            scrollable = $(\n                dom.find_scroll_container(\n                    target[0].parentElement,\n                    this.options.direction === \"top\" ? \"y\" : \"x\"\n                )\n            );\n\n            if (scrollable[0] === document.body) {\n                // positioning context is document\n                if (scroll === \"scrollTop\") {\n                    options[scroll] = Math.floor(target.safeOffset().top);\n                } else {\n                    options[scroll] = Math.floor(target.safeOffset().left);\n                }\n            } else if (scroll === \"scrollTop\") {\n                // difference between target top and scrollable top becomes 0\n                options[scroll] = Math.floor(\n                    scrollable.scrollTop() +\n                        target.safeOffset().top -\n                        scrollable.safeOffset().top\n                );\n            } else {\n                options[scroll] = Math.floor(\n                    scrollable.scrollLeft() +\n                        target.safeOffset().left -\n                        scrollable.safeOffset().left\n                );\n            }\n        }\n\n        options[scroll] -= this.options.offset;\n\n        // Fix scrolling on body - need to scroll on HTML, howsoever.\n        if (scrollable[0] === document.body) {\n            scrollable = $(\"html\");\n        }\n\n        // execute the scroll\n        await scrollable\n            .animate(options, {\n                duration: 500,\n                start: () => {\n                    $(\".pat-scroll\").addClass(\"pat-scroll-animated\");\n                    log.debug(\"scrolling.\");\n                },\n            })\n            .promise();\n    },\n});\n"],"names":["i","log","logging","parser","Parser","addArgument","Base","name","trigger","jquery_plugin","init","$el","opts","options","parse","delay","utils","ImagesLoaded","default","document","body","smoothScroll","el","addEventListener","onClick","bind","on","onPatternsUpdate","markBasedOnFragment","clearIfHidden","$","window","scroll","markIfVisible","history","pushState","this","attr","fragment","location","hash","substr","$target","addClass","active_target","$active_target","target","href","split","pop","length","removeClass","hasClass","nodeName","indexOf","undefined","offset","pattern","ev","data","originalEvent","type","_get_selector_target","selector","includes","querySelector","direction","scrollable","dom","parentElement","scrollTop","scrollHeight","scrollLeft","scrollWidth","Math","floor","safeOffset","top","left","animate","duration","start","debug","promise"],"sourceRoot":""}