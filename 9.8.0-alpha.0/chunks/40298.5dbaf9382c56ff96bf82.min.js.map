{"version":3,"file":"chunks/40298.5dbaf9382c56ff96bf82.min.js","mappings":"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","sources":["webpack://ploneintranet-patterns/./node_modules/@_ueberdosis/prosemirror-tables/dist/index.esm.js","webpack://ploneintranet-patterns/./node_modules/@tiptap/extension-table/dist/tiptap-extension-table.esm.js"],"sourcesContent":["import { PluginKey, Selection, SelectionRange, TextSelection, NodeSelection, Plugin } from 'prosemirror-state';\nimport { Fragment, Slice } from 'prosemirror-model';\nimport { keydownHandler } from 'prosemirror-keymap';\nimport { Decoration, DecorationSet } from 'prosemirror-view';\nimport { Transform } from 'prosemirror-transform';\n\n// Because working with row and column-spanning cells is not quite\n// trivial, this code builds up a descriptive structure for a given\n// table node. The structures are cached with the (persistent) table\n// nodes as key, so that they only have to be recomputed when the\n// content of the table changes.\n//\n// This does mean that they have to store table-relative, not\n// document-relative positions. So code that uses them will typically\n// compute the start position of the table and offset positions passed\n// to or gotten from this structure by that amount.\nlet readFromCache, addToCache; // Prefer using a weak map to cache table maps. Fall back on a\n// fixed-size cache if that's not supported.\n\nif (typeof WeakMap != 'undefined') {\n  // eslint-disable-next-line\n  let cache = new WeakMap();\n\n  readFromCache = key => cache.get(key);\n\n  addToCache = (key, value) => {\n    cache.set(key, value);\n    return value;\n  };\n} else {\n  let cache = [],\n      cacheSize = 10,\n      cachePos = 0;\n\n  readFromCache = key => {\n    for (let i = 0; i < cache.length; i += 2) if (cache[i] == key) return cache[i + 1];\n  };\n\n  addToCache = (key, value) => {\n    if (cachePos == cacheSize) cachePos = 0;\n    cache[cachePos++] = key;\n    return cache[cachePos++] = value;\n  };\n}\n\nclass Rect {\n  constructor(left, top, right, bottom) {\n    this.left = left;\n    this.top = top;\n    this.right = right;\n    this.bottom = bottom;\n  }\n\n} // ::- A table map describes the structore of a given table. To avoid\n// recomputing them all the time, they are cached per table node. To\n// be able to do that, positions saved in the map are relative to the\n// start of the table, rather than the start of the document.\n\nclass TableMap {\n  constructor(width, height, map, problems) {\n    // :: number The width of the table\n    this.width = width; // :: number The table's height\n\n    this.height = height; // :: [number] A width * height array with the start position of\n    // the cell covering that part of the table in each slot\n\n    this.map = map; // An optional array of problems (cell overlap or non-rectangular\n    // shape) for the table, used by the table normalizer.\n\n    this.problems = problems;\n  } // :: (number) → Rect\n  // Find the dimensions of the cell at the given position.\n\n\n  findCell(pos) {\n    for (let i = 0; i < this.map.length; i++) {\n      let curPos = this.map[i];\n      if (curPos != pos) continue;\n      let left = i % this.width,\n          top = i / this.width | 0;\n      let right = left + 1,\n          bottom = top + 1;\n\n      for (let j = 1; right < this.width && this.map[i + j] == curPos; j++) right++;\n\n      for (let j = 1; bottom < this.height && this.map[i + this.width * j] == curPos; j++) bottom++;\n\n      return new Rect(left, top, right, bottom);\n    }\n\n    throw new RangeError('No cell with offset ' + pos + ' found');\n  } // :: (number) → number\n  // Find the left side of the cell at the given position.\n\n\n  colCount(pos) {\n    for (let i = 0; i < this.map.length; i++) if (this.map[i] == pos) return i % this.width;\n\n    throw new RangeError('No cell with offset ' + pos + ' found');\n  } // :: (number, string, number) → ?number\n  // Find the next cell in the given direction, starting from the cell\n  // at `pos`, if any.\n\n\n  nextCell(pos, axis, dir) {\n    let {\n      left,\n      right,\n      top,\n      bottom\n    } = this.findCell(pos);\n\n    if (axis == 'horiz') {\n      if (dir < 0 ? left == 0 : right == this.width) return null;\n      return this.map[top * this.width + (dir < 0 ? left - 1 : right)];\n    } else {\n      if (dir < 0 ? top == 0 : bottom == this.height) return null;\n      return this.map[left + this.width * (dir < 0 ? top - 1 : bottom)];\n    }\n  } // :: (number, number) → Rect\n  // Get the rectangle spanning the two given cells.\n\n\n  rectBetween(a, b) {\n    let {\n      left: leftA,\n      right: rightA,\n      top: topA,\n      bottom: bottomA\n    } = this.findCell(a);\n    let {\n      left: leftB,\n      right: rightB,\n      top: topB,\n      bottom: bottomB\n    } = this.findCell(b);\n    return new Rect(Math.min(leftA, leftB), Math.min(topA, topB), Math.max(rightA, rightB), Math.max(bottomA, bottomB));\n  } // :: (Rect) → [number]\n  // Return the position of all cells that have the top left corner in\n  // the given rectangle.\n\n\n  cellsInRect(rect) {\n    let result = [],\n        seen = {};\n\n    for (let row = rect.top; row < rect.bottom; row++) {\n      for (let col = rect.left; col < rect.right; col++) {\n        let index = row * this.width + col,\n            pos = this.map[index];\n        if (seen[pos]) continue;\n        seen[pos] = true;\n        if ((col != rect.left || !col || this.map[index - 1] != pos) && (row != rect.top || !row || this.map[index - this.width] != pos)) result.push(pos);\n      }\n    }\n\n    return result;\n  } // :: (number, number, Node) → number\n  // Return the position at which the cell at the given row and column\n  // starts, or would start, if a cell started there.\n\n\n  positionAt(row, col, table) {\n    for (let i = 0, rowStart = 0;; i++) {\n      let rowEnd = rowStart + table.child(i).nodeSize;\n\n      if (i == row) {\n        let index = col + row * this.width,\n            rowEndIndex = (row + 1) * this.width; // Skip past cells from previous rows (via rowspan)\n\n        while (index < rowEndIndex && this.map[index] < rowStart) index++;\n\n        return index == rowEndIndex ? rowEnd - 1 : this.map[index];\n      }\n\n      rowStart = rowEnd;\n    }\n  } // :: (Node) → TableMap\n  // Find the table map for the given table node.\n\n\n  static get(table) {\n    return readFromCache(table) || addToCache(table, computeMap(table));\n  }\n\n} // Compute a table map.\n\nfunction computeMap(table) {\n  if (table.type.spec.tableRole != 'table') throw new RangeError('Not a table node: ' + table.type.name);\n  let width = findWidth(table),\n      height = table.childCount;\n  let map = [],\n      mapPos = 0,\n      problems = null,\n      colWidths = [];\n\n  for (let i = 0, e = width * height; i < e; i++) map[i] = 0;\n\n  for (let row = 0, pos = 0; row < height; row++) {\n    let rowNode = table.child(row);\n    pos++;\n\n    for (let i = 0;; i++) {\n      while (mapPos < map.length && map[mapPos] != 0) mapPos++;\n\n      if (i == rowNode.childCount) break;\n      let cellNode = rowNode.child(i),\n          {\n        colspan,\n        rowspan,\n        colwidth\n      } = cellNode.attrs;\n\n      for (let h = 0; h < rowspan; h++) {\n        if (h + row >= height) {\n          (problems || (problems = [])).push({\n            type: 'overlong_rowspan',\n            pos,\n            n: rowspan - h\n          });\n          break;\n        }\n\n        let start = mapPos + h * width;\n\n        for (let w = 0; w < colspan; w++) {\n          if (map[start + w] == 0) map[start + w] = pos;else (problems || (problems = [])).push({\n            type: 'collision',\n            row,\n            pos,\n            n: colspan - w\n          });\n          let colW = colwidth && colwidth[w];\n\n          if (colW) {\n            let widthIndex = (start + w) % width * 2,\n                prev = colWidths[widthIndex];\n\n            if (prev == null || prev != colW && colWidths[widthIndex + 1] == 1) {\n              colWidths[widthIndex] = colW;\n              colWidths[widthIndex + 1] = 1;\n            } else if (prev == colW) {\n              colWidths[widthIndex + 1]++;\n            }\n          }\n        }\n      }\n\n      mapPos += colspan;\n      pos += cellNode.nodeSize;\n    }\n\n    let expectedPos = (row + 1) * width,\n        missing = 0;\n\n    while (mapPos < expectedPos) if (map[mapPos++] == 0) missing++;\n\n    if (missing) (problems || (problems = [])).push({\n      type: 'missing',\n      row,\n      n: missing\n    });\n    pos++;\n  }\n\n  let tableMap = new TableMap(width, height, map, problems),\n      badWidths = false; // For columns that have defined widths, but whose widths disagree\n  // between rows, fix up the cells whose width doesn't match the\n  // computed one.\n\n  for (let i = 0; !badWidths && i < colWidths.length; i += 2) if (colWidths[i] != null && colWidths[i + 1] < height) badWidths = true;\n\n  if (badWidths) findBadColWidths(tableMap, colWidths, table);\n  return tableMap;\n}\n\nfunction findWidth(table) {\n  let width = -1,\n      hasRowSpan = false;\n\n  for (let row = 0; row < table.childCount; row++) {\n    let rowNode = table.child(row),\n        rowWidth = 0;\n    if (hasRowSpan) for (let j = 0; j < row; j++) {\n      let prevRow = table.child(j);\n\n      for (let i = 0; i < prevRow.childCount; i++) {\n        let cell = prevRow.child(i);\n        if (j + cell.attrs.rowspan > row) rowWidth += cell.attrs.colspan;\n      }\n    }\n\n    for (let i = 0; i < rowNode.childCount; i++) {\n      let cell = rowNode.child(i);\n      rowWidth += cell.attrs.colspan;\n      if (cell.attrs.rowspan > 1) hasRowSpan = true;\n    }\n\n    if (width == -1) width = rowWidth;else if (width != rowWidth) width = Math.max(width, rowWidth);\n  }\n\n  return width;\n}\n\nfunction findBadColWidths(map, colWidths, table) {\n  if (!map.problems) map.problems = [];\n\n  for (let i = 0, seen = {}; i < map.map.length; i++) {\n    let pos = map.map[i];\n    if (seen[pos]) continue;\n    seen[pos] = true;\n    let node = table.nodeAt(pos),\n        updated = null;\n\n    for (let j = 0; j < node.attrs.colspan; j++) {\n      let col = (i + j) % map.width,\n          colWidth = colWidths[col * 2];\n      if (colWidth != null && (!node.attrs.colwidth || node.attrs.colwidth[j] != colWidth)) (updated || (updated = freshColWidth(node.attrs)))[j] = colWidth;\n    }\n\n    if (updated) map.problems.unshift({\n      type: 'colwidth mismatch',\n      pos,\n      colwidth: updated\n    });\n  }\n}\n\nfunction freshColWidth(attrs) {\n  if (attrs.colwidth) return attrs.colwidth.slice();\n  let result = [];\n\n  for (let i = 0; i < attrs.colspan; i++) result.push(0);\n\n  return result;\n}\n\n// Helper for creating a schema that supports tables.\nfunction getCellAttrs(dom, extraAttrs) {\n  let widthAttr = dom.getAttribute('data-colwidth');\n  let widths = widthAttr && /^\\d+(,\\d+)*$/.test(widthAttr) ? widthAttr.split(',').map(s => Number(s)) : null;\n  let colspan = Number(dom.getAttribute('colspan') || 1);\n  let result = {\n    colspan,\n    rowspan: Number(dom.getAttribute('rowspan') || 1),\n    colwidth: widths && widths.length == colspan ? widths : null\n  };\n\n  for (let prop in extraAttrs) {\n    let getter = extraAttrs[prop].getFromDOM;\n    let value = getter && getter(dom);\n    if (value != null) result[prop] = value;\n  }\n\n  return result;\n}\n\nfunction setCellAttrs(node, extraAttrs) {\n  let attrs = {};\n  if (node.attrs.colspan != 1) attrs.colspan = node.attrs.colspan;\n  if (node.attrs.rowspan != 1) attrs.rowspan = node.attrs.rowspan;\n  if (node.attrs.colwidth) attrs['data-colwidth'] = node.attrs.colwidth.join(',');\n\n  for (let prop in extraAttrs) {\n    let setter = extraAttrs[prop].setDOMAttr;\n    if (setter) setter(node.attrs[prop], attrs);\n  }\n\n  return attrs;\n} // :: (Object) → Object\n//\n// This function creates a set of [node\n// specs](http://prosemirror.net/docs/ref/#model.SchemaSpec.nodes) for\n// `table`, `table_row`, and `table_cell` nodes types as used by this\n// module. The result can then be added to the set of nodes when\n// creating a a schema.\n//\n//   options::- The following options are understood:\n//\n//     tableGroup:: ?string\n//     A group name (something like `\"block\"`) to add to the table\n//     node type.\n//\n//     cellContent:: string\n//     The content expression for table cells.\n//\n//     cellAttributes:: ?Object\n//     Additional attributes to add to cells. Maps attribute names to\n//     objects with the following properties:\n//\n//       default:: any\n//       The attribute's default value.\n//\n//       getFromDOM:: ?(dom.Node) → any\n//       A function to read the attribute's value from a DOM node.\n//\n//       setDOMAttr:: ?(value: any, attrs: Object)\n//       A function to add the attribute's value to an attribute\n//       object that's used to render the cell's DOM.\n\n\nfunction tableNodes(options) {\n  let extraAttrs = options.cellAttributes || {};\n  let cellAttrs = {\n    colspan: {\n      default: 1\n    },\n    rowspan: {\n      default: 1\n    },\n    colwidth: {\n      default: null\n    }\n  };\n\n  for (let prop in extraAttrs) cellAttrs[prop] = {\n    default: extraAttrs[prop].default\n  };\n\n  return {\n    table: {\n      content: 'table_row+',\n      tableRole: 'table',\n      isolating: true,\n      group: options.tableGroup,\n      parseDOM: [{\n        tag: 'table'\n      }],\n\n      toDOM() {\n        return ['table', ['tbody', 0]];\n      }\n\n    },\n    table_row: {\n      content: '(table_cell | table_header)*',\n      tableRole: 'row',\n      parseDOM: [{\n        tag: 'tr'\n      }],\n\n      toDOM() {\n        return ['tr', 0];\n      }\n\n    },\n    table_cell: {\n      content: options.cellContent,\n      attrs: cellAttrs,\n      tableRole: 'cell',\n      isolating: true,\n      parseDOM: [{\n        tag: 'td',\n        getAttrs: dom => getCellAttrs(dom, extraAttrs)\n      }],\n\n      toDOM(node) {\n        return ['td', setCellAttrs(node, extraAttrs), 0];\n      }\n\n    },\n    table_header: {\n      content: options.cellContent,\n      attrs: cellAttrs,\n      tableRole: 'header_cell',\n      isolating: true,\n      parseDOM: [{\n        tag: 'th',\n        getAttrs: dom => getCellAttrs(dom, extraAttrs)\n      }],\n\n      toDOM(node) {\n        return ['th', setCellAttrs(node, extraAttrs), 0];\n      }\n\n    }\n  };\n}\nfunction tableNodeTypes(schema) {\n  let result = schema.cached.tableNodeTypes;\n\n  if (!result) {\n    result = schema.cached.tableNodeTypes = {};\n\n    for (let name in schema.nodes) {\n      let type = schema.nodes[name],\n          role = type.spec.tableRole;\n      if (role) result[role] = type;\n    }\n  }\n\n  return result;\n}\n\n// Various helper function for working with tables\nconst key$1 = new PluginKey('selectingCells');\nfunction cellAround($pos) {\n  for (let d = $pos.depth - 1; d > 0; d--) if ($pos.node(d).type.spec.tableRole == 'row') return $pos.node(0).resolve($pos.before(d + 1));\n\n  return null;\n}\nfunction cellWrapping($pos) {\n  for (let d = $pos.depth; d > 0; d--) {\n    // Sometimes the cell can be in the same depth.\n    const role = $pos.node(d).type.spec.tableRole;\n    if (role === 'cell' || role === 'header_cell') return $pos.node(d);\n  }\n\n  return null;\n}\nfunction isInTable(state) {\n  let $head = state.selection.$head;\n\n  for (let d = $head.depth; d > 0; d--) if ($head.node(d).type.spec.tableRole == 'row') return true;\n\n  return false;\n}\nfunction selectionCell(state) {\n  let sel = state.selection;\n\n  if (sel.$anchorCell) {\n    return sel.$anchorCell.pos > sel.$headCell.pos ? sel.$anchorCell : sel.$headCell;\n  } else if (sel.node && sel.node.type.spec.tableRole == 'cell') {\n    return sel.$anchor;\n  }\n\n  return cellAround(sel.$head) || cellNear(sel.$head);\n}\n\nfunction cellNear($pos) {\n  for (let after = $pos.nodeAfter, pos = $pos.pos; after; after = after.firstChild, pos++) {\n    let role = after.type.spec.tableRole;\n    if (role == 'cell' || role == 'header_cell') return $pos.doc.resolve(pos);\n  }\n\n  for (let before = $pos.nodeBefore, pos = $pos.pos; before; before = before.lastChild, pos--) {\n    let role = before.type.spec.tableRole;\n    if (role == 'cell' || role == 'header_cell') return $pos.doc.resolve(pos - before.nodeSize);\n  }\n}\n\nfunction pointsAtCell($pos) {\n  return $pos.parent.type.spec.tableRole == 'row' && $pos.nodeAfter;\n}\nfunction moveCellForward($pos) {\n  return $pos.node(0).resolve($pos.pos + $pos.nodeAfter.nodeSize);\n}\nfunction inSameTable($a, $b) {\n  return $a.depth == $b.depth && $a.pos >= $b.start(-1) && $a.pos <= $b.end(-1);\n}\nfunction findCell($pos) {\n  return TableMap.get($pos.node(-1)).findCell($pos.pos - $pos.start(-1));\n}\nfunction colCount($pos) {\n  return TableMap.get($pos.node(-1)).colCount($pos.pos - $pos.start(-1));\n}\nfunction nextCell($pos, axis, dir) {\n  let start = $pos.start(-1),\n      map = TableMap.get($pos.node(-1));\n  let moved = map.nextCell($pos.pos - start, axis, dir);\n  return moved == null ? null : $pos.node(0).resolve(start + moved);\n}\nfunction setAttr(attrs, name, value) {\n  let result = {};\n\n  for (let prop in attrs) result[prop] = attrs[prop];\n\n  result[name] = value;\n  return result;\n}\nfunction removeColSpan(attrs, pos, n = 1) {\n  let result = setAttr(attrs, 'colspan', attrs.colspan - n);\n\n  if (result.colwidth) {\n    result.colwidth = result.colwidth.slice();\n    result.colwidth.splice(pos, n);\n    if (!result.colwidth.some(w => w > 0)) result.colwidth = null;\n  }\n\n  return result;\n}\nfunction addColSpan(attrs, pos, n = 1) {\n  let result = setAttr(attrs, 'colspan', attrs.colspan + n);\n\n  if (result.colwidth) {\n    result.colwidth = result.colwidth.slice();\n\n    for (let i = 0; i < n; i++) result.colwidth.splice(pos, 0, 0);\n  }\n\n  return result;\n}\nfunction columnIsHeader(map, table, col) {\n  let headerCell = tableNodeTypes(table.type.schema).header_cell;\n\n  for (let row = 0; row < map.height; row++) if (table.nodeAt(map.map[col + row * map.width]).type != headerCell) return false;\n\n  return true;\n}\n\n// This file defines a ProseMirror selection subclass that models\n// subclass that represents a cell selection spanning part of a table.\n// With the plugin enabled, these will be created when the user\n// selects across cells, and will be drawn by giving selected cells a\n// `selectedCell` CSS class.\n\nclass CellSelection extends Selection {\n  // :: (ResolvedPos, ?ResolvedPos)\n  // A table selection is identified by its anchor and head cells. The\n  // positions given to this constructor should point _before_ two\n  // cells in the same table. They may be the same, to select a single\n  // cell.\n  constructor($anchorCell, $headCell = $anchorCell) {\n    let table = $anchorCell.node(-1),\n        map = TableMap.get(table),\n        start = $anchorCell.start(-1);\n    let rect = map.rectBetween($anchorCell.pos - start, $headCell.pos - start);\n    let doc = $anchorCell.node(0);\n    let cells = map.cellsInRect(rect).filter(p => p != $headCell.pos - start); // Make the head cell the first range, so that it counts as the\n    // primary part of the selection\n\n    cells.unshift($headCell.pos - start);\n    let ranges = cells.map(pos => {\n      let cell = table.nodeAt(pos),\n          from = pos + start + 1;\n      return new SelectionRange(doc.resolve(from), doc.resolve(from + cell.content.size));\n    });\n    super(ranges[0].$from, ranges[0].$to, ranges); // :: ResolvedPos\n    // A resolved position pointing _in front of_ the anchor cell (the one\n    // that doesn't move when extending the selection).\n\n    this.$anchorCell = $anchorCell; // :: ResolvedPos\n    // A resolved position pointing in front of the head cell (the one\n    // moves when extending the selection).\n\n    this.$headCell = $headCell;\n  }\n\n  map(doc, mapping) {\n    let $anchorCell = doc.resolve(mapping.map(this.$anchorCell.pos));\n    let $headCell = doc.resolve(mapping.map(this.$headCell.pos));\n\n    if (pointsAtCell($anchorCell) && pointsAtCell($headCell) && inSameTable($anchorCell, $headCell)) {\n      let tableChanged = this.$anchorCell.node(-1) != $anchorCell.node(-1);\n      if (tableChanged && this.isRowSelection()) return CellSelection.rowSelection($anchorCell, $headCell);else if (tableChanged && this.isColSelection()) return CellSelection.colSelection($anchorCell, $headCell);else return new CellSelection($anchorCell, $headCell);\n    }\n\n    return TextSelection.between($anchorCell, $headCell);\n  } // :: () → Slice\n  // Returns a rectangular slice of table rows containing the selected\n  // cells.\n\n\n  content() {\n    let table = this.$anchorCell.node(-1),\n        map = TableMap.get(table),\n        start = this.$anchorCell.start(-1);\n    let rect = map.rectBetween(this.$anchorCell.pos - start, this.$headCell.pos - start);\n    let seen = {},\n        rows = [];\n\n    for (let row = rect.top; row < rect.bottom; row++) {\n      let rowContent = [];\n\n      for (let index = row * map.width + rect.left, col = rect.left; col < rect.right; col++, index++) {\n        let pos = map.map[index];\n\n        if (!seen[pos]) {\n          seen[pos] = true;\n          let cellRect = map.findCell(pos),\n              cell = table.nodeAt(pos);\n          let extraLeft = rect.left - cellRect.left,\n              extraRight = cellRect.right - rect.right;\n\n          if (extraLeft > 0 || extraRight > 0) {\n            let attrs = cell.attrs;\n            if (extraLeft > 0) attrs = removeColSpan(attrs, 0, extraLeft);\n            if (extraRight > 0) attrs = removeColSpan(attrs, attrs.colspan - extraRight, extraRight);\n            if (cellRect.left < rect.left) cell = cell.type.createAndFill(attrs);else cell = cell.type.create(attrs, cell.content);\n          }\n\n          if (cellRect.top < rect.top || cellRect.bottom > rect.bottom) {\n            let attrs = setAttr(cell.attrs, 'rowspan', Math.min(cellRect.bottom, rect.bottom) - Math.max(cellRect.top, rect.top));\n            if (cellRect.top < rect.top) cell = cell.type.createAndFill(attrs);else cell = cell.type.create(attrs, cell.content);\n          }\n\n          rowContent.push(cell);\n        }\n      }\n\n      rows.push(table.child(row).copy(Fragment.from(rowContent)));\n    }\n\n    const fragment = this.isColSelection() && this.isRowSelection() ? table : rows;\n    return new Slice(Fragment.from(fragment), 1, 1);\n  }\n\n  replace(tr, content = Slice.empty) {\n    let mapFrom = tr.steps.length,\n        ranges = this.ranges;\n\n    for (let i = 0; i < ranges.length; i++) {\n      let {\n        $from,\n        $to\n      } = ranges[i],\n          mapping = tr.mapping.slice(mapFrom);\n      tr.replace(mapping.map($from.pos), mapping.map($to.pos), i ? Slice.empty : content);\n    }\n\n    let sel = Selection.findFrom(tr.doc.resolve(tr.mapping.slice(mapFrom).map(this.to)), -1);\n    if (sel) tr.setSelection(sel);\n  }\n\n  replaceWith(tr, node) {\n    this.replace(tr, new Slice(Fragment.from(node), 0, 0));\n  }\n\n  forEachCell(f) {\n    let table = this.$anchorCell.node(-1),\n        map = TableMap.get(table),\n        start = this.$anchorCell.start(-1);\n    let cells = map.cellsInRect(map.rectBetween(this.$anchorCell.pos - start, this.$headCell.pos - start));\n\n    for (let i = 0; i < cells.length; i++) f(table.nodeAt(cells[i]), start + cells[i]);\n  } // :: () → bool\n  // True if this selection goes all the way from the top to the\n  // bottom of the table.\n\n\n  isColSelection() {\n    let anchorTop = this.$anchorCell.index(-1),\n        headTop = this.$headCell.index(-1);\n    if (Math.min(anchorTop, headTop) > 0) return false;\n    let anchorBot = anchorTop + this.$anchorCell.nodeAfter.attrs.rowspan,\n        headBot = headTop + this.$headCell.nodeAfter.attrs.rowspan;\n    return Math.max(anchorBot, headBot) == this.$headCell.node(-1).childCount;\n  } // :: (ResolvedPos, ?ResolvedPos) → CellSelection\n  // Returns the smallest column selection that covers the given anchor\n  // and head cell.\n\n\n  static colSelection($anchorCell, $headCell = $anchorCell) {\n    let map = TableMap.get($anchorCell.node(-1)),\n        start = $anchorCell.start(-1);\n    let anchorRect = map.findCell($anchorCell.pos - start),\n        headRect = map.findCell($headCell.pos - start);\n    let doc = $anchorCell.node(0);\n\n    if (anchorRect.top <= headRect.top) {\n      if (anchorRect.top > 0) $anchorCell = doc.resolve(start + map.map[anchorRect.left]);\n      if (headRect.bottom < map.height) $headCell = doc.resolve(start + map.map[map.width * (map.height - 1) + headRect.right - 1]);\n    } else {\n      if (headRect.top > 0) $headCell = doc.resolve(start + map.map[headRect.left]);\n      if (anchorRect.bottom < map.height) $anchorCell = doc.resolve(start + map.map[map.width * (map.height - 1) + anchorRect.right - 1]);\n    }\n\n    return new CellSelection($anchorCell, $headCell);\n  } // :: () → bool\n  // True if this selection goes all the way from the left to the\n  // right of the table.\n\n\n  isRowSelection() {\n    let map = TableMap.get(this.$anchorCell.node(-1)),\n        start = this.$anchorCell.start(-1);\n    let anchorLeft = map.colCount(this.$anchorCell.pos - start),\n        headLeft = map.colCount(this.$headCell.pos - start);\n    if (Math.min(anchorLeft, headLeft) > 0) return false;\n    let anchorRight = anchorLeft + this.$anchorCell.nodeAfter.attrs.colspan,\n        headRight = headLeft + this.$headCell.nodeAfter.attrs.colspan;\n    return Math.max(anchorRight, headRight) == map.width;\n  }\n\n  eq(other) {\n    return other instanceof CellSelection && other.$anchorCell.pos == this.$anchorCell.pos && other.$headCell.pos == this.$headCell.pos;\n  } // :: (ResolvedPos, ?ResolvedPos) → CellSelection\n  // Returns the smallest row selection that covers the given anchor\n  // and head cell.\n\n\n  static rowSelection($anchorCell, $headCell = $anchorCell) {\n    let map = TableMap.get($anchorCell.node(-1)),\n        start = $anchorCell.start(-1);\n    let anchorRect = map.findCell($anchorCell.pos - start),\n        headRect = map.findCell($headCell.pos - start);\n    let doc = $anchorCell.node(0);\n\n    if (anchorRect.left <= headRect.left) {\n      if (anchorRect.left > 0) $anchorCell = doc.resolve(start + map.map[anchorRect.top * map.width]);\n      if (headRect.right < map.width) $headCell = doc.resolve(start + map.map[map.width * (headRect.top + 1) - 1]);\n    } else {\n      if (headRect.left > 0) $headCell = doc.resolve(start + map.map[headRect.top * map.width]);\n      if (anchorRect.right < map.width) $anchorCell = doc.resolve(start + map.map[map.width * (anchorRect.top + 1) - 1]);\n    }\n\n    return new CellSelection($anchorCell, $headCell);\n  }\n\n  toJSON() {\n    return {\n      type: 'cell',\n      anchor: this.$anchorCell.pos,\n      head: this.$headCell.pos\n    };\n  }\n\n  static fromJSON(doc, json) {\n    return new CellSelection(doc.resolve(json.anchor), doc.resolve(json.head));\n  } // :: (Node, number, ?number) → CellSelection\n\n\n  static create(doc, anchorCell, headCell = anchorCell) {\n    return new CellSelection(doc.resolve(anchorCell), doc.resolve(headCell));\n  }\n\n  getBookmark() {\n    return new CellBookmark(this.$anchorCell.pos, this.$headCell.pos);\n  }\n\n}\nCellSelection.prototype.visible = false;\nSelection.jsonID('cell', CellSelection);\n\nclass CellBookmark {\n  constructor(anchor, head) {\n    this.anchor = anchor;\n    this.head = head;\n  }\n\n  map(mapping) {\n    return new CellBookmark(mapping.map(this.anchor), mapping.map(this.head));\n  }\n\n  resolve(doc) {\n    let $anchorCell = doc.resolve(this.anchor),\n        $headCell = doc.resolve(this.head);\n    if ($anchorCell.parent.type.spec.tableRole == 'row' && $headCell.parent.type.spec.tableRole == 'row' && $anchorCell.index() < $anchorCell.parent.childCount && $headCell.index() < $headCell.parent.childCount && inSameTable($anchorCell, $headCell)) return new CellSelection($anchorCell, $headCell);else return Selection.near($headCell, 1);\n  }\n\n}\n\nfunction drawCellSelection(state) {\n  if (!(state.selection instanceof CellSelection)) return null;\n  let cells = [];\n  state.selection.forEachCell((node, pos) => {\n    cells.push(Decoration.node(pos, pos + node.nodeSize, {\n      class: 'selectedCell'\n    }));\n  });\n  return DecorationSet.create(state.doc, cells);\n}\n\nfunction isCellBoundarySelection({\n  $from,\n  $to\n}) {\n  if ($from.pos == $to.pos || $from.pos < $from.pos - 6) return false; // Cheap elimination\n\n  let afterFrom = $from.pos,\n      beforeTo = $to.pos,\n      depth = $from.depth;\n\n  for (; depth >= 0; depth--, afterFrom++) if ($from.after(depth + 1) < $from.end(depth)) break;\n\n  for (let d = $to.depth; d >= 0; d--, beforeTo--) if ($to.before(d + 1) > $to.start(d)) break;\n\n  return afterFrom == beforeTo && /row|table/.test($from.node(depth).type.spec.tableRole);\n}\n\nfunction isTextSelectionAcrossCells({\n  $from,\n  $to\n}) {\n  let fromCellBoundaryNode;\n  let toCellBoundaryNode;\n\n  for (let i = $from.depth; i > 0; i--) {\n    let node = $from.node(i);\n\n    if (node.type.spec.tableRole === 'cell' || node.type.spec.tableRole === 'header_cell') {\n      fromCellBoundaryNode = node;\n      break;\n    }\n  }\n\n  for (let i = $to.depth; i > 0; i--) {\n    let node = $to.node(i);\n\n    if (node.type.spec.tableRole === 'cell' || node.type.spec.tableRole === 'header_cell') {\n      toCellBoundaryNode = node;\n      break;\n    }\n  }\n\n  return fromCellBoundaryNode !== toCellBoundaryNode && $to.parentOffset === 0;\n}\n\nfunction normalizeSelection(state, tr, allowTableNodeSelection) {\n  let sel = (tr || state).selection,\n      doc = (tr || state).doc,\n      normalize,\n      role;\n\n  if (sel instanceof NodeSelection && (role = sel.node.type.spec.tableRole)) {\n    if (role == 'cell' || role == 'header_cell') {\n      normalize = CellSelection.create(doc, sel.from);\n    } else if (role == 'row') {\n      let $cell = doc.resolve(sel.from + 1);\n      normalize = CellSelection.rowSelection($cell, $cell);\n    } else if (!allowTableNodeSelection) {\n      let map = TableMap.get(sel.node),\n          start = sel.from + 1;\n      let lastCell = start + map.map[map.width * map.height - 1];\n      normalize = CellSelection.create(doc, start + 1, lastCell);\n    }\n  } else if (sel instanceof TextSelection && isCellBoundarySelection(sel)) {\n    normalize = TextSelection.create(doc, sel.from);\n  } else if (sel instanceof TextSelection && isTextSelectionAcrossCells(sel)) {\n    normalize = TextSelection.create(doc, sel.$from.start(), sel.$from.end());\n  }\n\n  if (normalize) (tr || (tr = state.tr)).setSelection(normalize);\n  return tr;\n}\n\n// Utilities used for copy/paste handling.\n// : (Slice) → ?{width: number, height: number, rows: [Fragment]}\n// Get a rectangular area of cells from a slice, or null if the outer\n// nodes of the slice aren't table cells or rows.\n\nfunction pastedCells(slice) {\n  if (!slice.size) return null;\n  let {\n    content,\n    openStart,\n    openEnd\n  } = slice;\n\n  while (content.childCount == 1 && (openStart > 0 && openEnd > 0 || content.firstChild.type.spec.tableRole == 'table')) {\n    openStart--;\n    openEnd--;\n    content = content.firstChild.content;\n  }\n\n  let first = content.firstChild,\n      role = first.type.spec.tableRole;\n  let schema = first.type.schema,\n      rows = [];\n\n  if (role == 'row') {\n    for (let i = 0; i < content.childCount; i++) {\n      let cells = content.child(i).content;\n      let left = i ? 0 : Math.max(0, openStart - 1);\n      let right = i < content.childCount - 1 ? 0 : Math.max(0, openEnd - 1);\n      if (left || right) cells = fitSlice(tableNodeTypes(schema).row, new Slice(cells, left, right)).content;\n      rows.push(cells);\n    }\n  } else if (role == 'cell' || role == 'header_cell') {\n    rows.push(openStart || openEnd ? fitSlice(tableNodeTypes(schema).row, new Slice(content, openStart, openEnd)).content : content);\n  } else {\n    return null;\n  }\n\n  return ensureRectangular(schema, rows);\n} // : (Schema, [Fragment]) → {width: number, height: number, rows: [Fragment]}\n// Compute the width and height of a set of cells, and make sure each\n// row has the same number of cells.\n\nfunction ensureRectangular(schema, rows) {\n  let widths = [];\n\n  for (let i = 0; i < rows.length; i++) {\n    let row = rows[i];\n\n    for (let j = row.childCount - 1; j >= 0; j--) {\n      let {\n        rowspan,\n        colspan\n      } = row.child(j).attrs;\n\n      for (let r = i; r < i + rowspan; r++) widths[r] = (widths[r] || 0) + colspan;\n    }\n  }\n\n  let width = 0;\n\n  for (let r = 0; r < widths.length; r++) width = Math.max(width, widths[r]);\n\n  for (let r = 0; r < widths.length; r++) {\n    if (r >= rows.length) rows.push(Fragment.empty);\n\n    if (widths[r] < width) {\n      let empty = tableNodeTypes(schema).cell.createAndFill(),\n          cells = [];\n\n      for (let i = widths[r]; i < width; i++) cells.push(empty);\n\n      rows[r] = rows[r].append(Fragment.from(cells));\n    }\n  }\n\n  return {\n    height: rows.length,\n    width,\n    rows\n  };\n}\n\nfunction fitSlice(nodeType, slice) {\n  let node = nodeType.createAndFill();\n  let tr = new Transform(node).replace(0, node.content.size, slice);\n  return tr.doc;\n} // : ({width: number, height: number, rows: [Fragment]}, number, number) → {width: number, height: number, rows: [Fragment]}\n// Clip or extend (repeat) the given set of cells to cover the given\n// width and height. Will clip rowspan/colspan cells at the edges when\n// they stick out.\n\nfunction clipCells({\n  width,\n  height,\n  rows\n}, newWidth, newHeight) {\n  if (width != newWidth) {\n    let added = [],\n        newRows = [];\n\n    for (let row = 0; row < rows.length; row++) {\n      let frag = rows[row],\n          cells = [];\n\n      for (let col = added[row] || 0, i = 0; col < newWidth; i++) {\n        let cell = frag.child(i % frag.childCount);\n        if (col + cell.attrs.colspan > newWidth) cell = cell.type.create(removeColSpan(cell.attrs, cell.attrs.colspan, col + cell.attrs.colspan - newWidth), cell.content);\n        cells.push(cell);\n        col += cell.attrs.colspan;\n\n        for (let j = 1; j < cell.attrs.rowspan; j++) added[row + j] = (added[row + j] || 0) + cell.attrs.colspan;\n      }\n\n      newRows.push(Fragment.from(cells));\n    }\n\n    rows = newRows;\n    width = newWidth;\n  }\n\n  if (height != newHeight) {\n    let newRows = [];\n\n    for (let row = 0, i = 0; row < newHeight; row++, i++) {\n      let cells = [],\n          source = rows[i % height];\n\n      for (let j = 0; j < source.childCount; j++) {\n        let cell = source.child(j);\n        if (row + cell.attrs.rowspan > newHeight) cell = cell.type.create(setAttr(cell.attrs, 'rowspan', Math.max(1, newHeight - cell.attrs.rowspan)), cell.content);\n        cells.push(cell);\n      }\n\n      newRows.push(Fragment.from(cells));\n    }\n\n    rows = newRows;\n    height = newHeight;\n  }\n\n  return {\n    width,\n    height,\n    rows\n  };\n} // Make sure a table has at least the given width and height. Return\n// true if something was changed.\n\nfunction growTable(tr, map, table, start, width, height, mapFrom) {\n  let schema = tr.doc.type.schema,\n      types = tableNodeTypes(schema),\n      empty,\n      emptyHead;\n\n  if (width > map.width) {\n    for (let row = 0, rowEnd = 0; row < map.height; row++) {\n      let rowNode = table.child(row);\n      rowEnd += rowNode.nodeSize;\n      let cells = [],\n          add;\n      if (rowNode.lastChild == null || rowNode.lastChild.type == types.cell) add = empty || (empty = types.cell.createAndFill());else add = emptyHead || (emptyHead = types.header_cell.createAndFill());\n\n      for (let i = map.width; i < width; i++) cells.push(add);\n\n      tr.insert(tr.mapping.slice(mapFrom).map(rowEnd - 1 + start), cells);\n    }\n  }\n\n  if (height > map.height) {\n    let cells = [];\n\n    for (let i = 0, start = (map.height - 1) * map.width; i < Math.max(map.width, width); i++) {\n      let header = i >= map.width ? false : table.nodeAt(map.map[start + i]).type == types.header_cell;\n      cells.push(header ? emptyHead || (emptyHead = types.header_cell.createAndFill()) : empty || (empty = types.cell.createAndFill()));\n    }\n\n    let emptyRow = types.row.create(null, Fragment.from(cells)),\n        rows = [];\n\n    for (let i = map.height; i < height; i++) rows.push(emptyRow);\n\n    tr.insert(tr.mapping.slice(mapFrom).map(start + table.nodeSize - 2), rows);\n  }\n\n  return !!(empty || emptyHead);\n} // Make sure the given line (left, top) to (right, top) doesn't cross\n// any rowspan cells by splitting cells that cross it. Return true if\n// something changed.\n\n\nfunction isolateHorizontal(tr, map, table, start, left, right, top, mapFrom) {\n  if (top == 0 || top == map.height) return false;\n  let found = false;\n\n  for (let col = left; col < right; col++) {\n    let index = top * map.width + col,\n        pos = map.map[index];\n\n    if (map.map[index - map.width] == pos) {\n      found = true;\n      let cell = table.nodeAt(pos);\n      let {\n        top: cellTop,\n        left: cellLeft\n      } = map.findCell(pos);\n      tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + start), null, setAttr(cell.attrs, 'rowspan', top - cellTop));\n      tr.insert(tr.mapping.slice(mapFrom).map(map.positionAt(top, cellLeft, table)), cell.type.createAndFill(setAttr(cell.attrs, 'rowspan', cellTop + cell.attrs.rowspan - top)));\n      col += cell.attrs.colspan - 1;\n    }\n  }\n\n  return found;\n} // Make sure the given line (left, top) to (left, bottom) doesn't\n// cross any colspan cells by splitting cells that cross it. Return\n// true if something changed.\n\n\nfunction isolateVertical(tr, map, table, start, top, bottom, left, mapFrom) {\n  if (left == 0 || left == map.width) return false;\n  let found = false;\n\n  for (let row = top; row < bottom; row++) {\n    let index = row * map.width + left,\n        pos = map.map[index];\n\n    if (map.map[index - 1] == pos) {\n      found = true;\n      let cell = table.nodeAt(pos),\n          cellLeft = map.colCount(pos);\n      let updatePos = tr.mapping.slice(mapFrom).map(pos + start);\n      tr.setNodeMarkup(updatePos, null, removeColSpan(cell.attrs, left - cellLeft, cell.attrs.colspan - (left - cellLeft)));\n      tr.insert(updatePos + cell.nodeSize, cell.type.createAndFill(removeColSpan(cell.attrs, 0, left - cellLeft)));\n      row += cell.attrs.rowspan - 1;\n    }\n  }\n\n  return found;\n} // Insert the given set of cells (as returned by `pastedCells`) into a\n// table, at the position pointed at by rect.\n\n\nfunction insertCells(state, dispatch, tableStart, rect, cells) {\n  let table = tableStart ? state.doc.nodeAt(tableStart - 1) : state.doc,\n      map = TableMap.get(table);\n  let {\n    top,\n    left\n  } = rect;\n  let right = left + cells.width,\n      bottom = top + cells.height;\n  let tr = state.tr,\n      mapFrom = 0;\n\n  function recomp() {\n    table = tableStart ? tr.doc.nodeAt(tableStart - 1) : tr.doc;\n    map = TableMap.get(table);\n    mapFrom = tr.mapping.maps.length;\n  } // Prepare the table to be large enough and not have any cells\n  // crossing the boundaries of the rectangle that we want to\n  // insert into. If anything about it changes, recompute the table\n  // map so that subsequent operations can see the current shape.\n\n\n  if (growTable(tr, map, table, tableStart, right, bottom, mapFrom)) recomp();\n  if (isolateHorizontal(tr, map, table, tableStart, left, right, top, mapFrom)) recomp();\n  if (isolateHorizontal(tr, map, table, tableStart, left, right, bottom, mapFrom)) recomp();\n  if (isolateVertical(tr, map, table, tableStart, top, bottom, left, mapFrom)) recomp();\n  if (isolateVertical(tr, map, table, tableStart, top, bottom, right, mapFrom)) recomp();\n\n  for (let row = top; row < bottom; row++) {\n    let from = map.positionAt(row, left, table),\n        to = map.positionAt(row, right, table);\n    tr.replace(tr.mapping.slice(mapFrom).map(from + tableStart), tr.mapping.slice(mapFrom).map(to + tableStart), new Slice(cells.rows[row - top], 0, 0));\n  }\n\n  recomp();\n  tr.setSelection(new CellSelection(tr.doc.resolve(tableStart + map.positionAt(top, left, table)), tr.doc.resolve(tableStart + map.positionAt(bottom - 1, right - 1, table))));\n  dispatch(tr);\n}\n\n// This file defines a number of helpers for wiring up user input to\nconst handleKeyDown = keydownHandler({\n  ArrowLeft: arrow('horiz', -1),\n  ArrowRight: arrow('horiz', 1),\n  ArrowUp: arrow('vert', -1),\n  ArrowDown: arrow('vert', 1),\n  'Shift-ArrowLeft': shiftArrow('horiz', -1),\n  'Shift-ArrowRight': shiftArrow('horiz', 1),\n  'Shift-ArrowUp': shiftArrow('vert', -1),\n  'Shift-ArrowDown': shiftArrow('vert', 1),\n  Backspace: deleteCellSelection,\n  'Mod-Backspace': deleteCellSelection,\n  Delete: deleteCellSelection,\n  'Mod-Delete': deleteCellSelection\n});\n\nfunction maybeSetSelection(state, dispatch, selection) {\n  if (selection.eq(state.selection)) return false;\n  if (dispatch) dispatch(state.tr.setSelection(selection).scrollIntoView());\n  return true;\n}\n\nfunction arrow(axis, dir) {\n  return (state, dispatch, view) => {\n    let sel = state.selection;\n\n    if (sel instanceof CellSelection) {\n      return maybeSetSelection(state, dispatch, Selection.near(sel.$headCell, dir));\n    }\n\n    if (axis != 'horiz' && !sel.empty) return false;\n    let end = atEndOfCell(view, axis, dir);\n    if (end == null) return false;\n\n    if (axis == 'horiz') {\n      return maybeSetSelection(state, dispatch, Selection.near(state.doc.resolve(sel.head + dir), dir));\n    } else {\n      let $cell = state.doc.resolve(end),\n          $next = nextCell($cell, axis, dir),\n          newSel;\n      if ($next) newSel = Selection.near($next, 1);else if (dir < 0) newSel = Selection.near(state.doc.resolve($cell.before(-1)), -1);else newSel = Selection.near(state.doc.resolve($cell.after(-1)), 1);\n      return maybeSetSelection(state, dispatch, newSel);\n    }\n  };\n}\n\nfunction shiftArrow(axis, dir) {\n  return (state, dispatch, view) => {\n    let sel = state.selection;\n\n    if (!(sel instanceof CellSelection)) {\n      let end = atEndOfCell(view, axis, dir);\n      if (end == null) return false;\n      sel = new CellSelection(state.doc.resolve(end));\n    }\n\n    let $head = nextCell(sel.$headCell, axis, dir);\n    if (!$head) return false;\n    return maybeSetSelection(state, dispatch, new CellSelection(sel.$anchorCell, $head));\n  };\n}\n\nfunction deleteCellSelection(state, dispatch) {\n  let sel = state.selection;\n  if (!(sel instanceof CellSelection)) return false;\n\n  if (dispatch) {\n    let tr = state.tr,\n        baseContent = tableNodeTypes(state.schema).cell.createAndFill().content;\n    sel.forEachCell((cell, pos) => {\n      if (!cell.content.eq(baseContent)) tr.replace(tr.mapping.map(pos + 1), tr.mapping.map(pos + cell.nodeSize - 1), new Slice(baseContent, 0, 0));\n    });\n    if (tr.docChanged) dispatch(tr);\n  }\n\n  return true;\n}\n\nfunction handleTripleClick(view, pos) {\n  let doc = view.state.doc,\n      $cell = cellAround(doc.resolve(pos));\n  if (!$cell) return false;\n  view.dispatch(view.state.tr.setSelection(new CellSelection($cell)));\n  return true;\n}\nfunction handlePaste(view, _, slice) {\n  if (!isInTable(view.state)) return false;\n  let cells = pastedCells(slice),\n      sel = view.state.selection;\n\n  if (sel instanceof CellSelection) {\n    if (!cells) cells = {\n      width: 1,\n      height: 1,\n      rows: [Fragment.from(fitSlice(tableNodeTypes(view.state.schema).cell, slice))]\n    };\n    let table = sel.$anchorCell.node(-1),\n        start = sel.$anchorCell.start(-1);\n    let rect = TableMap.get(table).rectBetween(sel.$anchorCell.pos - start, sel.$headCell.pos - start);\n    cells = clipCells(cells, rect.right - rect.left, rect.bottom - rect.top);\n    insertCells(view.state, view.dispatch, start, rect, cells);\n    return true;\n  } else if (cells) {\n    let $cell = selectionCell(view.state),\n        start = $cell.start(-1);\n    insertCells(view.state, view.dispatch, start, TableMap.get($cell.node(-1)).findCell($cell.pos - start), cells);\n    return true;\n  } else {\n    return false;\n  }\n}\nfunction handleMouseDown$1(view, startEvent) {\n  if (startEvent.ctrlKey || startEvent.metaKey) return;\n  let startDOMCell = domInCell(view, startEvent.target),\n      $anchor;\n\n  if (startEvent.shiftKey && view.state.selection instanceof CellSelection) {\n    // Adding to an existing cell selection\n    setCellSelection(view.state.selection.$anchorCell, startEvent);\n    startEvent.preventDefault();\n  } else if (startEvent.shiftKey && startDOMCell && ($anchor = cellAround(view.state.selection.$anchor)) != null && cellUnderMouse(view, startEvent).pos != $anchor.pos) {\n    // Adding to a selection that starts in another cell (causing a\n    // cell selection to be created).\n    setCellSelection($anchor, startEvent);\n    startEvent.preventDefault();\n  } else if (!startDOMCell) {\n    // Not in a cell, let the default behavior happen.\n    return;\n  } // Create and dispatch a cell selection between the given anchor and\n  // the position under the mouse.\n\n\n  function setCellSelection($anchor, event) {\n    let $head = cellUnderMouse(view, event);\n    let starting = key$1.getState(view.state) == null;\n\n    if (!$head || !inSameTable($anchor, $head)) {\n      if (starting) $head = $anchor;else return;\n    }\n\n    let selection = new CellSelection($anchor, $head);\n\n    if (starting || !view.state.selection.eq(selection)) {\n      let tr = view.state.tr.setSelection(selection);\n      if (starting) tr.setMeta(key$1, $anchor.pos);\n      view.dispatch(tr);\n    }\n  } // Stop listening to mouse motion events.\n\n\n  function stop() {\n    view.root.removeEventListener('mouseup', stop);\n    view.root.removeEventListener('dragstart', stop);\n    view.root.removeEventListener('mousemove', move);\n    if (key$1.getState(view.state) != null) view.dispatch(view.state.tr.setMeta(key$1, -1));\n  }\n\n  function move(event) {\n    let anchor = key$1.getState(view.state),\n        $anchor;\n\n    if (anchor != null) {\n      // Continuing an existing cross-cell selection\n      $anchor = view.state.doc.resolve(anchor);\n    } else if (domInCell(view, event.target) != startDOMCell) {\n      // Moving out of the initial cell -- start a new cell selection\n      $anchor = cellUnderMouse(view, startEvent);\n      if (!$anchor) return stop();\n    }\n\n    if ($anchor) setCellSelection($anchor, event);\n  }\n\n  view.root.addEventListener('mouseup', stop);\n  view.root.addEventListener('dragstart', stop);\n  view.root.addEventListener('mousemove', move);\n} // Check whether the cursor is at the end of a cell (so that further\n// motion would move out of the cell)\n\nfunction atEndOfCell(view, axis, dir) {\n  if (!(view.state.selection instanceof TextSelection)) return null;\n  let {\n    $head\n  } = view.state.selection;\n\n  for (let d = $head.depth - 1; d >= 0; d--) {\n    let parent = $head.node(d),\n        index = dir < 0 ? $head.index(d) : $head.indexAfter(d);\n    if (index != (dir < 0 ? 0 : parent.childCount)) return null;\n\n    if (parent.type.spec.tableRole == 'cell' || parent.type.spec.tableRole == 'header_cell') {\n      let cellPos = $head.before(d);\n      let dirStr = axis == 'vert' ? dir > 0 ? 'down' : 'up' : dir > 0 ? 'right' : 'left';\n      return view.endOfTextblock(dirStr) ? cellPos : null;\n    }\n  }\n\n  return null;\n}\n\nfunction domInCell(view, dom) {\n  for (; dom && dom != view.dom; dom = dom.parentNode) if (dom.nodeName == 'TD' || dom.nodeName == 'TH') return dom;\n}\n\nfunction cellUnderMouse(view, event) {\n  let mousePos = view.posAtCoords({\n    left: event.clientX,\n    top: event.clientY\n  });\n  if (!mousePos) return null;\n  return mousePos ? cellAround(view.state.doc.resolve(mousePos.pos)) : null;\n}\n\n// This file defines helpers for normalizing tables, making sure no\nconst fixTablesKey = new PluginKey('fix-tables'); // Helper for iterating through the nodes in a document that changed\n// compared to the given previous document. Useful for avoiding\n// duplicate work on each transaction.\n\nfunction changedDescendants(old, cur, offset, f) {\n  let oldSize = old.childCount,\n      curSize = cur.childCount;\n\n  outer: for (let i = 0, j = 0; i < curSize; i++) {\n    let child = cur.child(i);\n\n    for (let scan = j, e = Math.min(oldSize, i + 3); scan < e; scan++) {\n      if (old.child(scan) == child) {\n        j = scan + 1;\n        offset += child.nodeSize;\n        continue outer;\n      }\n    }\n\n    f(child, offset);\n    if (j < oldSize && old.child(j).sameMarkup(child)) changedDescendants(old.child(j), child, offset + 1, f);else child.nodesBetween(0, child.content.size, f, offset + 1);\n    offset += child.nodeSize;\n  }\n} // :: (EditorState, ?EditorState) → ?Transaction\n// Inspect all tables in the given state's document and return a\n// transaction that fixes them, if necessary. If `oldState` was\n// provided, that is assumed to hold a previous, known-good state,\n// which will be used to avoid re-scanning unchanged parts of the\n// document.\n\n\nfunction fixTables(state, oldState) {\n  let tr,\n      check = (node, pos) => {\n    if (node.type.spec.tableRole == 'table') tr = fixTable(state, node, pos, tr);\n  };\n\n  if (!oldState) state.doc.descendants(check);else if (oldState.doc != state.doc) changedDescendants(oldState.doc, state.doc, 0, check);\n  return tr;\n} // : (EditorState, Node, number, ?Transaction) → ?Transaction\n// Fix the given table, if necessary. Will append to the transaction\n// it was given, if non-null, or create a new one if necessary.\n\nfunction fixTable(state, table, tablePos, tr) {\n  let map = TableMap.get(table);\n  if (!map.problems) return tr;\n  if (!tr) tr = state.tr; // Track which rows we must add cells to, so that we can adjust that\n  // when fixing collisions.\n\n  let mustAdd = [];\n\n  for (let i = 0; i < map.height; i++) mustAdd.push(0);\n\n  for (let i = 0; i < map.problems.length; i++) {\n    let prob = map.problems[i];\n\n    if (prob.type == 'collision') {\n      let cell = table.nodeAt(prob.pos);\n\n      for (let j = 0; j < cell.attrs.rowspan; j++) mustAdd[prob.row + j] += prob.n;\n\n      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, removeColSpan(cell.attrs, cell.attrs.colspan - prob.n, prob.n));\n    } else if (prob.type == 'missing') {\n      mustAdd[prob.row] += prob.n;\n    } else if (prob.type == 'overlong_rowspan') {\n      let cell = table.nodeAt(prob.pos);\n      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, setAttr(cell.attrs, 'rowspan', cell.attrs.rowspan - prob.n));\n    } else if (prob.type == 'colwidth mismatch') {\n      let cell = table.nodeAt(prob.pos);\n      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, setAttr(cell.attrs, 'colwidth', prob.colwidth));\n    }\n  }\n\n  let first, last;\n\n  for (let i = 0; i < mustAdd.length; i++) if (mustAdd[i]) {\n    if (first == null) first = i;\n    last = i;\n  } // Add the necessary cells, using a heuristic for whether to add the\n  // cells at the start or end of the rows (if it looks like a 'bite'\n  // was taken out of the table, add cells at the start of the row\n  // after the bite. Otherwise add them at the end).\n\n\n  for (let i = 0, pos = tablePos + 1; i < map.height; i++) {\n    let row = table.child(i);\n    let end = pos + row.nodeSize;\n    let add = mustAdd[i];\n\n    if (add > 0) {\n      let tableNodeType = 'cell';\n\n      if (row.firstChild) {\n        tableNodeType = row.firstChild.type.spec.tableRole;\n      }\n\n      let nodes = [];\n\n      for (let j = 0; j < add; j++) nodes.push(tableNodeTypes(state.schema)[tableNodeType].createAndFill());\n\n      let side = (i == 0 || first == i - 1) && last == i ? pos + 1 : end - 1;\n      tr.insert(tr.mapping.map(side), nodes);\n    }\n\n    pos = end;\n  }\n\n  return tr.setMeta(fixTablesKey, {\n    fixTables: true\n  });\n}\n\n// This file defines a number of table-related commands.\n// map, table node, and table start offset to the object for\n// convenience.\n\nfunction selectedRect(state) {\n  let sel = state.selection,\n      $pos = selectionCell(state);\n  let table = $pos.node(-1),\n      tableStart = $pos.start(-1),\n      map = TableMap.get(table);\n  let rect;\n  if (sel instanceof CellSelection) rect = map.rectBetween(sel.$anchorCell.pos - tableStart, sel.$headCell.pos - tableStart);else rect = map.findCell($pos.pos - tableStart);\n  rect.tableStart = tableStart;\n  rect.map = map;\n  rect.table = table;\n  return rect;\n} // Add a column at the given position in a table.\n\nfunction addColumn(tr, {\n  map,\n  tableStart,\n  table\n}, col) {\n  let refColumn = col > 0 ? -1 : 0;\n  if (columnIsHeader(map, table, col + refColumn)) refColumn = col == 0 || col == map.width ? null : 0;\n\n  for (let row = 0; row < map.height; row++) {\n    let index = row * map.width + col; // If this position falls inside a col-spanning cell\n\n    if (col > 0 && col < map.width && map.map[index - 1] == map.map[index]) {\n      let pos = map.map[index],\n          cell = table.nodeAt(pos);\n      tr.setNodeMarkup(tr.mapping.map(tableStart + pos), null, addColSpan(cell.attrs, col - map.colCount(pos))); // Skip ahead if rowspan > 1\n\n      row += cell.attrs.rowspan - 1;\n    } else {\n      let type = refColumn == null ? tableNodeTypes(table.type.schema).cell : table.nodeAt(map.map[index + refColumn]).type;\n      let pos = map.positionAt(row, col, table);\n      tr.insert(tr.mapping.map(tableStart + pos), type.createAndFill());\n    }\n  }\n\n  return tr;\n} // :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Command to add a column before the column with the selection.\n\nfunction addColumnBefore(state, dispatch) {\n  if (!isInTable(state)) return false;\n\n  if (dispatch) {\n    let rect = selectedRect(state);\n    dispatch(addColumn(state.tr, rect, rect.left));\n  }\n\n  return true;\n} // :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Command to add a column after the column with the selection.\n\nfunction addColumnAfter(state, dispatch) {\n  if (!isInTable(state)) return false;\n\n  if (dispatch) {\n    let rect = selectedRect(state);\n    dispatch(addColumn(state.tr, rect, rect.right));\n  }\n\n  return true;\n}\nfunction removeColumn(tr, {\n  map,\n  table,\n  tableStart\n}, col) {\n  let mapStart = tr.mapping.maps.length;\n\n  for (let row = 0; row < map.height;) {\n    let index = row * map.width + col,\n        pos = map.map[index],\n        cell = table.nodeAt(pos); // If this is part of a col-spanning cell\n\n    if (col > 0 && map.map[index - 1] == pos || col < map.width - 1 && map.map[index + 1] == pos) {\n      tr.setNodeMarkup(tr.mapping.slice(mapStart).map(tableStart + pos), null, removeColSpan(cell.attrs, col - map.colCount(pos)));\n    } else {\n      let start = tr.mapping.slice(mapStart).map(tableStart + pos);\n      tr.delete(start, start + cell.nodeSize);\n    }\n\n    row += cell.attrs.rowspan;\n  }\n} // :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Command function that removes the selected columns from a table.\n\nfunction deleteColumn(state, dispatch) {\n  if (!isInTable(state)) return false;\n\n  if (dispatch) {\n    let rect = selectedRect(state),\n        tr = state.tr;\n    if (rect.left == 0 && rect.right == rect.map.width) return false;\n\n    for (let i = rect.right - 1;; i--) {\n      removeColumn(tr, rect, i);\n      if (i == rect.left) break;\n      rect.table = rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc;\n      rect.map = TableMap.get(rect.table);\n    }\n\n    dispatch(tr);\n  }\n\n  return true;\n}\nfunction rowIsHeader(map, table, row) {\n  let headerCell = tableNodeTypes(table.type.schema).header_cell;\n\n  for (let col = 0; col < map.width; col++) if (table.nodeAt(map.map[col + row * map.width]).type != headerCell) return false;\n\n  return true;\n}\nfunction addRow(tr, {\n  map,\n  tableStart,\n  table\n}, row) {\n  let rowPos = tableStart;\n\n  for (let i = 0; i < row; i++) rowPos += table.child(i).nodeSize;\n\n  let cells = [],\n      refRow = row > 0 ? -1 : 0;\n  if (rowIsHeader(map, table, row + refRow)) refRow = row == 0 || row == map.height ? null : 0;\n\n  for (let col = 0, index = map.width * row; col < map.width; col++, index++) {\n    // Covered by a rowspan cell\n    if (row > 0 && row < map.height && map.map[index] == map.map[index - map.width]) {\n      let pos = map.map[index],\n          attrs = table.nodeAt(pos).attrs;\n      tr.setNodeMarkup(tableStart + pos, null, setAttr(attrs, 'rowspan', attrs.rowspan + 1));\n      col += attrs.colspan - 1;\n    } else {\n      let type = refRow == null ? tableNodeTypes(table.type.schema).cell : table.nodeAt(map.map[index + refRow * map.width]).type;\n      cells.push(type.createAndFill());\n    }\n  }\n\n  tr.insert(rowPos, tableNodeTypes(table.type.schema).row.create(null, cells));\n  return tr;\n} // :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Add a table row before the selection.\n\nfunction addRowBefore(state, dispatch) {\n  if (!isInTable(state)) return false;\n\n  if (dispatch) {\n    let rect = selectedRect(state);\n    dispatch(addRow(state.tr, rect, rect.top));\n  }\n\n  return true;\n} // :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Add a table row after the selection.\n\nfunction addRowAfter(state, dispatch) {\n  if (!isInTable(state)) return false;\n\n  if (dispatch) {\n    let rect = selectedRect(state);\n    dispatch(addRow(state.tr, rect, rect.bottom));\n  }\n\n  return true;\n}\nfunction removeRow(tr, {\n  map,\n  table,\n  tableStart\n}, row) {\n  let rowPos = 0;\n\n  for (let i = 0; i < row; i++) rowPos += table.child(i).nodeSize;\n\n  let nextRow = rowPos + table.child(row).nodeSize;\n  let mapFrom = tr.mapping.maps.length;\n  tr.delete(rowPos + tableStart, nextRow + tableStart);\n\n  for (let col = 0, index = row * map.width; col < map.width; col++, index++) {\n    let pos = map.map[index];\n\n    if (row > 0 && pos == map.map[index - map.width]) {\n      // If this cell starts in the row above, simply reduce its rowspan\n      let attrs = table.nodeAt(pos).attrs;\n      tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + tableStart), null, setAttr(attrs, 'rowspan', attrs.rowspan - 1));\n      col += attrs.colspan - 1;\n    } else if (row < map.width && pos == map.map[index + map.width]) {\n      // Else, if it continues in the row below, it has to be moved down\n      let cell = table.nodeAt(pos);\n      let copy = cell.type.create(setAttr(cell.attrs, 'rowspan', cell.attrs.rowspan - 1), cell.content);\n      let newPos = map.positionAt(row + 1, col, table);\n      tr.insert(tr.mapping.slice(mapFrom).map(tableStart + newPos), copy);\n      col += cell.attrs.colspan - 1;\n    }\n  }\n} // :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Remove the selected rows from a table.\n\nfunction deleteRow(state, dispatch) {\n  if (!isInTable(state)) return false;\n\n  if (dispatch) {\n    let rect = selectedRect(state),\n        tr = state.tr;\n    if (rect.top == 0 && rect.bottom == rect.map.height) return false;\n\n    for (let i = rect.bottom - 1;; i--) {\n      removeRow(tr, rect, i);\n      if (i == rect.top) break;\n      rect.table = rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc;\n      rect.map = TableMap.get(rect.table);\n    }\n\n    dispatch(tr);\n  }\n\n  return true;\n}\n\nfunction isEmpty(cell) {\n  let c = cell.content;\n  return c.childCount == 1 && c.firstChild.isTextblock && c.firstChild.childCount == 0;\n}\n\nfunction cellsOverlapRectangle({\n  width,\n  height,\n  map\n}, rect) {\n  let indexTop = rect.top * width + rect.left,\n      indexLeft = indexTop;\n  let indexBottom = (rect.bottom - 1) * width + rect.left,\n      indexRight = indexTop + (rect.right - rect.left - 1);\n\n  for (let i = rect.top; i < rect.bottom; i++) {\n    if (rect.left > 0 && map[indexLeft] == map[indexLeft - 1] || rect.right < width && map[indexRight] == map[indexRight + 1]) return true;\n    indexLeft += width;\n    indexRight += width;\n  }\n\n  for (let i = rect.left; i < rect.right; i++) {\n    if (rect.top > 0 && map[indexTop] == map[indexTop - width] || rect.bottom < height && map[indexBottom] == map[indexBottom + width]) return true;\n    indexTop++;\n    indexBottom++;\n  }\n\n  return false;\n} // :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Merge the selected cells into a single cell. Only available when\n// the selected cells' outline forms a rectangle.\n\n\nfunction mergeCells(state, dispatch) {\n  let sel = state.selection;\n  if (!(sel instanceof CellSelection) || sel.$anchorCell.pos == sel.$headCell.pos) return false;\n  let rect = selectedRect(state),\n      {\n    map\n  } = rect;\n  if (cellsOverlapRectangle(map, rect)) return false;\n\n  if (dispatch) {\n    let tr = state.tr,\n        seen = {},\n        content = Fragment.empty,\n        mergedPos,\n        mergedCell;\n\n    for (let row = rect.top; row < rect.bottom; row++) {\n      for (let col = rect.left; col < rect.right; col++) {\n        let cellPos = map.map[row * map.width + col],\n            cell = rect.table.nodeAt(cellPos);\n        if (seen[cellPos]) continue;\n        seen[cellPos] = true;\n\n        if (mergedPos == null) {\n          mergedPos = cellPos;\n          mergedCell = cell;\n        } else {\n          if (!isEmpty(cell)) content = content.append(cell.content);\n          let mapped = tr.mapping.map(cellPos + rect.tableStart);\n          tr.delete(mapped, mapped + cell.nodeSize);\n        }\n      }\n    }\n\n    tr.setNodeMarkup(mergedPos + rect.tableStart, null, setAttr(addColSpan(mergedCell.attrs, mergedCell.attrs.colspan, rect.right - rect.left - mergedCell.attrs.colspan), 'rowspan', rect.bottom - rect.top));\n\n    if (content.size) {\n      let end = mergedPos + 1 + mergedCell.content.size;\n      let start = isEmpty(mergedCell) ? mergedPos + 1 : end;\n      tr.replaceWith(start + rect.tableStart, end + rect.tableStart, content);\n    }\n\n    tr.setSelection(new CellSelection(tr.doc.resolve(mergedPos + rect.tableStart)));\n    dispatch(tr);\n  }\n\n  return true;\n} // :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Split a selected cell, whose rowpan or colspan is greater than one,\n// into smaller cells. Use the first cell type for the new cells.\n\nfunction splitCell(state, dispatch) {\n  const nodeTypes = tableNodeTypes(state.schema);\n  return splitCellWithType(({\n    node\n  }) => {\n    return nodeTypes[node.type.spec.tableRole];\n  })(state, dispatch);\n} // :: (getCellType: ({ row: number, col: number, node: Node}) → NodeType) → (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Split a selected cell, whose rowpan or colspan is greater than one,\n// into smaller cells with the cell type (th, td) returned by getType function.\n\nfunction splitCellWithType(getCellType) {\n  return (state, dispatch) => {\n    let sel = state.selection;\n    let cellNode, cellPos;\n\n    if (!(sel instanceof CellSelection)) {\n      cellNode = cellWrapping(sel.$from);\n      if (!cellNode) return false;\n      cellPos = cellAround(sel.$from).pos;\n    } else {\n      if (sel.$anchorCell.pos != sel.$headCell.pos) return false;\n      cellNode = sel.$anchorCell.nodeAfter;\n      cellPos = sel.$anchorCell.pos;\n    }\n\n    if (cellNode.attrs.colspan == 1 && cellNode.attrs.rowspan == 1) {\n      return false;\n    }\n\n    if (dispatch) {\n      let baseAttrs = cellNode.attrs,\n          attrs = [],\n          colwidth = baseAttrs.colwidth;\n      if (baseAttrs.rowspan > 1) baseAttrs = setAttr(baseAttrs, 'rowspan', 1);\n      if (baseAttrs.colspan > 1) baseAttrs = setAttr(baseAttrs, 'colspan', 1);\n      let rect = selectedRect(state),\n          tr = state.tr;\n\n      for (let i = 0; i < rect.right - rect.left; i++) attrs.push(colwidth ? setAttr(baseAttrs, 'colwidth', colwidth && colwidth[i] ? [colwidth[i]] : null) : baseAttrs);\n\n      let lastCell;\n\n      for (let row = rect.top; row < rect.bottom; row++) {\n        let pos = rect.map.positionAt(row, rect.left, rect.table);\n        if (row == rect.top) pos += cellNode.nodeSize;\n\n        for (let col = rect.left, i = 0; col < rect.right; col++, i++) {\n          if (col == rect.left && row == rect.top) continue;\n          tr.insert(lastCell = tr.mapping.map(pos + rect.tableStart, 1), getCellType({\n            node: cellNode,\n            row,\n            col\n          }).createAndFill(attrs[i]));\n        }\n      }\n\n      tr.setNodeMarkup(cellPos, getCellType({\n        node: cellNode,\n        row: rect.top,\n        col: rect.left\n      }), attrs[0]);\n      if (sel instanceof CellSelection) tr.setSelection(new CellSelection(tr.doc.resolve(sel.$anchorCell.pos), lastCell && tr.doc.resolve(lastCell)));\n      dispatch(tr);\n    }\n\n    return true;\n  };\n} // :: (string, any) → (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Returns a command that sets the given attribute to the given value,\n// and is only available when the currently selected cell doesn't\n// already have that attribute set to that value.\n\nfunction setCellAttr(name, value) {\n  return function (state, dispatch) {\n    if (!isInTable(state)) return false;\n    let $cell = selectionCell(state);\n    if ($cell.nodeAfter.attrs[name] === value) return false;\n\n    if (dispatch) {\n      let tr = state.tr;\n      if (state.selection instanceof CellSelection) state.selection.forEachCell((node, pos) => {\n        if (node.attrs[name] !== value) tr.setNodeMarkup(pos, null, setAttr(node.attrs, name, value));\n      });else tr.setNodeMarkup($cell.pos, null, setAttr($cell.nodeAfter.attrs, name, value));\n      dispatch(tr);\n    }\n\n    return true;\n  };\n}\n\nfunction deprecated_toggleHeader(type) {\n  return function (state, dispatch) {\n    if (!isInTable(state)) return false;\n\n    if (dispatch) {\n      let types = tableNodeTypes(state.schema);\n      let rect = selectedRect(state),\n          tr = state.tr;\n      let cells = rect.map.cellsInRect(type == 'column' ? new Rect(rect.left, 0, rect.right, rect.map.height) : type == 'row' ? new Rect(0, rect.top, rect.map.width, rect.bottom) : rect);\n      let nodes = cells.map(pos => rect.table.nodeAt(pos));\n\n      for (let i = 0; i < cells.length; i++ // Remove headers, if any\n      ) if (nodes[i].type == types.header_cell) tr.setNodeMarkup(rect.tableStart + cells[i], types.cell, nodes[i].attrs);\n\n      if (tr.steps.length == 0) for (let i = 0; i < cells.length; i++ // No headers removed, add instead\n      ) tr.setNodeMarkup(rect.tableStart + cells[i], types.header_cell, nodes[i].attrs);\n      dispatch(tr);\n    }\n\n    return true;\n  };\n}\n\nfunction isHeaderEnabledByType(type, rect, types) {\n  // Get cell positions for first row or first column\n  const cellPositions = rect.map.cellsInRect({\n    left: 0,\n    top: 0,\n    right: type == 'row' ? rect.map.width : 1,\n    bottom: type == 'column' ? rect.map.height : 1\n  });\n\n  for (let i = 0; i < cellPositions.length; i++) {\n    const cell = rect.table.nodeAt(cellPositions[i]);\n\n    if (cell && cell.type !== types.header_cell) {\n      return false;\n    }\n  }\n\n  return true;\n} // :: (string, ?{ useDeprecatedLogic: bool }) → (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Toggles between row/column header and normal cells (Only applies to first row/column).\n// For deprecated behavior pass `useDeprecatedLogic` in options with true.\n\n\nfunction toggleHeader(type, options) {\n  options = options || {\n    useDeprecatedLogic: false\n  };\n  if (options.useDeprecatedLogic) return deprecated_toggleHeader(type);\n  return function (state, dispatch) {\n    if (!isInTable(state)) return false;\n\n    if (dispatch) {\n      let types = tableNodeTypes(state.schema);\n      let rect = selectedRect(state),\n          tr = state.tr;\n      let isHeaderRowEnabled = isHeaderEnabledByType('row', rect, types);\n      let isHeaderColumnEnabled = isHeaderEnabledByType('column', rect, types);\n      let isHeaderEnabled = type === 'column' ? isHeaderRowEnabled : type === 'row' ? isHeaderColumnEnabled : false;\n      let selectionStartsAt = isHeaderEnabled ? 1 : 0;\n      let cellsRect = type == 'column' ? new Rect(0, selectionStartsAt, 1, rect.map.height) : type == 'row' ? new Rect(selectionStartsAt, 0, rect.map.width, 1) : rect;\n      let newType = type == 'column' ? isHeaderColumnEnabled ? types.cell : types.header_cell : type == 'row' ? isHeaderRowEnabled ? types.cell : types.header_cell : types.cell;\n      rect.map.cellsInRect(cellsRect).forEach(relativeCellPos => {\n        const cellPos = relativeCellPos + rect.tableStart;\n        const cell = tr.doc.nodeAt(cellPos);\n\n        if (cell) {\n          tr.setNodeMarkup(cellPos, newType, cell.attrs);\n        }\n      });\n      dispatch(tr);\n    }\n\n    return true;\n  };\n} // :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Toggles whether the selected row contains header cells.\n\nlet toggleHeaderRow = toggleHeader('row', {\n  useDeprecatedLogic: true\n}); // :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Toggles whether the selected column contains header cells.\n\nlet toggleHeaderColumn = toggleHeader('column', {\n  useDeprecatedLogic: true\n}); // :: (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Toggles whether the selected cells are header cells.\n\nlet toggleHeaderCell = toggleHeader('cell', {\n  useDeprecatedLogic: true\n});\n\nfunction findNextCell($cell, dir) {\n  if (dir < 0) {\n    let before = $cell.nodeBefore;\n    if (before) return $cell.pos - before.nodeSize;\n\n    for (let row = $cell.index(-1) - 1, rowEnd = $cell.before(); row >= 0; row--) {\n      let rowNode = $cell.node(-1).child(row);\n      if (rowNode.childCount) return rowEnd - 1 - rowNode.lastChild.nodeSize;\n      rowEnd -= rowNode.nodeSize;\n    }\n  } else {\n    if ($cell.index() < $cell.parent.childCount - 1) return $cell.pos + $cell.nodeAfter.nodeSize;\n    let table = $cell.node(-1);\n\n    for (let row = $cell.indexAfter(-1), rowStart = $cell.after(); row < table.childCount; row++) {\n      let rowNode = table.child(row);\n      if (rowNode.childCount) return rowStart + 1;\n      rowStart += rowNode.nodeSize;\n    }\n  }\n} // :: (number) → (EditorState, dispatch: ?(tr: Transaction)) → bool\n// Returns a command for selecting the next (direction=1) or previous\n// (direction=-1) cell in a table.\n\n\nfunction goToNextCell(direction) {\n  return function (state, dispatch) {\n    if (!isInTable(state)) return false;\n    let cell = findNextCell(selectionCell(state), direction);\n    if (cell == null) return;\n\n    if (dispatch) {\n      let $cell = state.doc.resolve(cell);\n      dispatch(state.tr.setSelection(TextSelection.between($cell, moveCellForward($cell))).scrollIntoView());\n    }\n\n    return true;\n  };\n} // :: (EditorState, ?(tr: Transaction)) → bool\n// Deletes the table around the selection, if any.\n\nfunction deleteTable(state, dispatch) {\n  let $pos = state.selection.$anchor;\n\n  for (let d = $pos.depth; d > 0; d--) {\n    let node = $pos.node(d);\n\n    if (node.type.spec.tableRole == 'table') {\n      if (dispatch) dispatch(state.tr.delete($pos.before(d), $pos.after(d)).scrollIntoView());\n      return true;\n    }\n  }\n\n  return false;\n}\n\nclass TableView {\n  constructor(node, cellMinWidth) {\n    this.node = node;\n    this.cellMinWidth = cellMinWidth;\n    this.dom = document.createElement('div');\n    this.dom.className = 'tableWrapper';\n    this.table = this.dom.appendChild(document.createElement('table'));\n    this.colgroup = this.table.appendChild(document.createElement('colgroup'));\n    updateColumns(node, this.colgroup, this.table, cellMinWidth);\n    this.contentDOM = this.table.appendChild(document.createElement('tbody'));\n  }\n\n  update(node) {\n    if (node.type != this.node.type) return false;\n    this.node = node;\n    updateColumns(node, this.colgroup, this.table, this.cellMinWidth);\n    return true;\n  }\n\n  ignoreMutation(record) {\n    return record.type == 'attributes' && (record.target == this.table || this.colgroup.contains(record.target));\n  }\n\n}\nfunction updateColumns(node, colgroup, table, cellMinWidth, overrideCol, overrideValue) {\n  let totalWidth = 0,\n      fixedWidth = true;\n  let nextDOM = colgroup.firstChild,\n      row = node.firstChild;\n\n  for (let i = 0, col = 0; i < row.childCount; i++) {\n    let {\n      colspan,\n      colwidth\n    } = row.child(i).attrs;\n\n    for (let j = 0; j < colspan; j++, col++) {\n      let hasWidth = overrideCol == col ? overrideValue : colwidth && colwidth[j];\n      let cssWidth = hasWidth ? hasWidth + 'px' : '';\n      totalWidth += hasWidth || cellMinWidth;\n      if (!hasWidth) fixedWidth = false;\n\n      if (!nextDOM) {\n        colgroup.appendChild(document.createElement('col')).style.width = cssWidth;\n      } else {\n        if (nextDOM.style.width != cssWidth) nextDOM.style.width = cssWidth;\n        nextDOM = nextDOM.nextSibling;\n      }\n    }\n  }\n\n  while (nextDOM) {\n    let after = nextDOM.nextSibling;\n    nextDOM.parentNode.removeChild(nextDOM);\n    nextDOM = after;\n  }\n\n  if (fixedWidth) {\n    table.style.width = totalWidth + 'px';\n    table.style.minWidth = '';\n  } else {\n    table.style.width = '';\n    table.style.minWidth = totalWidth + 'px';\n  }\n}\n\nconst key = new PluginKey('tableColumnResizing');\nfunction columnResizing({\n  handleWidth = 5,\n  cellMinWidth = 25,\n  View = TableView,\n  lastColumnResizable = true\n} = {}) {\n  let plugin = new Plugin({\n    key,\n    state: {\n      init(_, state) {\n        this.spec.props.nodeViews[tableNodeTypes(state.schema).table.name] = (node, view) => new View(node, cellMinWidth, view);\n\n        return new ResizeState(-1, false);\n      },\n\n      apply(tr, prev) {\n        return prev.apply(tr);\n      }\n\n    },\n    props: {\n      attributes(state) {\n        let pluginState = key.getState(state);\n        return pluginState.activeHandle > -1 ? {\n          class: 'resize-cursor'\n        } : null;\n      },\n\n      handleDOMEvents: {\n        mousemove(view, event) {\n          handleMouseMove(view, event, handleWidth, cellMinWidth, lastColumnResizable);\n        },\n\n        mouseleave(view) {\n          handleMouseLeave(view);\n        },\n\n        mousedown(view, event) {\n          handleMouseDown(view, event, cellMinWidth);\n        }\n\n      },\n\n      decorations(state) {\n        let pluginState = key.getState(state);\n        if (pluginState.activeHandle > -1) return handleDecorations(state, pluginState.activeHandle);\n      },\n\n      nodeViews: {}\n    }\n  });\n  return plugin;\n}\n\nclass ResizeState {\n  constructor(activeHandle, dragging) {\n    this.activeHandle = activeHandle;\n    this.dragging = dragging;\n  }\n\n  apply(tr) {\n    let state = this,\n        action = tr.getMeta(key);\n    if (action && action.setHandle != null) return new ResizeState(action.setHandle, null);\n    if (action && action.setDragging !== undefined) return new ResizeState(state.activeHandle, action.setDragging);\n\n    if (state.activeHandle > -1 && tr.docChanged) {\n      let handle = tr.mapping.map(state.activeHandle, -1);\n      if (!pointsAtCell(tr.doc.resolve(handle))) handle = null;\n      state = new ResizeState(handle, state.dragging);\n    }\n\n    return state;\n  }\n\n}\n\nfunction handleMouseMove(view, event, handleWidth, cellMinWidth, lastColumnResizable) {\n  let pluginState = key.getState(view.state);\n\n  if (!pluginState.dragging) {\n    let target = domCellAround(event.target),\n        cell = -1;\n\n    if (target) {\n      let {\n        left,\n        right\n      } = target.getBoundingClientRect();\n      if (event.clientX - left <= handleWidth) cell = edgeCell(view, event, 'left');else if (right - event.clientX <= handleWidth) cell = edgeCell(view, event, 'right');\n    }\n\n    if (cell != pluginState.activeHandle) {\n      if (!lastColumnResizable && cell !== -1) {\n        let $cell = view.state.doc.resolve(cell);\n        let table = $cell.node(-1),\n            map = TableMap.get(table),\n            start = $cell.start(-1);\n        let col = map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;\n\n        if (col == map.width - 1) {\n          return;\n        }\n      }\n\n      updateHandle(view, cell);\n    }\n  }\n}\n\nfunction handleMouseLeave(view) {\n  let pluginState = key.getState(view.state);\n  if (pluginState.activeHandle > -1 && !pluginState.dragging) updateHandle(view, -1);\n}\n\nfunction handleMouseDown(view, event, cellMinWidth) {\n  let pluginState = key.getState(view.state);\n  if (pluginState.activeHandle == -1 || pluginState.dragging) return false;\n  let cell = view.state.doc.nodeAt(pluginState.activeHandle);\n  let width = currentColWidth(view, pluginState.activeHandle, cell.attrs);\n  view.dispatch(view.state.tr.setMeta(key, {\n    setDragging: {\n      startX: event.clientX,\n      startWidth: width\n    }\n  }));\n\n  function finish(event) {\n    window.removeEventListener('mouseup', finish);\n    window.removeEventListener('mousemove', move);\n    let pluginState = key.getState(view.state);\n\n    if (pluginState.dragging) {\n      updateColumnWidth(view, pluginState.activeHandle, draggedWidth(pluginState.dragging, event, cellMinWidth));\n      view.dispatch(view.state.tr.setMeta(key, {\n        setDragging: null\n      }));\n    }\n  }\n\n  function move(event) {\n    if (!event.which) return finish(event);\n    let pluginState = key.getState(view.state);\n    let dragged = draggedWidth(pluginState.dragging, event, cellMinWidth);\n    displayColumnWidth(view, pluginState.activeHandle, dragged, cellMinWidth);\n  }\n\n  window.addEventListener('mouseup', finish);\n  window.addEventListener('mousemove', move);\n  event.preventDefault();\n  return true;\n}\n\nfunction currentColWidth(view, cellPos, {\n  colspan,\n  colwidth\n}) {\n  let width = colwidth && colwidth[colwidth.length - 1];\n  if (width) return width;\n  let dom = view.domAtPos(cellPos);\n  let node = dom.node.childNodes[dom.offset];\n  let domWidth = node.offsetWidth,\n      parts = colspan;\n  if (colwidth) for (let i = 0; i < colspan; i++) if (colwidth[i]) {\n    domWidth -= colwidth[i];\n    parts--;\n  }\n  return domWidth / parts;\n}\n\nfunction domCellAround(target) {\n  while (target && target.nodeName != 'TD' && target.nodeName != 'TH') target = target.classList.contains('ProseMirror') ? null : target.parentNode;\n\n  return target;\n}\n\nfunction edgeCell(view, event, side) {\n  let found = view.posAtCoords({\n    left: event.clientX,\n    top: event.clientY\n  });\n  if (!found) return -1;\n  let {\n    pos\n  } = found;\n  let $cell = cellAround(view.state.doc.resolve(pos));\n  if (!$cell) return -1;\n  if (side == 'right') return $cell.pos;\n  let map = TableMap.get($cell.node(-1)),\n      start = $cell.start(-1);\n  let index = map.map.indexOf($cell.pos - start);\n  return index % map.width == 0 ? -1 : start + map.map[index - 1];\n}\n\nfunction draggedWidth(dragging, event, cellMinWidth) {\n  let offset = event.clientX - dragging.startX;\n  return Math.max(cellMinWidth, dragging.startWidth + offset);\n}\n\nfunction updateHandle(view, value) {\n  view.dispatch(view.state.tr.setMeta(key, {\n    setHandle: value\n  }));\n}\n\nfunction updateColumnWidth(view, cell, width) {\n  let $cell = view.state.doc.resolve(cell);\n  let table = $cell.node(-1),\n      map = TableMap.get(table),\n      start = $cell.start(-1);\n  let col = map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;\n  let tr = view.state.tr;\n\n  for (let row = 0; row < map.height; row++) {\n    let mapIndex = row * map.width + col; // Rowspanning cell that has already been handled\n\n    if (row && map.map[mapIndex] == map.map[mapIndex - map.width]) continue;\n    let pos = map.map[mapIndex],\n        {\n      attrs\n    } = table.nodeAt(pos);\n    let index = attrs.colspan == 1 ? 0 : col - map.colCount(pos);\n    if (attrs.colwidth && attrs.colwidth[index] == width) continue;\n    let colwidth = attrs.colwidth ? attrs.colwidth.slice() : zeroes(attrs.colspan);\n    colwidth[index] = width;\n    tr.setNodeMarkup(start + pos, null, setAttr(attrs, 'colwidth', colwidth));\n  }\n\n  if (tr.docChanged) view.dispatch(tr);\n}\n\nfunction displayColumnWidth(view, cell, width, cellMinWidth) {\n  let $cell = view.state.doc.resolve(cell);\n  let table = $cell.node(-1),\n      start = $cell.start(-1);\n  let col = TableMap.get(table).colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;\n  let dom = view.domAtPos($cell.start(-1)).node;\n\n  while (dom.nodeName != 'TABLE') dom = dom.parentNode;\n\n  updateColumns(table, dom.firstChild, dom, cellMinWidth, col, width);\n}\n\nfunction zeroes(n) {\n  let result = [];\n\n  for (let i = 0; i < n; i++) result.push(0);\n\n  return result;\n}\n\nfunction handleDecorations(state, cell) {\n  let decorations = [];\n  let $cell = state.doc.resolve(cell);\n  let table = $cell.node(-1),\n      map = TableMap.get(table),\n      start = $cell.start(-1);\n  let col = map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan;\n\n  for (let row = 0; row < map.height; row++) {\n    let index = col + row * map.width - 1; // For positions that are have either a different cell or the end\n    // of the table to their right, and either the top of the table or\n    // a different cell above them, add a decoration\n\n    if ((col == map.width || map.map[index] != map.map[index + 1]) && (row == 0 || map.map[index - 1] != map.map[index - 1 - map.width])) {\n      let cellPos = map.map[index];\n      let pos = start + cellPos + table.nodeAt(cellPos).nodeSize - 1;\n      let dom = document.createElement('div');\n      dom.className = 'column-resize-handle';\n      decorations.push(Decoration.widget(pos, dom));\n    }\n  }\n\n  return DecorationSet.create(state.doc, decorations);\n}\n\n// This file defines a plugin that handles the drawing of cell\n//\n// Creates a [plugin](http://prosemirror.net/docs/ref/#state.Plugin)\n// that, when added to an editor, enables cell-selection, handles\n// cell-based copy/paste, and makes sure tables stay well-formed (each\n// row has the same width, and cells don't overlap).\n//\n// You should probably put this plugin near the end of your array of\n// plugins, since it handles mouse and arrow key events in tables\n// rather broadly, and other plugins, like the gap cursor or the\n// column-width dragging plugin, might want to get a turn first to\n// perform more specific behavior.\n\nfunction tableEditing({\n  allowTableNodeSelection = false\n} = {}) {\n  return new Plugin({\n    key: key$1,\n    // This piece of state is used to remember when a mouse-drag\n    // cell-selection is happening, so that it can continue even as\n    // transactions (which might move its anchor cell) come in.\n    state: {\n      init() {\n        return null;\n      },\n\n      apply(tr, cur) {\n        let set = tr.getMeta(key$1);\n        if (set != null) return set == -1 ? null : set;\n        if (cur == null || !tr.docChanged) return cur;\n        let {\n          deleted,\n          pos\n        } = tr.mapping.mapResult(cur);\n        return deleted ? null : pos;\n      }\n\n    },\n    props: {\n      decorations: drawCellSelection,\n      handleDOMEvents: {\n        mousedown: handleMouseDown$1\n      },\n\n      createSelectionBetween(view) {\n        if (key$1.getState(view.state) != null) return view.state.selection;\n      },\n\n      handleTripleClick,\n      handleKeyDown,\n      handlePaste\n    },\n\n    appendTransaction(_, oldState, state) {\n      return normalizeSelection(state, fixTables(state, oldState), allowTableNodeSelection);\n    }\n\n  });\n}\n\nexport { CellSelection, TableMap, TableView, clipCells as __clipCells, insertCells as __insertCells, pastedCells as __pastedCells, addColSpan, addColumn, addColumnAfter, addColumnBefore, addRow, addRowAfter, addRowBefore, cellAround, colCount, columnIsHeader, columnResizing, key as columnResizingPluginKey, deleteColumn, deleteRow, deleteTable, findCell, fixTables, fixTablesKey, goToNextCell, handlePaste, inSameTable, isInTable, mergeCells, moveCellForward, nextCell, pointsAtCell, removeColSpan, removeColumn, removeRow, rowIsHeader, selectedRect, selectionCell, setAttr, setCellAttr, splitCell, splitCellWithType, tableEditing, key$1 as tableEditingKey, tableNodeTypes, tableNodes, toggleHeader, toggleHeaderCell, toggleHeaderColumn, toggleHeaderRow, updateColumns as updateColumnsOnResize };\n//# sourceMappingURL=index.esm.js.map\n","import { CellSelection, addColumnBefore, addColumnAfter, deleteColumn, addRowBefore, addRowAfter, deleteRow, deleteTable, mergeCells, splitCell, toggleHeader, toggleHeaderCell, setCellAttr, goToNextCell, fixTables, columnResizing, tableEditing } from '@_ueberdosis/prosemirror-tables';\nimport { findParentNodeClosestToPos, Node, mergeAttributes, callOrReturn, getExtensionField } from '@tiptap/core';\nimport { TextSelection } from 'prosemirror-state';\n\nfunction updateColumns(node, colgroup, table, cellMinWidth, overrideCol, overrideValue) {\r\n    let totalWidth = 0;\r\n    let fixedWidth = true;\r\n    let nextDOM = colgroup.firstChild;\r\n    const row = node.firstChild;\r\n    for (let i = 0, col = 0; i < row.childCount; i += 1) {\r\n        const { colspan, colwidth } = row.child(i).attrs;\r\n        for (let j = 0; j < colspan; j += 1, col += 1) {\r\n            const hasWidth = overrideCol === col ? overrideValue : colwidth && colwidth[j];\r\n            const cssWidth = hasWidth ? `${hasWidth}px` : '';\r\n            totalWidth += hasWidth || cellMinWidth;\r\n            if (!hasWidth) {\r\n                fixedWidth = false;\r\n            }\r\n            if (!nextDOM) {\r\n                colgroup.appendChild(document.createElement('col')).style.width = cssWidth;\r\n            }\r\n            else {\r\n                if (nextDOM.style.width !== cssWidth) {\r\n                    nextDOM.style.width = cssWidth;\r\n                }\r\n                nextDOM = nextDOM.nextSibling;\r\n            }\r\n        }\r\n    }\r\n    while (nextDOM) {\r\n        const after = nextDOM.nextSibling;\r\n        nextDOM.parentNode.removeChild(nextDOM);\r\n        nextDOM = after;\r\n    }\r\n    if (fixedWidth) {\r\n        table.style.width = `${totalWidth}px`;\r\n        table.style.minWidth = '';\r\n    }\r\n    else {\r\n        table.style.width = '';\r\n        table.style.minWidth = `${totalWidth}px`;\r\n    }\r\n}\r\nclass TableView {\r\n    constructor(node, cellMinWidth) {\r\n        this.node = node;\r\n        this.cellMinWidth = cellMinWidth;\r\n        this.dom = document.createElement('div');\r\n        this.dom.className = 'tableWrapper';\r\n        this.table = this.dom.appendChild(document.createElement('table'));\r\n        this.colgroup = this.table.appendChild(document.createElement('colgroup'));\r\n        updateColumns(node, this.colgroup, this.table, cellMinWidth);\r\n        this.contentDOM = this.table.appendChild(document.createElement('tbody'));\r\n    }\r\n    update(node) {\r\n        if (node.type !== this.node.type) {\r\n            return false;\r\n        }\r\n        this.node = node;\r\n        updateColumns(node, this.colgroup, this.table, this.cellMinWidth);\r\n        return true;\r\n    }\r\n    ignoreMutation(mutation) {\r\n        return mutation.type === 'attributes' && (mutation.target === this.table || this.colgroup.contains(mutation.target));\r\n    }\r\n}\n\nfunction createCell(cellType, cellContent) {\r\n    if (cellContent) {\r\n        return cellType.createChecked(null, cellContent);\r\n    }\r\n    return cellType.createAndFill();\r\n}\n\nfunction getTableNodeTypes(schema) {\r\n    if (schema.cached.tableNodeTypes) {\r\n        return schema.cached.tableNodeTypes;\r\n    }\r\n    const roles = {};\r\n    Object.keys(schema.nodes).forEach(type => {\r\n        const nodeType = schema.nodes[type];\r\n        if (nodeType.spec.tableRole) {\r\n            roles[nodeType.spec.tableRole] = nodeType;\r\n        }\r\n    });\r\n    schema.cached.tableNodeTypes = roles;\r\n    return roles;\r\n}\n\nfunction createTable(schema, rowsCount, colsCount, withHeaderRow, cellContent) {\r\n    const types = getTableNodeTypes(schema);\r\n    const headerCells = [];\r\n    const cells = [];\r\n    for (let index = 0; index < colsCount; index += 1) {\r\n        const cell = createCell(types.cell, cellContent);\r\n        if (cell) {\r\n            cells.push(cell);\r\n        }\r\n        if (withHeaderRow) {\r\n            const headerCell = createCell(types.header_cell, cellContent);\r\n            if (headerCell) {\r\n                headerCells.push(headerCell);\r\n            }\r\n        }\r\n    }\r\n    const rows = [];\r\n    for (let index = 0; index < rowsCount; index += 1) {\r\n        rows.push(types.row.createChecked(null, withHeaderRow && index === 0 ? headerCells : cells));\r\n    }\r\n    return types.table.createChecked(null, rows);\r\n}\n\nfunction isCellSelection(value) {\r\n    return value instanceof CellSelection;\r\n}\n\nconst deleteTableWhenAllCellsSelected = ({ editor }) => {\r\n    const { selection } = editor.state;\r\n    if (!isCellSelection(selection)) {\r\n        return false;\r\n    }\r\n    let cellCount = 0;\r\n    const table = findParentNodeClosestToPos(selection.ranges[0].$from, node => {\r\n        return node.type.name === 'table';\r\n    });\r\n    table === null || table === void 0 ? void 0 : table.node.descendants(node => {\r\n        if (node.type.name === 'table') {\r\n            return false;\r\n        }\r\n        if (['tableCell', 'tableHeader'].includes(node.type.name)) {\r\n            cellCount += 1;\r\n        }\r\n    });\r\n    const allCellsSelected = cellCount === selection.ranges.length;\r\n    if (!allCellsSelected) {\r\n        return false;\r\n    }\r\n    editor.commands.deleteTable();\r\n    return true;\r\n};\n\nconst Table = Node.create({\r\n    name: 'table',\r\n    // @ts-ignore\r\n    addOptions() {\r\n        return {\r\n            HTMLAttributes: {},\r\n            resizable: false,\r\n            handleWidth: 5,\r\n            cellMinWidth: 25,\r\n            // TODO: fix\r\n            View: TableView,\r\n            lastColumnResizable: true,\r\n            allowTableNodeSelection: false,\r\n        };\r\n    },\r\n    content: 'tableRow+',\r\n    tableRole: 'table',\r\n    isolating: true,\r\n    group: 'block',\r\n    parseHTML() {\r\n        return [\r\n            { tag: 'table' },\r\n        ];\r\n    },\r\n    renderHTML({ HTMLAttributes }) {\r\n        return ['table', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), ['tbody', 0]];\r\n    },\r\n    addCommands() {\r\n        return {\r\n            insertTable: ({ rows = 3, cols = 3, withHeaderRow = true } = {}) => ({ tr, dispatch, editor }) => {\r\n                const node = createTable(editor.schema, rows, cols, withHeaderRow);\r\n                if (dispatch) {\r\n                    const offset = tr.selection.anchor + 1;\r\n                    tr.replaceSelectionWith(node)\r\n                        .scrollIntoView()\r\n                        .setSelection(TextSelection.near(tr.doc.resolve(offset)));\r\n                }\r\n                return true;\r\n            },\r\n            addColumnBefore: () => ({ state, dispatch }) => {\r\n                return addColumnBefore(state, dispatch);\r\n            },\r\n            addColumnAfter: () => ({ state, dispatch }) => {\r\n                return addColumnAfter(state, dispatch);\r\n            },\r\n            deleteColumn: () => ({ state, dispatch }) => {\r\n                return deleteColumn(state, dispatch);\r\n            },\r\n            addRowBefore: () => ({ state, dispatch }) => {\r\n                return addRowBefore(state, dispatch);\r\n            },\r\n            addRowAfter: () => ({ state, dispatch }) => {\r\n                return addRowAfter(state, dispatch);\r\n            },\r\n            deleteRow: () => ({ state, dispatch }) => {\r\n                return deleteRow(state, dispatch);\r\n            },\r\n            deleteTable: () => ({ state, dispatch }) => {\r\n                return deleteTable(state, dispatch);\r\n            },\r\n            mergeCells: () => ({ state, dispatch }) => {\r\n                return mergeCells(state, dispatch);\r\n            },\r\n            splitCell: () => ({ state, dispatch }) => {\r\n                return splitCell(state, dispatch);\r\n            },\r\n            toggleHeaderColumn: () => ({ state, dispatch }) => {\r\n                return toggleHeader('column')(state, dispatch);\r\n            },\r\n            toggleHeaderRow: () => ({ state, dispatch }) => {\r\n                return toggleHeader('row')(state, dispatch);\r\n            },\r\n            toggleHeaderCell: () => ({ state, dispatch }) => {\r\n                return toggleHeaderCell(state, dispatch);\r\n            },\r\n            mergeOrSplit: () => ({ state, dispatch }) => {\r\n                if (mergeCells(state, dispatch)) {\r\n                    return true;\r\n                }\r\n                return splitCell(state, dispatch);\r\n            },\r\n            setCellAttribute: (name, value) => ({ state, dispatch }) => {\r\n                return setCellAttr(name, value)(state, dispatch);\r\n            },\r\n            goToNextCell: () => ({ state, dispatch }) => {\r\n                return goToNextCell(1)(state, dispatch);\r\n            },\r\n            goToPreviousCell: () => ({ state, dispatch }) => {\r\n                return goToNextCell(-1)(state, dispatch);\r\n            },\r\n            fixTables: () => ({ state, dispatch }) => {\r\n                if (dispatch) {\r\n                    fixTables(state);\r\n                }\r\n                return true;\r\n            },\r\n            setCellSelection: position => ({ tr, dispatch }) => {\r\n                if (dispatch) {\r\n                    const selection = CellSelection.create(tr.doc, position.anchorCell, position.headCell);\r\n                    // @ts-ignore\r\n                    tr.setSelection(selection);\r\n                }\r\n                return true;\r\n            },\r\n        };\r\n    },\r\n    addKeyboardShortcuts() {\r\n        return {\r\n            Tab: () => {\r\n                if (this.editor.commands.goToNextCell()) {\r\n                    return true;\r\n                }\r\n                if (!this.editor.can().addRowAfter()) {\r\n                    return false;\r\n                }\r\n                return this.editor\r\n                    .chain()\r\n                    .addRowAfter()\r\n                    .goToNextCell()\r\n                    .run();\r\n            },\r\n            'Shift-Tab': () => this.editor.commands.goToPreviousCell(),\r\n            Backspace: deleteTableWhenAllCellsSelected,\r\n            'Mod-Backspace': deleteTableWhenAllCellsSelected,\r\n            Delete: deleteTableWhenAllCellsSelected,\r\n            'Mod-Delete': deleteTableWhenAllCellsSelected,\r\n        };\r\n    },\r\n    addProseMirrorPlugins() {\r\n        const isResizable = this.options.resizable && this.editor.isEditable;\r\n        return [\r\n            ...(isResizable ? [columnResizing({\r\n                    handleWidth: this.options.handleWidth,\r\n                    cellMinWidth: this.options.cellMinWidth,\r\n                    View: this.options.View,\r\n                    // TODO: PR for @types/prosemirror-tables\r\n                    // @ts-ignore (incorrect type)\r\n                    lastColumnResizable: this.options.lastColumnResizable,\r\n                })] : []),\r\n            tableEditing({\r\n                allowTableNodeSelection: this.options.allowTableNodeSelection,\r\n            }),\r\n        ];\r\n    },\r\n    extendNodeSchema(extension) {\r\n        const context = {\r\n            name: extension.name,\r\n            options: extension.options,\r\n            storage: extension.storage,\r\n        };\r\n        return {\r\n            tableRole: callOrReturn(getExtensionField(extension, 'tableRole', context)),\r\n        };\r\n    },\r\n});\n\nexport { Table, createTable, Table as default };\n//# sourceMappingURL=tiptap-extension-table.esm.js.map\n"],"names":["readFromCache","addToCache","WeakMap","cache","key","get","value","set","cacheSize","cachePos","i","length","Rect","constructor","left","top","right","bottom","this","TableMap","width","height","map","problems","findCell","pos","curPos","j","RangeError","colCount","nextCell","axis","dir","rectBetween","a","b","leftA","rightA","topA","bottomA","leftB","rightB","topB","bottomB","Math","min","max","cellsInRect","rect","result","seen","row","col","index","push","positionAt","table","rowStart","rowEnd","child","nodeSize","rowEndIndex","static","type","spec","tableRole","name","hasRowSpan","childCount","rowNode","rowWidth","prevRow","cell","attrs","rowspan","colspan","findWidth","mapPos","colWidths","e","cellNode","colwidth","h","n","start","w","colW","widthIndex","prev","expectedPos","missing","tableMap","badWidths","node","nodeAt","updated","colWidth","freshColWidth","unshift","findBadColWidths","computeMap","slice","tableNodeTypes","schema","cached","nodes","role","key$1","cellAround","$pos","d","depth","resolve","before","isInTable","state","$head","selection","selectionCell","sel","$anchorCell","$headCell","$anchor","after","nodeAfter","firstChild","doc","nodeBefore","lastChild","cellNear","pointsAtCell","parent","inSameTable","$a","$b","end","moved","setAttr","prop","removeColSpan","splice","some","addColSpan","CellSelection","cells","filter","p","ranges","from","content","size","super","$from","$to","mapping","tableChanged","isRowSelection","rowSelection","isColSelection","colSelection","rows","rowContent","cellRect","extraLeft","extraRight","createAndFill","create","copy","fragment","replace","tr","mapFrom","steps","to","setSelection","replaceWith","forEachCell","f","anchorTop","headTop","anchorBot","headBot","anchorRect","headRect","anchorLeft","headLeft","anchorRight","headRight","eq","other","toJSON","anchor","head","json","anchorCell","headCell","getBookmark","CellBookmark","prototype","visible","drawCellSelection","class","pastedCells","openStart","openEnd","first","fitSlice","widths","r","empty","append","ensureRectangular","nodeType","isolateHorizontal","found","cellTop","cellLeft","setNodeMarkup","insert","isolateVertical","updatePos","insertCells","dispatch","tableStart","recomp","maps","emptyHead","types","add","header_cell","header","emptyRow","growTable","handleKeyDown","ArrowLeft","arrow","ArrowRight","ArrowUp","ArrowDown","shiftArrow","Backspace","deleteCellSelection","Delete","maybeSetSelection","scrollIntoView","view","atEndOfCell","newSel","$cell","$next","baseContent","docChanged","handleTripleClick","handlePaste","_","newWidth","newHeight","added","newRows","frag","source","clipCells","handleMouseDown$1","startEvent","ctrlKey","metaKey","startDOMCell","domInCell","target","shiftKey","setCellSelection","preventDefault","cellUnderMouse","event","starting","getState","setMeta","stop","root","removeEventListener","move","addEventListener","indexAfter","cellPos","dirStr","endOfTextblock","dom","parentNode","nodeName","mousePos","posAtCoords","clientX","clientY","fixTablesKey","changedDescendants","old","cur","offset","oldSize","curSize","outer","scan","sameMarkup","nodesBetween","fixTables","oldState","check","tablePos","last","mustAdd","prob","tableNodeType","side","fixTable","descendants","selectedRect","addColumn","refColumn","headerCell","columnIsHeader","removeColumn","mapStart","delete","addRow","rowPos","refRow","rowIsHeader","removeRow","nextRow","newPos","isEmpty","c","isTextblock","mergeCells","indexTop","indexLeft","indexBottom","indexRight","cellsOverlapRectangle","mergedPos","mergedCell","mapped","splitCell","nodeTypes","getCellType","cellWrapping","baseAttrs","lastCell","isHeaderEnabledByType","cellPositions","toggleHeader","options","useDeprecatedLogic","deprecated_toggleHeader","isHeaderRowEnabled","isHeaderColumnEnabled","selectionStartsAt","cellsRect","newType","forEach","relativeCellPos","toggleHeaderCell","goToNextCell","direction","findNextCell","TableView","cellMinWidth","document","createElement","className","appendChild","colgroup","updateColumns","contentDOM","update","ignoreMutation","record","contains","overrideCol","overrideValue","totalWidth","fixedWidth","nextDOM","hasWidth","cssWidth","style","nextSibling","removeChild","minWidth","columnResizing","handleWidth","View","lastColumnResizable","plugin","init","props","nodeViews","ResizeState","apply","attributes","activeHandle","handleDOMEvents","mousemove","pluginState","dragging","classList","domCellAround","getBoundingClientRect","edgeCell","updateHandle","handleMouseMove","mouseleave","handleMouseLeave","mousedown","domAtPos","domWidth","childNodes","offsetWidth","parts","currentColWidth","finish","window","mapIndex","zeroes","updateColumnWidth","draggedWidth","setDragging","which","dragged","displayColumnWidth","startX","startWidth","handleMouseDown","decorations","handleDecorations","action","getMeta","setHandle","undefined","handle","indexOf","tableEditing","allowTableNodeSelection","deleted","mapResult","createSelectionBetween","appendTransaction","normalize","afterFrom","beforeTo","test","isCellBoundarySelection","fromCellBoundaryNode","toCellBoundaryNode","parentOffset","isTextSelectionAcrossCells","normalizeSelection","mutation","createCell","cellType","cellContent","createChecked","createTable","rowsCount","colsCount","withHeaderRow","roles","Object","keys","getTableNodeTypes","headerCells","deleteTableWhenAllCellsSelected","editor","cellCount","findParentNodeClosestToPos","includes","commands","deleteTable","Table","Node","addOptions","HTMLAttributes","resizable","isolating","group","parseHTML","tag","renderHTML","mergeAttributes","addCommands","insertTable","cols","replaceSelectionWith","addColumnBefore","addColumnAfter","deleteColumn","addRowBefore","addRowAfter","deleteRow","toggleHeaderColumn","toggleHeaderRow","mergeOrSplit","setCellAttribute","setCellAttr","goToPreviousCell","position","addKeyboardShortcuts","Tab","can","chain","run","addProseMirrorPlugins","isEditable","extendNodeSchema","extension","context","storage","callOrReturn","getExtensionField"],"sourceRoot":""}